<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>Semi-Lagrangian Library: sll_m_low_level_bsplines Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div align=right><a href="https://github.com/selalib/selalib/issues/new"><small>Report Typos and Errors &nbsp; &nbsp;</small></a></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="selalib.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Semi-Lagrangian Library
   </div>
   <div id="projectbrief">Modular library for kinetic and gyrokinetic simulations of plasmas in fusion energy devices.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Derived types and interfaces</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sll_m_low_level_bsplines Module Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Low level arbitrary degree splines. </p>
<p>This module defines low level algorithms for arbitrary degree splines. For non periodic boundary conditions, knots defined from a grid are either duplicated (open knot sequence) or mirror outside boundary. It is a selalib implementation of the classical algorithms found in the de Boor book "A Practical Guide to Splines" or the NURBS book by Piegl and Tiller. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Derived types and interfaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html">sll_t_bsplines</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information for evaluation of B-splines on non-uniform grid.  <a href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ab23ac5ba62ba1ea6be3b1f292c1d67f9"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__low__level__bsplines.html#ab23ac5ba62ba1ea6be3b1f292c1d67f9">sll_s_bsplines_init_from_grid</a> (basis, degree, grid, bc_xmin, bc_xmax)</td></tr>
<tr class="memdesc:ab23ac5ba62ba1ea6be3b1f292c1d67f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build new <a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html" title="Information for evaluation of B-splines on non-uniform grid.">sll_t_bsplines</a> object based on a on a grid of strictly increasing points including the last point also for periodic domains.  <a href="namespacesll__m__low__level__bsplines.html#ab23ac5ba62ba1ea6be3b1f292c1d67f9">More...</a><br /></td></tr>
<tr class="separator:ab23ac5ba62ba1ea6be3b1f292c1d67f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7388ffef0e36d4229d08912dcaff8"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__low__level__bsplines.html#ad4d7388ffef0e36d4229d08912dcaff8">sll_s_bsplines_init_from_knots</a> (basis, degree, n, knots)</td></tr>
<tr class="memdesc:ad4d7388ffef0e36d4229d08912dcaff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build new <a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html" title="Information for evaluation of B-splines on non-uniform grid.">sll_t_bsplines</a> object.  <a href="namespacesll__m__low__level__bsplines.html#ad4d7388ffef0e36d4229d08912dcaff8">More...</a><br /></td></tr>
<tr class="separator:ad4d7388ffef0e36d4229d08912dcaff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8bf123f17051029ab6fb91416eaeae"><td class="memItemLeft" align="right" valign="top">pure integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__low__level__bsplines.html#afa8bf123f17051029ab6fb91416eaeae">sll_f_find_cell</a> (basis, x)</td></tr>
<tr class="memdesc:afa8bf123f17051029ab6fb91416eaeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">return index i of grid cell such that: basisknots(i) &lt;= x &lt;= basisknots(i+1).  <a href="namespacesll__m__low__level__bsplines.html#afa8bf123f17051029ab6fb91416eaeae">More...</a><br /></td></tr>
<tr class="separator:afa8bf123f17051029ab6fb91416eaeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f0d550b3c5485714b1306a78afd08f"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__low__level__bsplines.html#ac5f0d550b3c5485714b1306a78afd08f">sll_s_bsplines_free</a> (spline)</td></tr>
<tr class="memdesc:ac5f0d550b3c5485714b1306a78afd08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates B-spline values at a point x in a given cell.  <a href="namespacesll__m__low__level__bsplines.html#ac5f0d550b3c5485714b1306a78afd08f">More...</a><br /></td></tr>
<tr class="separator:ac5f0d550b3c5485714b1306a78afd08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a572601519dfd43a8990fcc72c97f14c9"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__low__level__bsplines.html#a572601519dfd43a8990fcc72c97f14c9">wp</a> = f64</td></tr>
<tr class="memdesc:a572601519dfd43a8990fcc72c97f14c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Working precision.  <a href="namespacesll__m__low__level__bsplines.html#a572601519dfd43a8990fcc72c97f14c9">More...</a><br /></td></tr>
<tr class="separator:a572601519dfd43a8990fcc72c97f14c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463dc83e3096604da432f3bb20864351"><td class="memItemLeft" align="right" valign="top">integer, dimension(1:3), parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__low__level__bsplines.html#a463dc83e3096604da432f3bb20864351">allowed_bcs</a> = [sll_p_periodic, sll_p_open, sll_p_mirror]</td></tr>
<tr class="memdesc:a463dc83e3096604da432f3bb20864351"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of allowed boundary conditions.  <a href="namespacesll__m__low__level__bsplines.html#a463dc83e3096604da432f3bb20864351">More...</a><br /></td></tr>
<tr class="separator:a463dc83e3096604da432f3bb20864351"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="afa8bf123f17051029ab6fb91416eaeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8bf123f17051029ab6fb91416eaeae">&#9670;&nbsp;</a></span>sll_f_find_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function, public sll_m_low_level_bsplines::sll_f_find_cell </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html">sll_t_bsplines</a>), intent(in)&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(<a class="el" href="namespacesll__m__low__level__bsplines.html#a572601519dfd43a8990fcc72c97f14c9">wp</a>), intent(in)&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return index i of grid cell such that: basisknots(i) &lt;= x &lt;= basisknots(i+1). </p>
<p>@detail If x is not between basisknots(1) and basisknots(basisnum_pts), then the value -1 is returned. </p>

<p class="definition">Definition at line <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html#l00339">339</a> of file <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html">sll_m_low_level_bsplines.F90</a>.</p>

</div>
</div>
<a id="ac5f0d550b3c5485714b1306a78afd08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f0d550b3c5485714b1306a78afd08f">&#9670;&nbsp;</a></span>sll_s_bsplines_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public sll_m_low_level_bsplines::sll_s_bsplines_free </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html">sll_t_bsplines</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>spline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates B-spline values at a point x in a given cell. </p>
<p>sll_s_bsplines_eval_basis( basis, cell, x, splines_at_x ) computes the values of all the splines which have support in 'cell' and evaluates them at point 'x', which is supposed to be in cell. The spline object should have already been initialized and will contain information on the spline degree to use and the type of boundary condition desired. The algorithm implemented is numerically stable and known as The Cox - de Boor algorithm, which is a generalisation to splines of the de Casteljau algorithm for Bezier curves. </p><dl class="section return"><dt>Returns</dt><dd>b_spline_at_x B-spline values</dd></dl>
<p>returns first derivative values at x of all b-splines with support in cell</p>
<p>sll_s_bsplines_eval_deriv returns an array with the derivative values of the B-splines of a requested order that are supported in 'cell' and evaluated at 'x'. Algorithm derived from algorithm A3.2 of NURBS book The return value has the format: </p><p class="formulaDsp">
\[ B&#39;[deg,i-deg](x), B&#39;[deg,i-deg+1](x), ..., B&#39;[deg,i](x) \]
</p>
<p> where 'deg' is the degree of the spline. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">bsdx</td><td>B-spline derivatives</td></tr>
  </table>
  </dd>
</dl>
<p>returns splines and first derivatives</p>
<p>See sll_s_bsplines_eval_deriv and sll_f_splines_at_x </p><dl class="section return"><dt>Returns</dt><dd>b_spline_and_derivs_at_x B-spline values and derivatives</dd></dl>
<p>returns splines and first derivatives</p>
<p>See sll_s_bsplines_eval_deriv and sll_f_splines_at_x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basis</td><td>bspline object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">icell</td><td>cell where bsplines are to be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>value of point where bsplines are to be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of derivatives to be computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bsdx</td><td>B-spline values and the first n derivatives</td></tr>
  </table>
  </dd>
</dl>
<p>Alternative direct implentation of recursion formula.</p>
<p>@detail This provides an evaluation of B-splines directly based on the recurrence formula. It is 10% faster than the classical Cox - de Boor formula that is implented in sll_f_splines_at_x, but can have numerical stability issues. For this reason the Cox - de Boor formula should be the default implementation</p>
<p>Alternative direct implentation of recursion formula.</p>
<p>@detail This provides an evaluation of B-splines directly based on the recurrence formula. It is about 80% faster than the classical Cox - de Boor formula that is implented in sll_f_splines_at_x, but can have numerical stability issues. For this reason the Cox - de Boor formula should be the default implementation </p>

<p class="definition">Definition at line <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html#l00842">842</a> of file <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html">sll_m_low_level_bsplines.F90</a>.</p>

</div>
</div>
<a id="ab23ac5ba62ba1ea6be3b1f292c1d67f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23ac5ba62ba1ea6be3b1f292c1d67f9">&#9670;&nbsp;</a></span>sll_s_bsplines_init_from_grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public sll_m_low_level_bsplines::sll_s_bsplines_init_from_grid </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html">sll_t_bsplines</a>), intent(out)&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(<a class="el" href="namespacesll__m__low__level__bsplines.html#a572601519dfd43a8990fcc72c97f14c9">wp</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>bc_xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>bc_xmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build new <a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html" title="Information for evaluation of B-splines on non-uniform grid.">sll_t_bsplines</a> object based on a on a grid of strictly increasing points including the last point also for periodic domains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">basis</td><td>arbitrary_degree_spline_1d object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>spline_degree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>x coordinates of grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_pts</td><td>number of grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc_xmin</td><td>boundary condition at xmin [periodic/open/mirror] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc_xmax</td><td>boundary condition at xmax [periodic/open/mirror]</td></tr>
  </table>
  </dd>
</dl>
<p>The logic behind the periodic boundary condition is the following. The given grid array has minimum (grid(1)) and maximum (grid(n)) values at either end. This defines a length 'L'. If interpreted as a periodic space, this is also the period. Thus, as we extend the number of knots at both ends of the given array, we use the periodicity condition to fill out the new values: </p><pre class="fragment">               .
               .
               .
      knots(-1) = knots(n-2) - L
      knots( 0) = knots(n-1) - L
               .
               .
               .
      knots(n+1) = knots(1) + L
      knots(n+2) = knots(2) + L
               .
               .
               .
</pre><p> The 'open' boundary condition simply extends the new values of the local array at both ends with repeated endpoint values. That is </p><pre class="fragment">... = knots(-2) = knots(-1) = knots(0) = knots(1)
</pre><p> and</p>
<p>knots(n+1) = knots(n+2) = knots(n+3) = ... = knots(n)</p>
<p>The mirror boundary condition mirrors the knot values on each side of the grid of the local array at both ends with repeated endpoint values. That is </p><pre class="fragment">... =  = knots(-1) = knots(0) = knots(1)
</pre><p> and</p>
<p>knots(n+1) = knots(n+2) = knots(n+3) = ... = knots(n) </p>

<p class="definition">Definition at line <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html#l00145">145</a> of file <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html">sll_m_low_level_bsplines.F90</a>.</p>

</div>
</div>
<a id="ad4d7388ffef0e36d4229d08912dcaff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d7388ffef0e36d4229d08912dcaff8">&#9670;&nbsp;</a></span>sll_s_bsplines_init_from_knots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public sll_m_low_level_bsplines::sll_s_bsplines_init_from_knots </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html">sll_t_bsplines</a>), intent(out)&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(<a class="el" href="namespacesll__m__low__level__bsplines.html#a572601519dfd43a8990fcc72c97f14c9">wp</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>knots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build new <a class="el" href="structsll__m__low__level__bsplines_1_1sll__t__bsplines.html" title="Information for evaluation of B-splines on non-uniform grid.">sll_t_bsplines</a> object. </p>
<p>based on a given array of knots which is a non decreasing array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">basis</td><td>spline object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degree</td><td>spline degree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>dimension of spline space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knots</td><td>array of give knots </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html#l00289">289</a> of file <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html">sll_m_low_level_bsplines.F90</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a463dc83e3096604da432f3bb20864351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463dc83e3096604da432f3bb20864351">&#9670;&nbsp;</a></span>allowed_bcs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer, dimension(1:3), parameter allowed_bcs = [sll_p_periodic, sll_p_open, sll_p_mirror]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of allowed boundary conditions. </p>

<p class="definition">Definition at line <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html#l00072">72</a> of file <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html">sll_m_low_level_bsplines.F90</a>.</p>

</div>
</div>
<a id="a572601519dfd43a8990fcc72c97f14c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572601519dfd43a8990fcc72c97f14c9">&#9670;&nbsp;</a></span>wp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer, parameter wp = f64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Working precision. </p>

<p class="definition">Definition at line <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html#l00069">69</a> of file <a class="el" href="sll__m__low__level__bsplines_8_f90_source.html">sll_m_low_level_bsplines.F90</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/>
<div id="url"></div>
<div align=left><a href="https://github.com/selalib/selalib/issues/new"><small>&nbsp; &nbsp; Report Typos and Errors</small></a></div>
<address class="footer"><small>
Generated on Tue Sep 5 2023 15:59:31 for Semi-Lagrangian Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
