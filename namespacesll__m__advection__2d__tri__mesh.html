<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Semi-Lagrangian Library: sll_m_advection_2d_tri_mesh Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div align=right><a href="https://github.com/selalib/selalib/issues/new"><small>Report Typos and Errors &nbsp; &nbsp;</small></a></div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="selalib.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Semi-Lagrangian Library
   </div>
   <div id="projectbrief">Modular library for kinetic and gyrokinetic simulations of plasmas in fusion energy devices.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Derived types and interfaces</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">sll_m_advection_2d_tri_mesh Module Reference<div class="ingroups"><a class="el" href="group__advection.html">sll_advection</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>advection on triangular mesh. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Derived types and interfaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsll__m__advection__2d__tri__mesh_1_1sll__t__advection__tri__mesh.html">sll_t_advection_tri_mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2d advection on triangular mesh  <a href="structsll__m__advection__2d__tri__mesh_1_1sll__t__advection__tri__mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a11366caa4d5002d69a7767758b1c79c1"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structsll__m__advection__2d__tri__mesh_1_1sll__t__advection__tri__mesh.html">sll_t_advection_tri_mesh</a>) function, pointer, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__advection__2d__tri__mesh.html#a11366caa4d5002d69a7767758b1c79c1">sll_f_new_advection_2d_tri_mesh</a> (mesh)</td></tr>
<tr class="memdesc:a11366caa4d5002d69a7767758b1c79c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates the memory space for a new 2D advection on triangular mesh on the heap, initializes it with the given triangular mesh and returns a pointer to the object.  <a href="#a11366caa4d5002d69a7767758b1c79c1">More...</a><br /></td></tr>
<tr class="separator:a11366caa4d5002d69a7767758b1c79c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1061521adff89f1b423b04e769beaa4f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__advection__2d__tri__mesh.html#a1061521adff89f1b423b04e769beaa4f">compute_derivatives</a> (f_val, f_der, f_der2, degree, epsilon)</td></tr>
<tr class="memdesc:a1061521adff89f1b423b04e769beaa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes degrees of freedom on one point.  <a href="#a1061521adff89f1b423b04e769beaa4f">More...</a><br /></td></tr>
<tr class="separator:a1061521adff89f1b423b04e769beaa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ac23f99a7ee53064250c6de66bdf13"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__advection__2d__tri__mesh.html#af7ac23f99a7ee53064250c6de66bdf13">compute_coordinates_dof</a> (x1_adv, x2_adv, x1_coo, x2_coo, degree, epsilon, x1_dof, x2_dof)</td></tr>
<tr class="memdesc:af7ac23f99a7ee53064250c6de66bdf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the coordinates of the poisition of the degrees of freedom (dof)  <a href="#af7ac23f99a7ee53064250c6de66bdf13">More...</a><br /></td></tr>
<tr class="separator:af7ac23f99a7ee53064250c6de66bdf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebc6b0eb356eb1fa96670bb4291b04c"><td class="memItemLeft" align="right" valign="top">real(kind=f64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__advection__2d__tri__mesh.html#aeebc6b0eb356eb1fa96670bb4291b04c">eval_at_lambda</a> (lam, func_loc, der_loc, der2_loc)</td></tr>
<tr class="memdesc:aeebc6b0eb356eb1fa96670bb4291b04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluation at barycentric points of one cell  <a href="#aeebc6b0eb356eb1fa96670bb4291b04c">More...</a><br /></td></tr>
<tr class="separator:aeebc6b0eb356eb1fa96670bb4291b04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86e3b294bd94fdd9504000c526f328f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__advection__2d__tri__mesh.html#ac86e3b294bd94fdd9504000c526f328f">interpolation_mitchell</a> ()</td></tr>
<tr class="separator:ac86e3b294bd94fdd9504000c526f328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d6eb364b1aab8ad62ef9f872eae19"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesll__m__advection__2d__tri__mesh.html#a988d6eb364b1aab8ad62ef9f872eae19">sll_s_advection_2d</a> (adv, f_in, ex, ey, dt)</td></tr>
<tr class="memdesc:a988d6eb364b1aab8ad62ef9f872eae19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute characterisitic origin in triangular mesh.  <a href="#a988d6eb364b1aab8ad62ef9f872eae19">More...</a><br /></td></tr>
<tr class="separator:a988d6eb364b1aab8ad62ef9f872eae19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="af7ac23f99a7ee53064250c6de66bdf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ac23f99a7ee53064250c6de66bdf13">&#9670;&nbsp;</a></span>compute_coordinates_dof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine sll_m_advection_2d_tri_mesh::compute_coordinates_dof </td>
          <td>(</td>
          <td class="paramtype">real(kind=f64), intent(in)&#160;</td>
          <td class="paramname"><em>x1_adv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), intent(in)&#160;</td>
          <td class="paramname"><em>x2_adv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>x1_coo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>x2_coo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(:), intent(out)&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), intent(in)&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(:), intent(out)&#160;</td>
          <td class="paramname"><em>x1_dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(:), intent(out)&#160;</td>
          <td class="paramname"><em>x2_dof</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the coordinates of the poisition of the degrees of freedom (dof) </p>
<p>computes the coordinates of the poisition of the degrees of freedom (dof) in respect to a point (advected or not). These positions won't be really advected because they are at a small distance from the meshes nodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1_adv</td><td>real first coordinate of a mesh point (advected or not) </td></tr>
    <tr><td class="paramname">x2_adv</td><td>real second coordinate of a mesh point (advected or not) </td></tr>
    <tr><td class="paramname">x1_coo</td><td>real vector first coordinates of neighbouring vertices </td></tr>
    <tr><td class="paramname">x2_coo</td><td>real vector second coordinates of neighbouring vertices </td></tr>
    <tr><td class="paramname">degree</td><td>int containing the degree of the triangulation (ie the number of cells that have the point (x1_adv, x2_adv). </td></tr>
    <tr><td class="paramname">epsilon</td><td>real containting the small displacement of the dof </td></tr>
    <tr><td class="paramname">x1_dof</td><td>real vector containing the computed first coordinates of the dof </td></tr>
    <tr><td class="paramname">x2_dof</td><td>real vector containing the computed second coordinates of the dof </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html#l00175">175</a> of file <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html">sll_m_advection_2d_tri_mesh.F90</a>.</p>

</div>
</div>
<a id="a1061521adff89f1b423b04e769beaa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1061521adff89f1b423b04e769beaa4f">&#9670;&nbsp;</a></span>compute_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine sll_m_advection_2d_tri_mesh::compute_derivatives </td>
          <td>(</td>
          <td class="paramtype">intent(in)&#160;</td>
          <td class="paramname"><em>f_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intent(out)&#160;</td>
          <td class="paramname"><em>f_der</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intent(out)&#160;</td>
          <td class="paramname"><em>f_der2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intent(in)&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intent(in)&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes degrees of freedom on one point. </p>
<p>Computes on a point the degrees of freedom (dof): For every annexing triangle we compute the first derivatives (following the triangle edges e1, e2, and e3) and the crossed derivatives (following e1+e2, e2+e3, and e1+e3). they are computed using the values of the function at the vertices.  f_val [intent IN] real vector containing the function values at the vertices of annexing triangles  f_der [intent OUT] real vector containing the values of the first derivatives following the vertices  f_der2 [intent OUT] real vector containing the values of the second derivatives aka. crossed derivatives (see details)  degree [intent IN] integer value of the number of cells parting from the point  epsilon [intent IN] real value of the small distance to compute the dof </p>

<p class="definition">Definition at line <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html#l00139">139</a> of file <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html">sll_m_advection_2d_tri_mesh.F90</a>.</p>

</div>
</div>
<a id="aeebc6b0eb356eb1fa96670bb4291b04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebc6b0eb356eb1fa96670bb4291b04c">&#9670;&nbsp;</a></span>eval_at_lambda()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">real(kind=f64) function sll_m_advection_2d_tri_mesh::eval_at_lambda </td>
          <td>(</td>
          <td class="paramtype">real(kind=f64), dimension(3), intent(in)&#160;</td>
          <td class="paramname"><em>lam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(3), intent(in)&#160;</td>
          <td class="paramname"><em>func_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(6), intent(in)&#160;</td>
          <td class="paramname"><em>der_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(3), intent(in)&#160;</td>
          <td class="paramname"><em>der2_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>evaluation at barycentric points of one cell </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lam</td><td>real vector containing the barycentric coordinates of the edges of the cell </td></tr>
    <tr><td class="paramname">func_loc</td><td>real vector containg values of the function at dof points of one cell func_loc = [f1, f2, f3] </td></tr>
    <tr><td class="paramname">der_loc</td><td>real vector containg values of the derivatives at dof points of one cell (edge by edge) der_loc = [df12, df13, df23, df21, df31, df32] </td></tr>
    <tr><td class="paramname">der2_loc</td><td>real vector containg values of the 2nd derivatives at dof points one cell (edge by edge) func_loc = [d2f1, d2f2, d2f3] </td></tr>
  </table>
  </dd>
</dl>
<p>Sum over functions at edges func_loc = [f1, f2, f3] formula: out += fi * lam(i)**2 * ((3-2*lam(i) + 6*lam(j)*lam(k)) where i, j, k are the edges of the cell/triangle</p>
<p>der_loc = [df12, df13, df23, df21, df31, df32] fomula : out += dfij * lamb(i)**2 * lam(j) * (1 + 2 * lam(k)) where i, j, k are the edges of the cell/triangle</p>
<p>Sum over second derivatives func_loc = [d2f1, d2f2, d2f3] formula: out += d2fi * lam(i)**2 * lam(j) * lam(k) where i, j, k are the edges of the cell/triangle </p>

<p class="definition">Definition at line <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html#l00213">213</a> of file <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html">sll_m_advection_2d_tri_mesh.F90</a>.</p>

</div>
</div>
<a id="ac86e3b294bd94fdd9504000c526f328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86e3b294bd94fdd9504000c526f328f">&#9670;&nbsp;</a></span>interpolation_mitchell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine sll_m_advection_2d_tri_mesh::interpolation_mitchell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html#l00249">249</a> of file <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html">sll_m_advection_2d_tri_mesh.F90</a>.</p>

</div>
</div>
<a id="a11366caa4d5002d69a7767758b1c79c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11366caa4d5002d69a7767758b1c79c1">&#9670;&nbsp;</a></span>sll_f_new_advection_2d_tri_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structsll__m__advection__2d__tri__mesh_1_1sll__t__advection__tri__mesh.html">sll_t_advection_tri_mesh</a>) function, pointer, public sll_m_advection_2d_tri_mesh::sll_f_new_advection_2d_tri_mesh </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsll__m__triangular__meshes_1_1sll__t__triangular__mesh__2d.html">sll_t_triangular_mesh_2d</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates the memory space for a new 2D advection on triangular mesh on the heap, initializes it with the given triangular mesh and returns a pointer to the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>triangular mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html#l00061">61</a> of file <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html">sll_m_advection_2d_tri_mesh.F90</a>.</p>

</div>
</div>
<a id="a988d6eb364b1aab8ad62ef9f872eae19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988d6eb364b1aab8ad62ef9f872eae19">&#9670;&nbsp;</a></span>sll_s_advection_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public sll_m_advection_2d_tri_mesh::sll_s_advection_2d </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsll__m__advection__2d__tri__mesh_1_1sll__t__advection__tri__mesh.html">sll_t_advection_tri_mesh</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>adv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>f_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>ey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(kind=f64), intent(in)&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute characterisitic origin in triangular mesh. </p>
<p>xlm1 - 1ere coordonnee barycentrique xlm2 - 2eme coordonnee barycentrique xlm3 - 3eme coordonnee barycentrique</p>
<p>coord - coordonnees des noeuds nodes - numero des sommets des triangles nvois - numero des voisins des elements aire - aire de chaque element</p>
<p>coef1 - tableau temporaire des determinants coef2 - tableau temporaire des determinants coef3 - tableau temporaire des determinants coef4 - tableau temporaire</p>
<p>numpt - tableau auxiliaire contenant les numeros des particules a eliminer nelet - tableau auxiliaire contenant les numeros des elements qui contenaient ces particules nlmloc - tableau auxiliaire contenant les numeros des elements ou l'on cherche les particules numres - tableau auxiliaire contenant les numeros des particules non encore localisees</p>
<p>itest - tableau auxiliaire pour preciser le comportement:</p><ul>
<li>si itest=0 la particules reste dans son triangle</li>
<li>si itest=1,2,3 la particule traverse le cote 1,2ou3 mais ne traverse pas de frontiere</li>
<li>si itest=11,12,13 la particule est absorbee par le cote frontiere 1,2,3</li>
<li>si itest=21,22,23 la particule est reflechie par le cote frontiere 1,2,3 Dans tous les cas le chiffre des unites de itest designe le numero du cote traverse par la particule. Le type de frontiere est defini dans le tableau nvoiv</li>
<li>si nvoiv(i,n) &gt; 0 le cote i n'est pas une frontiere</li>
<li>si nvoiv(i,n) = 0 le cote i absorbe les particules</li>
<li>si nvoiv(i,n) =-1 le cote i reflechit les particules</li>
</ul>
<p>nbpert - nombre de particules a eliminer rho - densite de charge ad1 - tableau temporaire (adresse de la 1ere particule de chaque maille dans le tableau ordonne des particules) indice - tableau temporaire (incrementation du nombre de particules dja reperees) itabor - tableau temporaire (numeros des particules ordonnes suivant les numeros des mailles) nbpama - tableau temporaire (nombre de particules par maille)</p>
<p>petitl - petite longueur de reference</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">adv</td><td>mesh</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f_in</td><td>distribution function on nodes</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ex</td><td>electric field on x1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ey</td><td>electric field on x2</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>time step </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html#l00307">307</a> of file <a class="el" href="sll__m__advection__2d__tri__mesh_8_f90_source.html">sll_m_advection_2d_tri_mesh.F90</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/>
<div id="url"></div>
<div align=left><a href="https://github.com/selalib/selalib/issues/new"><small>&nbsp; &nbsp; Report Typos and Errors</small></a></div>
<address class="footer"><small>
Generated on Sat Mar 13 2021 15:26:55 for Semi-Lagrangian Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
