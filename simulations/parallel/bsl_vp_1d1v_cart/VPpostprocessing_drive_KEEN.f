! Program 'VPpostprocessing'. Post-process data generated by 'VP1DMS.f'.
! Compile with:
! gfortran -O3 VPpostprocessing_drive_KEEN.f dfftpack.f -o postproc_drive
program VPpostprocessing_drive

   implicit none
   integer N, Nv, Nt, i, j, nsave, nsavef, it, mbox
   integer nmovierho, nmovieefield, nmoviedeltaf, ivmin, ivmax
   integer modeorder, nmovieEdr, nharmonics, nsavef1, nsavef2
   integer ierr, numarg
   !parameter (N=1024, Nv=4096)
   double precision pi, dt, k0
   !integer  Nout, nrho,
   !double precision eps, f0_max, t,
   double precision vxmax, vxmin, Tmax, L
   double precision Edrmax
   double precision omega0, Tsetup, vrangemax, vrangemin
   real(8), allocatable :: rhotot(:), efield(:), deltaf(:, :)
   double precision max_delta_f, min_delta_f !,  entropy
   real(8), allocatable :: x(:), v(:)
   double precision rhofundamental, efieldfundamental, Q
   real(8), allocatable :: rhoharmonics(:)
   real(8), allocatable :: rhoharmonicsre(:), rhoharmonicsim(:)
   double precision dk, k, vphase, dv
   real(8), allocatable :: rho_from_E(:), phi(:), f0(:, :)
   double precision entropy1, entropy2, f, adr, KE, ESE, intf
   real(8), allocatable :: Edr(:), distv(:), distv0(:)
   complex(8), allocatable :: table(:), efieldft(:), rhoft(:)
   complex(8), allocatable :: frowft(:), f_kx_v(:, :), phift(:)
   complex(8) :: ii
   real(8), allocatable :: abs_f_kx_v(:, :), re_f_kx_v(:, :)
   real(8), allocatable :: im_f_kx_v(:, :)
   character(len=256) :: rundir
   double precision tflat, tL, tR, twL, twR
   ! These variables have to do with partition
   !integer N_orange, N_blue
   !double precision part_boundaries(10)
   real(8), allocatable :: orange_v(:), orange_f(:)
   real(8), allocatable :: blue_v(:), blue_f(:)

   ! This is the velocity range to be written out
   vrangemax = 4.0_8
   vrangemin = 0._8

   ! Constants
   pi = 3.1415926535897932385_8
   ii = cmplx(0, 1, 8)

   ! get run directory
   numarg = command_argument_count()
   if (numarg > 0) then
      call get_command_argument(1, rundir)
   else
      print *, 'Error: rundir not defined'
      stop
   end if

   ! Read in run parameters
   open (unit=50, file=trim(rundir)//'/parameters.dat')
   read (50, *) Tmax
   read (50, *) dt
   read (50, *) Nt
   read (50, *) k0
   read (50, *) omega0
   read (50, *) L
   read (50, *) mbox
   read (50, *) Edrmax
   read (50, *) nsave
   read (50, *) nsavef1
   read (50, *) nsavef2
   read (50, *) Tsetup
   read (50, *) vxmax
   read (50, *) vxmin
   read (50, *) N
   read (50, *) Nv
   ! added ES
   read (50, *) tL
   read (50, *) tR
   read (50, *) twL
   read (50, *) twR
   read (50, *) tflat
   close (50)

   open (unit=50, file=trim(rundir)//'/parameters.txt')
   write (50, *) Tmax
   write (50, *) dt
   write (50, *) Nt
   write (50, *) k0
   write (50, *) omega0
   write (50, *) L
   write (50, *) mbox
   write (50, *) Edrmax
   write (50, *) nsave
   write (50, *) nsavef1
   write (50, *) nsavef2
   write (50, *) Tsetup
   write (50, *) vxmax
   write (50, *) vxmin
   write (50, *) N
   write (50, *) Nv
   write (50, *) tL
   write (50, *) tR
   write (50, *) twL
   write (50, *) twR
   write (50, *) tflat
   close (50)

   !    allocate matrices
   allocate (rhotot(N), STAT=ierr)
   allocate (efield(N), STAT=ierr)
   allocate (deltaf(N, Nv), STAT=ierr)
   allocate (x(N), STAT=ierr)
   allocate (v(Nv), STAT=ierr)
   allocate (rhoharmonics(N), STAT=ierr)
   allocate (rhoharmonicsre(N), STAT=ierr)
   allocate (rhoharmonicsim(N), STAT=ierr)
   allocate (rho_from_E(N), STAT=ierr)
   allocate (phi(N), STAT=ierr)
   allocate (f0(N, Nv), STAT=ierr)
   allocate (Edr(N), STAT=ierr)
   allocate (distv(Nv), STAT=ierr)
   allocate (distv0(Nv), STAT=ierr)
   allocate (table(15 + 4*N), STAT=ierr)
   allocate (efieldft(N), STAT=ierr)
   allocate (rhoft(N), STAT=ierr)
   allocate (phift(N), STAT=ierr)
   allocate (frowft(N), STAT=ierr)
   allocate (f_kx_v(N, Nv), STAT=ierr)
   allocate (abs_f_kx_v(N, Nv), STAT=ierr)
   allocate (re_f_kx_v(N, Nv), STAT=ierr)
   allocate (im_f_kx_v(N, Nv), STAT=ierr)
   allocate (orange_v(Nv), STAT=ierr)
   allocate (orange_f(Nv), STAT=ierr)
   allocate (blue_v(Nv), STAT=ierr)
   allocate (blue_f(Nv), STAT=ierr)

   ! Post-processing parameters
   nmovierho = 50
   nmovieefield = 50
   nmovieEdr = 500
   nmoviedeltaf = 40 ! Should be a multiple of "nsavef"!
   modeorder = mbox  ! Since there are 'mbox' wavelengths inside the box
   nharmonics = 20*mbox  ! Number of harmonics to write out

   ! Make sure that the period for movies is a multiple of nsavef2
   if (mod(nmoviedeltaf, nsavef2) .ne. 0) then
      write (*, *) 'Problem: nmoviedeltaf should be a multiple of'
      write (*, *) ' nsavef2'
      write (*, *) 'nmoviedeltaf, nsavef2=', nmoviedeltaf, nsavef2
      stop
   end if

   ! Initialize FT
   call ZFFTI(N, table)

   ! Read in x and v
   open (unit=71,
   +file = trim(rundir)//'/x.bdat',
   +ACCESS = "STREAM",
   +form = 'unformatted')
   read (71) x
   close (71)
   open (unit=71,
   +file = trim(rundir)//'/v.bdat',
   +ACCESS = "STREAM",
   +form = 'unformatted')
   read (71) v
   close (71)
   open (unit=71, file=trim(rundir)//'/x.txt')
   write (71, *) (x(i), i=1, N)
   close (71)
   open (unit=71, file=trim(rundir)//'/v.txt')
   write (71, *) (v(i), i=1, Nv)
   close (71)

   ! Generate list of mode numbers
   open (unit=71, file=trim(rundir)//'/n_k.txt')
   write (71, *) (i, i=0, nharmonics)
   close (71)

   ! Post-process rho data
   write (*, *) 'Post-processing rho data'
   open (unit=2, file=trim(rundir)//'/rhotot.bdat',
   +ACCESS = "STREAM",
   +form = 'unformatted')
   open (unit=3,
   +file = trim(rundir)//'/rho_movie.txt')
   open (unit=4,
   +file = trim(rundir)//'/rho_movie_t.txt')
   open (unit=75,
   +file = trim(rundir)//'/total_charge.txt')
   open (unit=76,
   +file = trim(rundir)//'/rho_fundamental.txt')
   open (unit=7,
   +file = trim(rundir)//'/rho_FT_movie.txt')
   open (unit=8,
   +file = trim(rundir)//'/rho_harmonics.txt')
   open (unit=9,
   +file = trim(rundir)//'/rho_harmonics_re.txt')
   open (unit=10,
   +file = trim(rundir)//'/rho_harmonics_im.txt')
   do it = 0, Nt
      if (mod(it, nsave) == 0) then
         ! Read this rho
         read (2) rhotot
         !print *,'it=',it,Nt
         ! Write out movie data
         if (mod(it, nmovierho) == 0) then
            write (3, *) (rhotot(i), i=1, N)
            write (4, *) it*dt
         end if
         ! Calculate total charge
         Q = 0._8
         do i = 1, N
            Q = Q + rhotot(i)
         end do
         Q = Q*L/N
         write (75, *) it*dt, Q
         ! Take Fourier transform
         do i = 1, N
            rhoft(i) = cmplx(rhotot(i), 0., 8)
         end do
         call ZFFTF(N, rhoft, table)
         call normfft_sqrtN(cmplx(rhoft, kind=8), N)
         ! Get amplitude of fundamental mode
         rhofundamental = 2.*abs(rhoft(modeorder + 1))
         ! Write out amplitude of fundamental mode
         write (76, *) it*dt, rhofundamental
         ! Write out amplitude of harmonics
         do j = 1, nharmonics
            rhoharmonics(j) = 2.*abs(rhoft(j))
            rhoharmonicsre(j) = real(rhoft(j))
            rhoharmonicsim(j) = aimag(rhoft(j))
         end do
         write (8, *) (rhoharmonics(j), j=1, nharmonics)
         write (9, *) (rhoharmonicsre(j), j=1, nharmonics)
         write (10, *) (rhoharmonicsim(j), j=1, nharmonics)
         ! Write out movie for FT of rho
         if (mod(it, nmovierho) == 0) then
            write (7, *) (2.*abs(rhoft(i)), i=1, N/2)
         end if
      end if
   end do
   close (2)
   close (3)
   close (4)
   close (75)
   close (76)
   close (7)
   close (8)
   close (9)
   close (10)

   ! Post-process E-field data
   write (*, *) 'Post-processing E-field data'
   open (unit=14, file=trim(rundir)//'/efield.bdat',
   +ACCESS = "STREAM",
   +form = 'unformatted')
   open (unit=15,
   +file = trim(rundir)//'/efield_movie.txt')
   open (unit=16,
   +file = trim(rundir)//'/efield_movie_t.txt')
   open (unit=17,
   +file = trim(rundir)//'/rho_from_E_movie.txt')
   open (unit=18,
   +file = trim(rundir)//'/phi_movie.txt')
   open (unit=19,
   +file = trim(rundir)//'/efield_fundamental.txt')
   open (unit=13,
   +file = trim(rundir)//'/deltaf_efield_movie.txt')
   open (unit=21,
   +file = trim(rundir)//'/efield_vs_t.txt')
   open (unit=11,
   +file = trim(rundir)//'/adr.bdat',
   +ACCESS = "STREAM",
   +form = 'unformatted')
   open (unit=12,
   +file = trim(rundir)//'/adr.txt')
   open (unit=111,
   +file = trim(rundir)//'/Edr.bdat',
   +ACCESS = "STREAM",
   +form = 'unformatted')
   open (unit=112,
   +file = trim(rundir)//'/Edr.txt')
   open (unit=113,
   +file = trim(rundir)//'/Edr_t.txt')
   open (unit=20,
   +file = trim(rundir)//'/efield_FT_movie.txt')
   open (unit=120,
   +file = trim(rundir)//'/ESE.txt')
   do it = 0, Nt
      if (mod(it, nsave) == 0) then
         ! Read this efield
         read (14) efield
         ! Write out movie data
         if (mod(it, nmovieefield) == 0) then
            write (15, *) (efield(i), i=1, N)
            write (16, *) it*dt
         end if
         ! Write out data for delta-f movie
         ! Write out only one vortex
         if (mod(it, nmoviedeltaf) == 0) then
            write (13, *) (efield(i), i=1, N/mbox)
         end if

         ! Write out E-field at position x=0
         write (21, *) it*dt, efield(1)

         ! Take Fourier transform
         do i = 1, N
            efieldft(i) = cmplx(efield(i), 0., 8)
         end do
         call ZFFTF(N, efieldft, table)
         call normfft_sqrtN(cmplx(efieldft, kind=8), N)
         ! Get amplitude of fundamental mode
         efieldfundamental = 2.*abs(efieldft(modeorder + 1))
         ! Write out amplitude of fundamental mode
         write (19, *) it*dt, efieldfundamental
         ! Write out movie of FT of E-field
         if (mod(it, nmovieefield) == 0) then
            write (20, *) (2.*abs(efieldft(i)), i=1, N/2)
         end if

         ! Calculate electrostatic energy
         ESE = 0._8
         do i = 1, N
            ESE = ESE + efield(i)*efield(i)/(8.*pi)
         end do
         ESE = ESE*0.5_8*L/real(N, 8)
         write (120, *) it*dt, ESE

         ! Calculate rho and phi from the E-field
         if (mod(it, nmovieefield) == 0) then
            dk = 2.*pi/L
            rhoft(1) = cmplx(0., 0., 8)
            phift(1) = cmplx(0., 0., 8)
            do i = 2, N/2
               k = real(i - 1, 8)*dk
               rhoft(i) = efieldft(i)*ii*k
               phift(i) = efieldft(i)/ii/k
            end do
            do i = N/2 + 1, N
               k = real(i - 1 - N, 8)*dk
               rhoft(i) = efieldft(i)*ii*k
               phift(i) = efieldft(i)/ii/k
            end do
            call ZFFTB(N, rhoft, table)
            call normfft_sqrtN(cmplx(rhoft, kind=8), N)
            call ZFFTB(N, phift, table)
            call normfft_sqrtN(cmplx(phift, kind=8), N)
            do i = 1, N
               rho_from_E(i) = real(rhoft(i))
               phi(i) = real(phift(i))
            end do
            ! Write out movie data for rho and phi
            write (17, *) rho_from_E
            write (18, *) phi
         end if

         ! Read amplitude of ponderomotive force
         read (11) adr
         write (12, *) it*dt, adr
         read (111) Edr
         if (mod(it, nmovieEdr) == 0) then
            write (112, *) Edr
            write (113, *) it*dt
         end if

      end if
   end do
   close (14)
   close (15)
   close (16)
   close (17)
   close (18)
   close (19)
   close (13)
   close (11)
   close (12)
   close (20)
   close (111)
   close (112)
   close (113)
   close (21)
   close (120)

   ! Post-process delta-f data
   write (*, *) 'Post-processing delta-f data'
   open (unit=21,
   +file = trim(rundir)//'/deltaf.bdat',
   +ACCESS = "STREAM",
   +form = 'unformatted')
   open (unit=201,
   +file = trim(rundir)//'/f0.bdat',
   +ACCESS = "STREAM",
   +form = 'unformatted')
   open (unit=22,
   +file = trim(rundir)//'/deltaf_movie.txt')
   open (unit=23,
   +file = trim(rundir)//'/deltaf_movie_t.txt')
   open (unit=24,
   +file = trim(rundir)//'/deltaf_movie_v.txt')
   open (unit=32,
   +file = trim(rundir)//'/deltaf_movie_allv.txt')
   open (unit=33,
   +file = trim(rundir)//'/deltaf_movie_v_allv.txt')
   open (unit=34,
   +file = trim(rundir)//'/deltaf_min_max.txt')
   open (unit=35,
   +file = trim(rundir)//'/deltaf_min_max_allv.txt')
   open (unit=25,
   +file = trim(rundir)//'/entropy1.txt')
   open (unit=26,
   +file = trim(rundir)//'/entropy2.txt')
   open (unit=27,
   +file = trim(rundir)//'/dist_v.txt')
   open (unit=28,
   +file = trim(rundir)//'/KE.txt')
   open (unit=41,
   +file = trim(rundir)//'/f_kx_v_re.txt')
   open (unit=42,
   +file = trim(rundir)//'/f_kx_v_im.txt')
   open (unit=43,
   +file = trim(rundir)//'/f_kx_v_t.txt')
!      open(unit=44,
!     +  file=trim(rundir)//'/f_kx_v_re_movie.txt')
!      open(unit=45,
!     +  file=trim(rundir)//'/f_kx_v_im_movie.txt')
   open (unit=50,
   +file = trim(rundir)//'/f_0.txt')
   open (unit=51,
   +file = trim(rundir)//'/f_0_allv.txt')
   ! Those are temporary outputs: data points belonging
   ! to the outer orange and blue regions
   open (unit=60,
   +file = trim(rundir)//'/orange_v.txt')
   open (unit=61,
   +file = trim(rundir)//'/orange_f.txt')
   open (unit=62,
   +file = trim(rundir)//'/blue_v.txt')
   open (unit=63,
   +file = trim(rundir)//'/blue_f.txt')
   open (unit=64,
   +file = trim(rundir)//'/orange_t.txt')
   open (unit=65,
   +file = trim(rundir)//'/blue_t.txt')

   vphase = omega0/k0
   dv = (vxmax - vxmin)/real(Nv, 8)
   ivmin = int((vrangemin - vxmin)/(vxmax - vxmin)*Nv)
   ivmax = int((vrangemax - vxmin)/(vxmax - vxmin)*Nv)
   !write(*,*) 'ivmin, ivmax:', ivmin, ivmax
   !write(*,*) 'vrange: ', v(ivmin), v(ivmax)
   if (ivmin > Nv) then
      ivmin = Nv - 1
   end if
   if (ivmax > Nv) then
      ivmax = Nv
   end if
   do j = ivmin, ivmax
      write (24, *) v(j)
   end do
   close (24)
   do j = 1, Nv
      write (33, *) v(j)
   end do
   close (33)
   ! Read initial distribution
   read (201) f0
   ! Write out initial distribution
   do j = ivmin, ivmax
      write (50, *) (f0(i, j), i=1, N)
   end do
   do j = 1, Nv
      write (51, *) (f0(i, j), i=1, N)
   end do
   close (50)
   close (51)

   ! Calculate initial velocity distribution
   do j = 1, Nv
      intf = 0._8
      do i = 1, N
         intf = f0(i, j)
      end do
      distv0(j) = intf*L/real(N, 8)
   end do
   ! Now, look at the time evolution of delta-f(x,v)
   do it = 0, Nt
      if (it*dt > Tsetup) then
         nsavef = nsavef2
      else
         nsavef = nsavef1
      end if
      !print *,'nsavef=',nsavef
      ! At least for now, we write out every available
      ! time step to calculate Fourier transforms in time
      !nmoviedeltaf = nsavef

      if (mod(it, nsavef) == 0) then
         ! Read this delta-f
         write (*, *) 'reading data, it=', it
         read (21) deltaf

         ! Write out movie data
         if (mod(it, nmoviedeltaf) == 0) then
            do j = ivmin, ivmax
               ! Write out one vortex only
               write (22, *) (deltaf(i, j), i=1, N/mbox)
            end do
            ! Don't write out the all-v movie (it's a large file and
            ! we are not looking at that movie for now)
            !do j=1, Nv
            !   write(32,*) (deltaf(i,j), i=1, N)
            !enddo
            write (23, *) it*dt
            ! Calculate min and max values of 'all-v' movie
            min_delta_f = 0._8
            max_delta_f = 0._8
            do i = 1, N/mbox
               do j = 1, Nv
                  if (deltaf(i, j) > max_delta_f) then
                     max_delta_f = deltaf(i, j)
                  elseif (deltaf(i, j) < min_delta_f) then
                     min_delta_f = deltaf(i, j)
                  end if
               end do
            end do
            write (35, *) min_delta_f, max_delta_f
            ! Calculate min and max values of 'zoom' movie
            min_delta_f = 0._8
            max_delta_f = 0._8
            do i = 1, N/mbox
               do j = ivmin, ivmax
                  if (deltaf(i, j) > max_delta_f) then
                     max_delta_f = deltaf(i, j)
                  elseif (deltaf(i, j) < min_delta_f) then
                     min_delta_f = deltaf(i, j)
                  end if
               end do
            end do
            write (34, *) min_delta_f, max_delta_f

            ! Calculate space-averaged velocity distribution
            do j = 1, Nv
               intf = 0._8
               do i = 1, N
                  intf = deltaf(i, j)
               end do
               distv(j) = distv0(j) + intf*L/real(N, 8)
            end do
            write (27, *) distv

         end if  ! End of write out movies of f(x,v)

         ! Now, calculate Fourier transforms in x. It will be
         ! used to calculate f_hat_hat(k,w).
         ! First, calculate FT in x around the phase velocity
         ! Put zeros everywhere (since only the vicinity of
         ! v_phase will be used)
         if (it*dt > Tsetup) then
            do j = 1, Nv
               do i = 1, N
                  f_kx_v(i, j) = cmplx(0., 0., 8)
               end do
            end do
            do j = ivmin, ivmax
               do i = 1, N
                  frowft(i) = cmplx(deltaf(i, j) + f0(i, j), 0., 8)
               end do
               call ZFFTF(N, frowft, table)
               call normfft_sqrtN(cmplx(frowft, kind=8), N)
               do i = 1, N/2
                  f_kx_v(i, j) = frowft(i + N/2)
               end do
               do i = N/2 + 1, N
                  f_kx_v(i, j) = frowft(i - N/2)
               end do
               do i = 1, N
                  abs_f_kx_v(i, j) = abs(f_kx_v(i, j))
                  re_f_kx_v(i, j) = real(f_kx_v(i, j))
                  im_f_kx_v(i, j) = aimag(f_kx_v(i, j))
               end do
            end do
            ! Write out f(kx,v) for a few modes, and over the v-range
            ! surrounding v_phase
            do j = ivmin, ivmax
               write (41, *) (re_f_kx_v(i, j), i=N/2 + 1,
               +N/2 + 1 + nharmonics)
               write (42, *) (im_f_kx_v(i, j), i=N/2 + 1,
               +N/2 + 1 + nharmonics)
            end do
!               ! Write out all harmonics, but not for every time step
!               if(mod(it, nmoviedeltaf)==0) then
!                  do j=ivmin, ivmax
!                        write(44,*) (re_f_kx_v(i,j), i=1, N)
!                        write(45,*) (im_f_kx_v(i,j), i=1, N)
!                  enddo
!               endif
            write (43, *) it*dt
         end if

         ! Calculate entropy and kinetic energy
         entropy1 = 0._8
         entropy2 = 0._8
         KE = 0.0_8
         do i = 1, N
            do j = 1, Nv
               f = f0(i, j) + deltaf(i, j)
               entropy1 = entropy1 + f*log(f + 1.e-8)
               entropy2 = entropy2 + f*f
               KE = KE + 0.5_8*f*v(j)*v(j)
            end do
         end do
         entropy1 = entropy1*L/real(N, 8)*dv
         entropy2 = entropy2*L/real(N, 8)*dv
         KE = KE*L/real(N, 8)*dv
         write (25, *) it*dt, entropy1
         write (26, *) it*dt, entropy2
         write (28, *) it*dt, KE

!            ! TEMPORARY: WRITE OUT DATA POINTS BELONGING
!            ! TO THE OUTER ORANGE AND BLUE REGION (IN THE CASE
!            ! OF A CANONICAL RUN)
!
!            part_boundaries(1) = 0.27
!            part_boundaries(2) = 0.34
!            part_boundaries(3) = 0.43
!            part_boundaries(4) = 0.46
!            part_boundaries(5) = 0.63
!            part_boundaries(6) = 1.
!            f0_max = 1/sqrt(2.*pi)
!            ! Identify outer orange region
!            do i=1,N/mbox
!               N_orange = 0
!               do j= Nv, 1, -1
!                  f = f0(i,j) + deltaf(i,j)
!                  if(f > part_boundaries(1)*f0_max) then
!                     if(f <= part_boundaries(2)*f0_max) then
!                        N_orange = N_orange + 1
!                        orange_v(N_orange) = v(j)
!                        orange_f(N_orange) = f
!                     else
!                        exit
!                     endif
!                  endif
!               enddo
!               ! Write out data: each line is a different x value, and
!               ! all v values are on the same line
!               if(N_orange > 0) then
!                  write(60,*) (orange_v(j), j=1, N_orange)
!                  write(61,*) (orange_f(j), j=1, N_orange)
!               else
!                  write(60,*) '\\'
!                  write(61,*) '\\'
!               endif
!            enddo
!            ! Identify outer blue region
!            do i=1,N/mbox
!               N_blue = 0
!               do j= Nv, 1, -1
!                  f = f0(i,j) + deltaf(i,j)
!                  if(f > part_boundaries(2)*f0_max) then
!                     if(f <= part_boundaries(3)*f0_max) then
!                        N_blue = N_blue + 1
!                        blue_v(N_blue) = v(j)
!                        blue_f(N_blue) = f
!                     else
!                        exit
!                     endif
!                  endif
!               enddo
!               ! Write out data: each line is a different x value, and
!               ! all v values are on the same line
!               if(N_blue > 0) then
!                  write(62,*) (blue_v(j), j=1, N_blue)
!                  write(63,*) (blue_f(j), j=1, N_blue)
!               else
!                  write(62,*) '\\'
!                  write(63,*) '\\'
!               endif
!            enddo
!            ! Write out this time value
!            write(64,*) it*dt
!            write(65,*) it*dt
!            write(*,*) 'after writing out ', it*dt
!            ! END TEMPORARY
      end if
   end do
   close (21)
   close (22)
   close (23)
   close (25)
   close (28)
   close (26)
   close (32)
   close (34)
   close (35)
   close (201)
   close (27)
   close (41)
   close (42)
   close (43)
   close (44)
   close (45)
   close (60)
   close (61)
   close (62)
   close (63)
   close (64)
   close (65)

end

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Subroutine 'normfft'.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine normfft(efield, N)

   implicit none
   integer N, i
   complex(8) efield(N)

   do i = 1, N
      efield(i) = efield(i)/N
   end do
   return
end

subroutine normfft_sqrtN(efield, N)

   implicit none
   integer N, i
   complex(8) efield(N)

   do i = 1, N
      efield(i) = efield(i)/cmplx(sqrt(real(N, 8)), 0., 8)
   end do
   return
end
