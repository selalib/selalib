!**************************************************************
!  Copyright INRIA
!  Authors : 
!     CALVI project team
!  
!  This code SeLaLib (for Semi-Lagrangian-Library) 
!  is a parallel library for simulating the plasma turbulence 
!  in a tokamak.
!  
!  This software is governed by the CeCILL-B license 
!  under French law and abiding by the rules of distribution 
!  of free software.  You can  use, modify and redistribute 
!  the software under the terms of the CeCILL-B license as 
!  circulated by CEA, CNRS and INRIA at the following URL
!  "http://www.cecill.info". 
!**************************************************************

!> @file sll_coordinate_transformation_multipatch.F90
!> @namespace sll_coordinate_transformation_multipatch
!> @brief  
!> Non-cartesian geometries in Selalib are dealt with coordinate
!> transformations applied on cartesian meshes. Whenever a single deformed
!> domain is not sufficient to cover the desired region in a desired way, it
!> is possible to use multiple cartesian domains, each independently 
!> transformed, to cover the given region. We call this a 'multipatch'. In 
!> such case, there are specific relations between the different 'patches', 
!> in the sense that a face of one patch will be 'connected' with a face of 
!> another patch. We use this idea of 'multipatching' to extend other objects
!> in the library, such as the coordinate transformation, which is normally
!> associated with a single patch (a logical mesh). The multipatched 
!> coordinate transformation offers in principle the same services as the
!> single-patch coordinate transformation, except that the function arguments
!> also include an index to a given patch. It may also include additional 
!> services that pertain to the multi-patch nature of the object, such as
!> answering questions about connectivity information and such.
!> @details
!> User needs to declare a pointer to the multipatch object. The pointer needs
!> to be allocated and initialized with the appropriate 'new_' function. 
!> Given the reasonably laborious nature of building this object, the 'new'
!> function is based on reading from a file. Furthermore, the files which
!> are meant to be used are generated by a specific mesh-generation software:
!> CAID, which generates discrete coordinate transformations based on NURBS.
!> The object's resources can be liberated by a call to 'sll_delete()'.


module sll_coordinate_transformation_multipatch_module
#include "sll_assert.h"
#include "sll_memory.h"
#include "sll_working_precision.h"
#include "sll_file_io.h"
  use sll_logical_meshes_multipatch
  use sll_module_coordinate_transformations_2d_nurbs
  implicit none

  !> @brief basic type for the multipatch. It is meant to be an opaque
  !> entity and dealt with only through the methods in this module.
  type :: sll_coordinate_transformation_multipatch_2d
     sll_int32 :: number_patches
     character(len=128), dimension(:), pointer :: patch_names => null()
     sll_int32, dimension(:,:), pointer :: connectivities => null()
     type(sll_logical_mesh_multipatch_2d), pointer :: logical_mesh_mp => null()
     type(sll_coordinate_transformation_2d_nurbs_ptr), dimension(:), pointer::&
          transfs => null()
   contains
     procedure, pass :: read_from_file => read_from_file_ctmp2d
     procedure, pass :: get_number_patches => get_number_patches_ctmp2d
     procedure, pass :: get_transformation => get_transformation_ctmp2d
     procedure, pass :: get_logical_mesh => get_logical_mesh_ctmp2d
     procedure, pass :: get_connectivity => get_connectivity_ctmp2d
     procedure, pass :: x1_node => x1_node_ctmp2d
     procedure, pass :: x2_node => x2_node_ctmp2d
     procedure, pass :: jacobian_at_node => jacobian_at_node_ctmp2d
     procedure, pass :: x1 => x1_ctmp2d
     procedure, pass :: x2 => x2_ctmp2d
     procedure, pass :: x1_at_cell => x1_at_cell_ctmp2d
     procedure, pass :: x2_at_cell => x2_at_cell_ctmp2d
     procedure, pass :: jacobian_at_cell => jacobian_at_cell_ctmp2d
     procedure, pass :: jacobian => jacobian_ctmp2d
     procedure, pass :: jacobian_matrix => jacobian_matrix_ctmp2d
     procedure, pass :: inverse_jacobian_matrix => inverse_jm_ctmp2d
     procedure, pass :: write_to_file => write_to_file_ctmp2d
  end type sll_coordinate_transformation_multipatch_2d

contains

  function new_coordinate_transformation_multipatch_2d( filename ) result(res)
    type(sll_coordinate_transformation_multipatch_2d), pointer :: res
    character(len=*), intent(in) :: filename
    sll_int32 :: ierr

    SLL_ALLOCATE(res,ierr)
    call res%read_from_file(trim(filename))

  end function new_coordinate_transformation_multipatch_2d

  subroutine read_from_file_ctmp2d( mp, filename )
    class(sll_coordinate_transformation_multipatch_2d), intent(inout) :: mp
    character(len=*), intent(in) :: filename
    character(len=256) :: label
    character(len=256) :: filename_local
    sll_int32 :: IO_stat
    sll_int32 :: input_file_id
    sll_int32 :: i
    sll_int32 :: ierr
    sll_int32 :: whatisthisrd
    sll_int32 :: dimension
    sll_int32 :: number_patches
    sll_int32, dimension(:), pointer :: connectivities
    sll_int32, dimension(:,:), pointer :: connectivities_reshaped
    character(len=128), dimension(:), pointer :: patches

    namelist /multipatch_label/ label
    namelist /rd/ whatisthisrd
    namelist /dim/ dimension
    namelist /num_patches/ number_patches
    namelist /connectivity/ connectivities
    namelist /patch_names/ patches

    if(len(filename) >= 256) then
       print *, 'ERROR, read_from_file_multipatch_2d => ',&
            'filenames longer than 256 characters are not allowed.'
       STOP
    end if
    filename_local = trim(filename)

    ! get a new identifier for the file.
    call sll_new_file_id( input_file_id, ierr )
    if( ierr .ne. 0 ) then
       print *, 'ERROR while trying to obtain an unique identifier for file ',&
            filename, '. Called from read_from_file_multipatch_2d().'
       stop
    end if
    open(unit=input_file_id, file=filename_local, STATUS="OLD", IOStat=IO_stat)
    if( IO_Stat .ne. 0 ) then
       print *, 'ERROR while opening file ',filename, &
            '. Called from read_from_file_multipatch_2d().'
       stop
    end if

    ! read the label
    read( input_file_id, multipatch_label )
    ! read the rd
    read( input_file_id, rd )
    print *, 'rd = ', whatisthisrd
    read( input_file_id, dim )
    print *, 'dimension =', dimension
    read( input_file_id, num_patches )
    mp%number_patches = number_patches
    print *, 'number patches = ', number_patches
    SLL_ALLOCATE(connectivities(number_patches*8),ierr)
    SLL_ALLOCATE(connectivities_reshaped(8,number_patches),ierr)
    SLL_ALLOCATE(mp%transfs(number_patches),ierr)
    read( input_file_id, connectivity )
    connectivities_reshaped = reshape(connectivities,(/8,5/))
    print *, 'connectivity array: ', connectivities_reshaped
    SLL_ALLOCATE(mp%connectivities(number_patches,8),ierr)
    mp%connectivities = transpose(connectivities_reshaped)
    print *, 'size mp%connectivities = ', size(mp%connectivities,1), &
         size(mp%connectivities,2), mp%connectivities
    SLL_ALLOCATE(patches(number_patches),ierr)
    read( input_file_id, patch_names )
    print *, 'patch names: ', patches
    close( input_file_id )

    ! Create the coordinate transformations.
    do i=1,number_patches
       mp%transfs(i)%T => &
            new_nurbs_2d_transformation_from_file(trim(patches(i)))
    end do

    SLL_DEALLOCATE(connectivities,ierr)
    SLL_DEALLOCATE(connectivities_reshaped,ierr)
  end subroutine read_from_file_ctmp2d

  function get_number_patches_ctmp2d( mp ) result(res)
    sll_int32 :: res
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    res = mp%number_patches
  end function get_number_patches_ctmp2d

  function get_logical_mesh_ctmp2d( mp, patch ) result(res)
    type(sll_logical_mesh_2d), pointer :: res
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in) :: patch
    SLL_ASSERT( (patch >= 0) .and. (patch < mp%number_patches) )
    call mp%logical_mesh_mp%get_logical_mesh(patch)
  end function get_logical_mesh_ctmp2d

  function get_transformation_ctmp2d( mp, patch ) result(res)
    type(sll_coordinate_transformation_2d_nurbs), pointer :: res
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in) :: patch
    SLL_ASSERT( (patch >= 0) .and. (patch < mp%number_patches) )
    res => mp%transfs(patch+1)%T
  end function get_transformation_ctmp2d 

  function get_connectivity_ctmp2d( mp, patch, face ) result(res)
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in)   :: patch
    sll_int32, intent(in)   :: face
    sll_int32, dimension(2) :: res
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    SLL_ASSERT(face  >= 0 .and. face <= 3)
    res(1) = mp%connectivities(patch+1,2*face+1)
    res(2) = mp%connectivities(patch+1,2*face+2)
  end function get_connectivity_ctmp2d

  function x1_node_ctmp2d( mp, i, j, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in)   :: i
    sll_int32, intent(in)   :: j
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%x1_at_node(i,j)
  end function x1_node_ctmp2d

  function x2_node_ctmp2d( mp, i, j, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in)   :: i
    sll_int32, intent(in)   :: j
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%x2_at_node(i,j)
  end function x2_node_ctmp2d

  function jacobian_at_node_ctmp2d( mp, i, j, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in)   :: i
    sll_int32, intent(in)   :: j
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%jacobian_at_node(i,j)
  end function jacobian_at_node_ctmp2d

  function x1_ctmp2d( mp, eta1, eta2, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_real64, intent(in)   :: eta1
    sll_real64, intent(in)   :: eta2
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%x1(eta1,eta2)
  end function x1_ctmp2d

  function x2_ctmp2d( mp, eta1, eta2, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_real64, intent(in)   :: eta1
    sll_real64, intent(in)   :: eta2
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%x2(eta1,eta2)
  end function x2_ctmp2d

  function x1_at_cell_ctmp2d( mp, i, j, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in)   :: i
    sll_int32, intent(in)   :: j
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%x1_at_cell(i,j)
  end function x1_at_cell_ctmp2d

  function x2_at_cell_ctmp2d( mp, i, j, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in)   :: i
    sll_int32, intent(in)   :: j
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%x2_at_cell(i,j)
  end function x2_at_cell_ctmp2d

  function jacobian_at_cell_ctmp2d( mp, i, j, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in)   :: i
    sll_int32, intent(in)   :: j
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%jacobian_at_cell(i,j)
  end function jacobian_at_cell_ctmp2d

  function jacobian_ctmp2d( mp, eta1, eta2, patch ) result(val)
    sll_real64 :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_real64, intent(in)   :: eta1
    sll_real64, intent(in)   :: eta2
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%jacobian(eta1,eta2)
  end function jacobian_ctmp2d

  function jacobian_matrix_ctmp2d( mp, eta1, eta2, patch ) result(val)
    sll_real64, dimension(1:2,1:2) :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_real64, intent(in)   :: eta1
    sll_real64, intent(in)   :: eta2
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%jacobian_matrix(eta1,eta2)
  end function jacobian_matrix_ctmp2d

  function inverse_jm_ctmp2d( mp, eta1, eta2, patch ) result(val)
    sll_real64, dimension(1:2,1:2) :: val
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_real64, intent(in)   :: eta1
    sll_real64, intent(in)   :: eta2
    sll_int32, intent(in)   :: patch
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    val = mp%transfs(patch)%T%inverse_jacobian_matrix(eta1,eta2)
  end function inverse_jm_ctmp2d

  subroutine write_to_file_ctmp2d( mp, output_format )
    class(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in), optional :: output_format
    sll_int32 :: i
    sll_int32 :: np
    np = mp%number_patches
    do i=1,np
       call mp%transfs(i-1)%T%write_to_file( output_format )
    end do
    ! it would be nice to add some kind of 'master' file, in such way that
    ! loading this master with the visualizing program would automatically load
    ! each patch...
  end subroutine write_to_file_ctmp2d

  subroutine delete_ctmp2d( mp )
    type(sll_coordinate_transformation_multipatch_2d), intent(inout) :: mp
    sll_int32 :: ierr
    SLL_DEALLOCATE(mp%connectivities,ierr)
    SLL_DEALLOCATE(mp%patch_names,ierr)
  end subroutine delete_ctmp2d

end module sll_coordinate_transformation_multipatch_module
