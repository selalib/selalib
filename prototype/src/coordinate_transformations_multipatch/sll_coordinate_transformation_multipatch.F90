!**************************************************************
!  Copyright INRIA
!  Authors : 
!     CALVI project team
!  
!  This code SeLaLib (for Semi-Lagrangian-Library) 
!  is a parallel library for simulating the plasma turbulence 
!  in a tokamak.
!  
!  This software is governed by the CeCILL-B license 
!  under French law and abiding by the rules of distribution 
!  of free software.  You can  use, modify and redistribute 
!  the software under the terms of the CeCILL-B license as 
!  circulated by CEA, CNRS and INRIA at the following URL
!  "http://www.cecill.info". 
!**************************************************************

!> @file sll_coordinate_transformation_multipatch.F90
!> @namespace sll_coordinate_transformation_multipatch
!> @brief  
!> Non-cartesian geometries in Selalib are dealt with coordinate
!> transformations applied on cartesian meshes. Whenever a single deformed
!> domain is not sufficient to cover the desired region in a desired way, it
!> is possible to use multiple cartesian domains, each independently 
!> transformed, to cover the given region. We call this a 'multipatch'. In 
!> such case, there are specific relations between the different 'patches', 
!> in the sense that a face of one patch will be 'connected' with a face of 
!> another patch. We use this idea of 'multipatching' to extend other objects
!> in the library, such as the coordinate transformation, which is normally
!> associated with a single patch (a logical mesh). The multipatched 
!> coordinate transformation offers in principle the same services as the
!> single-patch coordinate transformation, except that the function arguments
!> also include an index to a given patch. It may also include additional 
!> services that pertain to the multi-patch nature of the object, such as
!> answering questions about connectivity information and such.
!> @details
!> User needs to declare a pointer to the multipatch object. The pointer needs
!> to be allocated and initialized with the appropriate 'new_' function. 
!> Given the reasonably laborious nature of building this object, the 'new'
!> function is based on reading from a file. Furthermore, the files which
!> are meant to be used are generated by a specific mesh-generation software:
!> CAID, which generates discrete coordinate transformations based on NURBS.
!> The object's resources can be liberated by a call to 'sll_delete()'.


module sll_coordinate_transformation_multipatch_module
#include "sll_assert.h"
#include "sll_memory.h"
#include "sll_working_precision.h"
#include "sll_file_io.h"
  use sll_module_coordinate_transformations_2d_nurbs
  implicit none

  !> @brief basic type for the multipatch. It is meant to be an opaque
  !> entity and dealt with only through the methods in this module.
  type :: sll_coordinate_transformation_multipatch_2d
     sll_int32 :: number_patches
     character(len=128), dimension(:), pointer :: patch_names
     sll_int32, dimension(:,:), pointer :: connectivities
     class(sll_coordinate_transformation_2d_nurbs_ptr), dimension(:), pointer ::&
          transfs
!   contains
!     procedure, pass(mp) :: read_from_file => read_from_file_multipatch_2d
  end type sll_coordinate_transformation_multipatch_2d

  interface initialize_from_file
     module procedure read_from_file_multipatch_2d
  end interface initialize_from_file

contains

  subroutine read_from_file_multipatch_2d( mp, filename )
    type(sll_coordinate_transformation_multipatch_2d), intent(inout) :: mp
    character(len=*), intent(in) :: filename
    character(len=256) :: label
    character(len=256) :: filename_local
    sll_int32 :: IO_stat
    sll_int32 :: input_file_id
    sll_int32 :: i
    sll_int32 :: ierr
    sll_int32 :: whatisthisrd
    sll_int32 :: dimension
    sll_int32 :: number_patches
    sll_int32, dimension(:), pointer :: connectivities
    sll_int32, dimension(:,:), pointer :: connectivities_reshaped
    character(len=128), dimension(:), pointer :: patches

    namelist /multipatch_label/ label
    namelist /rd/ whatisthisrd
    namelist /dim/ dimension
    namelist /num_patches/ number_patches
    namelist /connectivity/ connectivities
    namelist /patch_names/ patches

    if(len(filename) >= 256) then
       print *, 'ERROR, read_from_file_multipatch_2d => ',&
            'filenames longer than 256 characters are not allowed.'
       STOP
    end if
    filename_local = trim(filename)

    ! get a new identifier for the file.
    call sll_new_file_id( input_file_id, ierr )
    if( ierr .ne. 0 ) then
       print *, 'ERROR while trying to obtain an unique identifier for file ',&
            filename, '. Called from read_from_file_multipatch_2d().'
       stop
    end if
    open(unit=input_file_id, file=filename_local, STATUS="OLD", IOStat=IO_stat)
    if( IO_Stat .ne. 0 ) then
       print *, 'ERROR while opening file ',filename, &
            '. Called from read_from_file_multipatch_2d().'
       stop
    end if

    ! read the label
    read( input_file_id, multipatch_label )
    ! read the rd
    read( input_file_id, rd )
    print *, 'rd = ', whatisthisrd
    read( input_file_id, dim )
    print *, 'dimension =', dimension
    read( input_file_id, num_patches )
    mp%number_patches = number_patches
    print *, 'number patches = ', number_patches
    SLL_ALLOCATE(connectivities(number_patches*8),ierr)
    SLL_ALLOCATE(connectivities_reshaped(8,number_patches),ierr)
    SLL_ALLOCATE(mp%transfs(number_patches),ierr)
    read( input_file_id, connectivity )
    connectivities_reshaped = reshape(connectivities,(/8,5/))
    print *, 'connectivity array: ', connectivities_reshaped
    SLL_ALLOCATE(mp%connectivities(number_patches,8),ierr)
    mp%connectivities = transpose(connectivities_reshaped)
    print *, 'size mp%connectivities = ', size(mp%connectivities,1), &
         size(mp%connectivities,2), mp%connectivities
    SLL_ALLOCATE(patches(number_patches),ierr)
    read( input_file_id, patch_names )
    print *, 'patch names: ', patches
    close( input_file_id )

    ! Create the coordinate transformations.
    do i=1,number_patches
       mp%transfs(i)%T => &
            new_nurbs_2d_transformation_from_file(trim(patches(i)))
    end do

    SLL_DEALLOCATE(connectivities,ierr)
    SLL_DEALLOCATE(connectivities_reshaped,ierr)
  end subroutine read_from_file_multipatch_2d

  function get_connectivity( mp, patch, face ) result(res)
    type(sll_coordinate_transformation_multipatch_2d), intent(in) :: mp
    sll_int32, intent(in)   :: patch
    sll_int32, intent(in)   :: face
    sll_int32, dimension(2) :: res
    SLL_ASSERT(patch >= 0 .and. patch < mp%number_patches )
    SLL_ASSERT(face  >= 0 .and. face <= 3)
    res(1) = mp%connectivities(patch+1,2*face+1)
    res(2) = mp%connectivities(patch+1,2*face+2)
  end function get_connectivity

  subroutine delete_multipatch_2d( mp )
    type(sll_coordinate_transformation_multipatch_2d), intent(inout) :: mp
    sll_int32 :: ierr
    SLL_DEALLOCATE(mp%connectivities,ierr)
    SLL_DEALLOCATE(mp%patch_names,ierr)
  end subroutine delete_multipatch_2d

end module sll_coordinate_transformation_multipatch_module
