! Program 'VPpostprocessing'. Post-process data generated by 'VP1DMS.f'.
! Compile with:
! gfortran -O3 VPpostprocessing_drive_KEEN.f dfftpack.f -o postproc_drive
      program VPpostprocessing_drive
      
      implicit none
      integer N, Nv, Nt, i, j, nsave, nsavef, it, Nout, nrho, mbox
      integer nmovierho, nmovieefield, nmoviedeltaf, ivmin, ivmax
      integer modeorder, nmovieEdr, nharmonics, nsavef1, nsavef2
      integer ierr,numarg, iargc
      !parameter (N=1024, Nv=4096)
      double precision pi, dt, t, k0, eps, vxmax, vxmin, Tmax, L
      double precision Edrmax
      double precision omega0, Tsetup, vrangemax, vrangemin
      real(8), allocatable :: rhotot(:), efield(:), deltaf(:, :)
      double precision max_delta_f, min_delta_f,  entropy
      real(8), allocatable :: x(:), v(:)
      double precision rhofundamental, efieldfundamental, Q
      real(8), allocatable :: rhoharmonics(:)
      real(8), allocatable :: rhoharmonicsre(:), rhoharmonicsim(:)
      double precision dk, k,  vphase, dv
      real(8), allocatable :: rho_from_E(:), phi(:), f0(:, :)
      double precision entropy1, entropy2, f, adr, KE, ESE, intf
      real(8), allocatable :: Edr(:),  distv(:), distv0(:)
      complex(8), allocatable :: table(:), efieldft(:), rhoft(:)
      complex(8), allocatable :: frowft(:), f_kx_v(:,:), phift(:)
      complex(8) :: ii
      real(8), allocatable :: abs_f_kx_v(:,:),re_f_kx_v(:,:)
      real(8), allocatable :: im_f_kx_v(:,:)
      character(20) :: rundir
      double precision tflat, tL, tR, twL, twR
      ! These variables have to do with partition
      integer N_orange, N_blue
      double precision part_boundaries(10), f0_max
      real(8), allocatable :: orange_v(:), orange_f(:)
      real(8), allocatable :: blue_v(:), blue_f(:)
      
      ! This is the velocity range to be written out 
      vrangemax = 4.0
      vrangemin = 0.
           
      ! Constants
      pi = 3.1415926535897932385_8
      ii = cmplx(0, 1)

      ! get run directory
      numarg = iargc ( )
      if (numarg > 0) then
         call getarg ( 1, rundir )
      else 
         print*, 'Error: rundir not defined'
         stop
      end if    
     
      ! Read in run parameters
      open(unit=50, file=trim(rundir)//'/parameters.dat')
      read(50, *) Tmax
      read(50, *) dt
      read(50, *) Nt
      read(50, *) k0
      read(50, *) omega0
      read(50, *) L
      read(50, *) mbox
      read(50, *) Edrmax
      read(50, *) nsave
      read(50, *) nsavef1
      read(50, *) nsavef2
      read(50, *) Tsetup
      read(50, *) vxmax
      read(50, *) vxmin
      read(50, *) N
      read(50, *) Nv
      ! added ES
      read(50, *) tL
      read(50, *) tR
      read(50, *) twL
      read(50, *) twR
      read(50, *) tflat
      close(50)
      
      
       open(unit=50, file=trim(rundir)//'/parameters.txt')
       write(50, *) Tmax
       write(50, *) dt
       write(50, *) Nt
       write(50, *) k0
       write(50, *) omega0
       write(50, *) L
       write(50, *) mbox
       write(50, *) Edrmax
       write(50, *) nsave
       write(50, *) nsavef1
       write(50, *) nsavef2
       write(50, *) Tsetup
       write(50, *) vxmax
       write(50, *) vxmin
       write(50, *) N
       write(50, *) Nv
       write(50, *) tL
       write(50, *) tR
       write(50, *) twL
       write(50, *) twR
       write(50, *) tflat
       close(50)

      
      
      
      !    allocate matrices
      allocate(rhotot(N), STAT=ierr)
      allocate(efield(N), STAT=ierr)
      allocate(deltaf(N, Nv), STAT=ierr)
      allocate(x(N), STAT=ierr)
      allocate(v(Nv), STAT=ierr)
      allocate(rhoharmonics(N), STAT=ierr)
      allocate(rhoharmonicsre(N), STAT=ierr)
      allocate(rhoharmonicsim(N), STAT=ierr)
      allocate(rho_from_E(N), STAT=ierr)
      allocate(phi(N), STAT=ierr)
      allocate(f0(N, Nv), STAT=ierr)
      allocate(Edr(N), STAT=ierr)
      allocate(distv(Nv), STAT=ierr)
      allocate(distv0(Nv), STAT=ierr)
      allocate(table(15+4*N), STAT=ierr)
      allocate(efieldft(N), STAT=ierr)
      allocate(rhoft(N), STAT=ierr)
      allocate(phift(N), STAT=ierr)
      allocate(frowft(N), STAT=ierr)
      allocate(f_kx_v(N,Nv), STAT=ierr)
      allocate(abs_f_kx_v(N,Nv), STAT=ierr)
      allocate(re_f_kx_v(N,Nv), STAT=ierr)
      allocate(im_f_kx_v(N,Nv), STAT=ierr)
      allocate(orange_v(Nv), STAT=ierr)
      allocate(orange_f(Nv), STAT=ierr)
      allocate(blue_v(Nv), STAT=ierr)
      allocate(blue_f(Nv), STAT=ierr)
      

      ! Post-processing parameters
      nmovierho = 50 
      nmovieefield = 50 
      nmovieEdr = 500
      nmoviedeltaf = 40 ! Should be a multiple of "nsavef"!
      modeorder = mbox  ! Since there are 'mbox' wavelengths inside the box
      nharmonics = 20 * mbox  ! Number of harmonics to write out 
      
      ! Make sure that the period for movies is a multiple of nsavef2
      if(mod(nmoviedeltaf, nsavef2) .ne. 0) then
         write(*,*) 'Problem: nmoviedeltaf should be a multiple of'
         write(*,*) ' nsavef2'
         write(*,*) 'nmoviedeltaf, nsavef2=', nmoviedeltaf, nsavef2
         stop
      endif
         
      
      ! Initialize FT
      call ZFFTI(N, table)
      
      ! Read in x and v
      open(unit=71,
     +  file=trim(rundir)//'/x.bdat', 
     +       ACCESS="STREAM",
     +  form='unformatted')
      read(71) x
      close(71)
      open(unit=71, 
     +  file=trim(rundir)//'/v.bdat', 
     +       ACCESS="STREAM",
     +  form='unformatted')
      read(71) v
      close(71)
      open(unit=71, file=trim(rundir)//'/x.txt')
      write(71,*) (x(i), i=1, N)
      close(71)
      open(unit=71, file=trim(rundir)//'/v.txt')
      write(71,*) (v(i), i=1, Nv)
      close(71)

      ! Generate list of mode numbers
      open(unit=71, file=trim(rundir)//'/n_k.txt')      
      write(71,*) (i, i=0, nharmonics)
      close(71)
      
      ! Post-process rho data
      write(*,*) 'Post-processing rho data'
      open(unit=2, file=trim(rundir)//'/rhotot.bdat', 
     +       ACCESS="STREAM",
     + form='unformatted')
      open(unit=3, 
     +  file=trim(rundir)//'/rho_movie.txt')
      open(unit=4, 
     +  file=trim(rundir)//'/rho_movie_t.txt')
      open(unit=75, 
     +  file=trim(rundir)//'/total_charge.txt')
      open(unit=76, 
     +  file=trim(rundir)//'/rho_fundamental.txt')
      open(unit=7, 
     +  file=trim(rundir)//'/rho_FT_movie.txt')
      open(unit=8, 
     + file=trim(rundir)//'/rho_harmonics.txt')
      open(unit=9, 
     + file=trim(rundir)//'/rho_harmonics_re.txt')
      open(unit=10, 
     + file=trim(rundir)//'/rho_harmonics_im.txt')
      do it=0, Nt
         if(mod(it, nsave)==0) then
            ! Read this rho
            read(2) rhotot
            !print *,'it=',it,Nt
            ! Write out movie data
            if(mod(it, nmovierho) == 0) then
               write(3, *) (rhotot(i), i=1,N)
               write(4, *) it*dt
            endif
            ! Calculate total charge
            Q = 0.
            do i=1, N
               Q = Q + rhotot(i)
            enddo
            Q = Q * L / N
            write(75,*) it*dt,  Q
            ! Take Fourier transform
            do i=1, N
               rhoft(i) = rhotot(i)
            enddo
            call ZFFTF(N, rhoft, table)
            call normfft_sqrtN(cmplx(rhoft,kind=16), N)
            ! Get amplitude of fundamental mode
            rhofundamental = 2.*abs(rhoft(modeorder+1))     
            ! Write out amplitude of fundamental mode
            write(76, *) it * dt, rhofundamental
            ! Write out amplitude of harmonics
            do j=1, nharmonics
               rhoharmonics(j) = 2.*abs(rhoft(j))
               rhoharmonicsre(j) = real(rhoft(j))
               rhoharmonicsim(j) = aimag(rhoft(j))
            enddo
            write(8,*) (rhoharmonics(j), j=1, nharmonics)
            write(9,*) (rhoharmonicsre(j), j=1, nharmonics)
            write(10,*) (rhoharmonicsim(j), j=1, nharmonics)
            ! Write out movie for FT of rho
            if(mod(it, nmovierho)==0) then
               write(7,*) (2.*abs(rhoft(i)), i=1,N/2)
            endif
         endif
      enddo
      close(2)
      close(3)
      close(4)
      close(75)
      close(76)
      close(7)
      close(8)
      close(9)
      close(10)

      ! Post-process E-field data
      write(*,*) 'Post-processing E-field data'
      open(unit=14, file=trim(rundir)//'/efield.bdat', 
     +       ACCESS="STREAM",
     +  form='unformatted')
      open(unit=15, 
     +  file=trim(rundir)//'/efield_movie.txt')
      open(unit=16, 
     +  file=trim(rundir)//'/efield_movie_t.txt')
      open(unit=17, 
     +  file=trim(rundir)//'/rho_from_E_movie.txt')
      open(unit=18, 
     +  file=trim(rundir)//'/phi_movie.txt')
      open(unit=19, 
     +  file=trim(rundir)//'/efield_fundamental.txt')
      open(unit=13, 
     +  file=trim(rundir)//'/deltaf_efield_movie.txt')
      open(unit=21, 
     +  file=trim(rundir)//'/efield_vs_t.txt')
      open(unit=11, 
     +  file=trim(rundir)//'/adr.bdat', 
     +       ACCESS="STREAM",
     +     form='unformatted')
      open(unit=12, 
     +  file=trim(rundir)//'/adr.txt')
      open(unit=111, 
     +  file=trim(rundir)//'/Edr.bdat', 
     +       ACCESS="STREAM",
     +     form='unformatted')
      open(unit=112, 
     +  file=trim(rundir)//'/Edr.txt')
      open(unit=113, 
     +  file=trim(rundir)//'/Edr_t.txt')
      open(unit=20, 
     +  file=trim(rundir)//'/efield_FT_movie.txt')
      open(unit=120, 
     +  file=trim(rundir)//'/ESE.txt')
      do it=0, Nt
         if(mod(it, nsave)==0) then
            ! Read this efield
            read(14) efield
            ! Write out movie data
            if(mod(it, nmovieefield) == 0) then
               write(15, *) (efield(i), i=1,N)
               write(16, *) it * dt
            endif
            ! Write out data for delta-f movie
            ! Write out only one vortex
            if(mod(it, nmoviedeltaf) == 0) then
               write(13, *) (efield(i), i=1, N/mbox)
            endif
            
            ! Write out E-field at position x=0
            write(21,*) it*dt, efield(1)
            
            ! Take Fourier transform
            do i=1, N
               efieldft(i) = efield(i)
            enddo
            call ZFFTF(N, efieldft, table)
            call normfft_sqrtN(cmplx(efieldft,kind=16), N)
            ! Get amplitude of fundamental mode
            efieldfundamental = 2.*abs(efieldft(modeorder+1))     
            ! Write out amplitude of fundamental mode
            write(19, *) it * dt, efieldfundamental
            ! Write out movie of FT of E-field
            if(mod(it, nmovieefield)==0) then
               write(20,*) (2.*abs(efieldft(i)), i=1,N/2)
            endif
            
            ! Calculate electrostatic energy
            ESE = 0.
            do i=1,N
               ESE = ESE + efield(i)*efield(i)/(8.*pi)
            enddo
            ESE = ESE * 0.5_8 * L / float(N)
            write(120,*) it*dt, ESE
            
            ! Calculate rho and phi from the E-field
            if(mod(it, nmovieefield)==0) then
               dk = 2.*pi / L
               rhoft(1) = 0.
               phift(1) = 0.
               do i=2, N/2
                  k = dfloat(i-1) * dk
                  rhoft(i) = efieldft(i) * ii * k
                  phift(i) = efieldft(i) / ii / k
               enddo
               do i=N/2+1, N
                  k = dfloat(i-1-N) * dk
                  rhoft(i) = efieldft(i) * ii * k
                  phift(i) = efieldft(i) / ii / k
               enddo
               call ZFFTB(N, rhoft, table)
               call normfft_sqrtN(cmplx(rhoft,kind=16), N)
               call ZFFTB(N, phift, table)
               call normfft_sqrtN(cmplx(phift,kind=16), N)
               do i=1, N
                  rho_from_E(i) = real(rhoft(i))
                  phi(i) = real(phift(i))
               enddo
               ! Write out movie data for rho and phi
               write(17,*) rho_from_E
               write(18,*) phi
            endif
            
            ! Read amplitude of ponderomotive force
            read(11) adr
            write(12,*) it*dt, adr
            read(111) Edr
            if(mod(it, nmovieEdr) == 0) then
               write(112,*) Edr
               write(113,*) it*dt
            endif
               
            
         endif
      enddo
      close(14)
      close(15)
      close(16)
      close(17)
      close(18)
      close(19)
      close(13)
      close(11)
      close(12)
      close(20)
      close(111)
      close(112)
      close(113)
      close(21)
      close(120)
                             
      ! Post-process delta-f data
      write(*,*) 'Post-processing delta-f data'
      open(unit=21, 
     +  file=trim(rundir)//'/deltaf.bdat', 
     +       ACCESS="STREAM",
     +  form='unformatted')
      open(unit=201,
     +  file=trim(rundir)//'/f0.bdat',
     +       ACCESS="STREAM",
     +  form='unformatted')
      open(unit=22, 
     +  file=trim(rundir)//'/deltaf_movie.txt')
      open(unit=23, 
     +  file=trim(rundir)//'/deltaf_movie_t.txt')
      open(unit=24, 
     +  file=trim(rundir)//'/deltaf_movie_v.txt')
      open(unit=32, 
     +  file=trim(rundir)//'/deltaf_movie_allv.txt')
      open(unit=33,
     +  file=trim(rundir)//'/deltaf_movie_v_allv.txt')
      open(unit=34, 
     +  file=trim(rundir)//'/deltaf_min_max.txt')
      open(unit=35, 
     +  file=trim(rundir)//'/deltaf_min_max_allv.txt')
      open(unit=25, 
     +  file=trim(rundir)//'/entropy1.txt')
      open(unit=26, 
     +  file=trim(rundir)//'/entropy2.txt')
      open(unit=27,
     +  file=trim(rundir)//'/dist_v.txt')
      open(unit=28,
     +  file=trim(rundir)//'/KE.txt')
      open(unit=41, 
     +  file=trim(rundir)//'/f_kx_v_re.txt')
      open(unit=42, 
     +  file=trim(rundir)//'/f_kx_v_im.txt')
      open(unit=43,
     +  file=trim(rundir)//'/f_kx_v_t.txt')
!      open(unit=44, 
!     +  file=trim(rundir)//'/f_kx_v_re_movie.txt')
!      open(unit=45, 
!     +  file=trim(rundir)//'/f_kx_v_im_movie.txt')
      open(unit=50,
     +  file=trim(rundir)//'/f_0.txt')
      open(unit=51,
     +  file=trim(rundir)//'/f_0_allv.txt')
      ! Those are temporary outputs: data points belonging
      ! to the outer orange and blue regions
      open(unit=60, 
     +  file=trim(rundir)//'/orange_v.txt')
      open(unit=61, 
     +  file=trim(rundir)//'/orange_f.txt')
      open(unit=62, 
     +  file=trim(rundir)//'/blue_v.txt')
      open(unit=63,
     +  file=trim(rundir)//'/blue_f.txt')
      open(unit=64,
     +  file=trim(rundir)//'/orange_t.txt')
      open(unit=65,
     +  file=trim(rundir)//'/blue_t.txt')
          
     
   
      vphase = omega0/k0
      dv = (vxmax-vxmin)/dfloat(Nv)
      ivmin = int((vrangemin - vxmin)/(vxmax-vxmin)*Nv)
      ivmax = int((vrangemax - vxmin)/(vxmax-vxmin)*Nv)
      !write(*,*) 'ivmin, ivmax:', ivmin, ivmax
      !write(*,*) 'vrange: ', v(ivmin), v(ivmax)
      if(ivmin > Nv) then
         ivmin = Nv-1
      endif
      if(ivmax > Nv) then
         ivmax = Nv
      endif
      do j=ivmin, ivmax
         write(24,*) v(j)
      enddo
      close(24)
      do j=1, Nv
         write(33,*) v(j)
      enddo
      close(33)
      ! Read initial distribution
      read(201) f0
      ! Write out initial distribution 
      do j=ivmin, ivmax
         write(50,*) (f0(i,j), i=1, N)
      enddo
      do j=1, Nv
         write(51,*) (f0(i,j), i=1, N)
      enddo
      close(50)
      close(51)
      
      ! Calculate initial velocity distribution
      do j=1, Nv
         intf = 0.
         do i=1, N
            intf = f0(i,j)
         enddo
         distv0(j) = intf * L/float(N)
      enddo
      ! Now, look at the time evolution of delta-f(x,v)
      do it=0, Nt
         if(it*dt > Tsetup) then
            nsavef = nsavef2
         else
            nsavef = nsavef1
         endif
         !print *,'nsavef=',nsavef
         ! At least for now, we write out every available
         ! time step to calculate Fourier transforms in time
         !nmoviedeltaf = nsavef
         
         if(mod(it, nsavef)==0) then
            ! Read this delta-f
            write(*,*) 'reading data, it=', it
            read(21) deltaf
            
            ! Write out movie data
            if(mod(it, nmoviedeltaf)==0) then
               do j=ivmin, ivmax
                  ! Write out one vortex only
                  write(22,*) (deltaf(i,j), i=1, N/mbox)
               enddo
               ! Don't write out the all-v movie (it's a large file and
               ! we are not looking at that movie for now)
               !do j=1, Nv
               !   write(32,*) (deltaf(i,j), i=1, N)
               !enddo
               write(23, *) it * dt
               ! Calculate min and max values of 'all-v' movie
               min_delta_f = 0.
               max_delta_f = 0.
               do i=1, N/mbox
                  do j=1, Nv
                     if(deltaf(i,j) > max_delta_f) then
                        max_delta_f = deltaf(i,j)
                     elseif(deltaf(i,j) < min_delta_f) then
                        min_delta_f = deltaf(i,j)
                     endif
                  enddo
               enddo
               write(35,*) min_delta_f, max_delta_f
                ! Calculate min and max values of 'zoom' movie
               min_delta_f = 0.
               max_delta_f = 0.
               do i=1, N/mbox
                  do j=ivmin, ivmax
                     if(deltaf(i,j) > max_delta_f) then
                        max_delta_f = deltaf(i,j)
                     elseif(deltaf(i,j) < min_delta_f) then
                        min_delta_f = deltaf(i,j)
                     endif
                  enddo
               enddo
               write(34,*) min_delta_f, max_delta_f
               
               ! Calculate space-averaged velocity distribution
               do j=1, Nv
                  intf = 0.
                  do i=1, N
                     intf = deltaf(i,j)
                  enddo
                  distv(j) = distv0(j) + intf * L/float(N)
               enddo
               write(27,*) distv
               
            endif  ! End of write out movies of f(x,v)
            
            ! Now, calculate Fourier transforms in x. It will be
            ! used to calculate f_hat_hat(k,w).
            ! First, calculate FT in x around the phase velocity
            ! Put zeros everywhere (since only the vicinity of 
            ! v_phase will be used)
            if(it*dt > Tsetup) then
               do j=1, Nv
                  do i=1, N
                     f_kx_v(i,j) = 0.
                  enddo
               enddo
               do j=ivmin, ivmax
                  do i=1, N
                     frowft(i) = deltaf(i,j) + f0(i,j)
                  enddo
                  call ZFFTF(N, frowft, table)
                  call normfft_sqrtN(cmplx(frowft,kind=16), N)
                  do i=1, N/2
                     f_kx_v(i,j) = frowft(i+N/2)
                  enddo
                  do i=N/2+1, N
                     f_kx_v(i,j) = frowft(i-N/2)
                  enddo
                  do i=1, N
                     abs_f_kx_v(i,j) = abs(f_kx_v(i,j))
                     re_f_kx_v(i,j) = real(f_kx_v(i,j))
                     im_f_kx_v(i,j) = aimag(f_kx_v(i,j))
                  enddo
               enddo
               ! Write out f(kx,v) for a few modes, and over the v-range
               ! surrounding v_phase
               do j=ivmin, ivmax
                     write(41,*) (re_f_kx_v(i,j), i=N/2+1, 
     +                         N/2+1+nharmonics)
                     write(42,*) (im_f_kx_v(i,j), i=N/2+1, 
     +                         N/2+1+nharmonics)
               enddo
!               ! Write out all harmonics, but not for every time step
!               if(mod(it, nmoviedeltaf)==0) then
!                  do j=ivmin, ivmax
!                        write(44,*) (re_f_kx_v(i,j), i=1, N)
!                        write(45,*) (im_f_kx_v(i,j), i=1, N)
!                  enddo
!               endif
               write(43,*) it*dt
            endif
                    
                        
            ! Calculate entropy and kinetic energy
            entropy1 = 0.
            entropy2 = 0.
            KE = 0.
            do i=1, N
               do j=1, Nv
                  f = f0(i,j) + deltaf(i,j)
                  entropy1 = entropy1 + f*dlog(f+1.e-8)
                  entropy2 = entropy2 + f*f
                  KE = KE + 0.5_8*f*v(j)*v(j)
               enddo
            enddo 
            entropy1 = entropy1 * L/dfloat(N) * dv
            entropy2 = entropy2 * L/dfloat(N) * dv 
            KE = KE * L/dfloat(N) * dv
            write(25, *) it * dt, entropy1
            write(26, *) it * dt, entropy2
            write(28, *) it * dt, KE
            
            
            
!            ! TEMPORARY: WRITE OUT DATA POINTS BELONGING
!            ! TO THE OUTER ORANGE AND BLUE REGION (IN THE CASE
!            ! OF A CANONICAL RUN)
!            
!            part_boundaries(1) = 0.27
!            part_boundaries(2) = 0.34
!            part_boundaries(3) = 0.43
!            part_boundaries(4) = 0.46
!            part_boundaries(5) = 0.63
!            part_boundaries(6) = 1.
!            f0_max = 1/sqrt(2.*pi)
!            ! Identify outer orange region
!            do i=1,N/mbox
!               N_orange = 0
!               do j= Nv, 1, -1
!                  f = f0(i,j) + deltaf(i,j)
!                  if(f > part_boundaries(1)*f0_max) then
!                     if(f <= part_boundaries(2)*f0_max) then
!                        N_orange = N_orange + 1
!                        orange_v(N_orange) = v(j)
!                        orange_f(N_orange) = f
!                     else
!                        exit
!                     endif
!                  endif
!               enddo
!               ! Write out data: each line is a different x value, and
!               ! all v values are on the same line
!               if(N_orange > 0) then
!                  write(60,*) (orange_v(j), j=1, N_orange)
!                  write(61,*) (orange_f(j), j=1, N_orange)
!               else
!                  write(60,*) '\\'
!                  write(61,*) '\\'
!               endif
!            enddo
!            ! Identify outer blue region 
!            do i=1,N/mbox
!               N_blue = 0
!               do j= Nv, 1, -1
!                  f = f0(i,j) + deltaf(i,j)
!                  if(f > part_boundaries(2)*f0_max) then
!                     if(f <= part_boundaries(3)*f0_max) then
!                        N_blue = N_blue + 1
!                        blue_v(N_blue) = v(j)
!                        blue_f(N_blue) = f
!                     else
!                        exit
!                     endif
!                  endif
!               enddo
!               ! Write out data: each line is a different x value, and
!               ! all v values are on the same line
!               if(N_blue > 0) then
!                  write(62,*) (blue_v(j), j=1, N_blue)
!                  write(63,*) (blue_f(j), j=1, N_blue)
!               else
!                  write(62,*) '\\'
!                  write(63,*) '\\'
!               endif
!            enddo
!            ! Write out this time value
!            write(64,*) it*dt
!            write(65,*) it*dt 
!            write(*,*) 'after writing out ', it*dt   
!            ! END TEMPORARY
        endif
      enddo
      close(21)
      close(22)
      close(23)
      close(25)
      close(28)
      close(26)
      close(32)
      close(34)
      close(35)
      close(201)
      close(27)
      close(41)
      close(42)
      close(43)
      close(44)
      close(45)
      close(60)
      close(61)
      close(62)
      close(63)
      close(64)
      close(65)
      
      end
      
            
      

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Subroutine 'normfft'. 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine normfft(efield, N)
      
      implicit none
      integer N, i
      complex(16) efield(N)
      
      do i=1, N
         efield(i) = efield(i) / N
      enddo
      return
      end

      subroutine normfft_sqrtN(efield, N)
      
      implicit none
      integer N, i
      complex(16) efield(N)
      
      do i=1, N
         efield(i) = efield(i) / sqrt(float(N))
      enddo
      return
      end
      


	   
