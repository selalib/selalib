#!/usr/bin/env python3
"""
SYNOPSIS

    translate_connectivity_info.py [-h,--help] [-v,--verbose] [--version]

DESCRIPTION

    This script translates multiple .txt input files generated by the CAID
    program containing information about the local and global indexing data 
    for a finite element calculation.  The necessary input files are:

    ID.txt
    IEN_0.txt
    IEN_1.txt
    IEN_2.txt
    .
    .
    .
    LM_0.txt
    LM_1.txt
    LM_2.txt
    .
    .
    .

    all of which need to be passed as arguments, in the proper order. The 
    first 2 arguments are however: 
    - the 'base name' of the multipatch, i.e.: the name by which the group
      of patches generated by CAID is known.
    - the number of patches
    
    The script generates one main information file with the name:

    - [base_name]_element_connectivity_main.nml

    Followed by 2*number_patches additional .nml files containing the local
    and local to global indexing information.

EXAMPLES

    ./translate_connectivity_info.py base_name 4 ID.txt IEN_0.txt IEN_1.txt IEN_2.txt IEN_3.txt LM_0.txt LM_1.txt LM_2.txt LM_3.txt

    Please launch the script on the same directory as the group of files to be 
    processed.

EXIT STATUS

    TODO:

AUTHOR

    Edwin CHACON-GOLCHER <golcher@math.unistra.fr>

LICENSE

    Same as Selalib's...

VERSION

    1.0
"""

import sys, os, traceback, optparse
import time
import re
import pprint

sys.stdout = open('translate_connectivity_info.out', 'w')

def main ():

    global options, args
    readfilename   = ""
    flattened = []
    patch_li_names = []       # array for names of local index filenames
    patch_loc_glob_names = [] # array for names of local to global files
    global_indices = []
    num_patches = 0
    pp = pprint.PrettyPrinter(indent=4)
    ngi = 0   # counter, number of global indices

    print('number of arguments passed')
    print(len(args))
    print(args)

    if (len(args) < 5): # 5 is the number of arguments in a 1-patch case
        print( "Insufficient number of arguments. Usage: ")
        print( "user$ ./translate_connectivity_info.py 'base_name' N ID.txt IEN_0.txt IEN_1.txt ... IEN_{N-1} LM_0.txt LM_1.txt ... LM_{N-1}")
        sys.exit()
    # Unfortunately, here we don't do any argument-checking of significance.
    inputname    = args[0]
    num_patches  = args[1]
    outputname   = inputname + "_element_connectivity_main.nml"
    print( "Output will be written to {0}".format(outputname))

    # Open the ID.txt file to load the global index data. According to the
    # rigid convention above, this is always the 3rd argument.
    with open(args[2],'r') as readfile, open(outputname,'w') as writefile:
        now  = time.localtime()
        date = str(now[1]) + "/" + str(now[2]) + "/" + str(now[0])
        mytime = str(now[3]) + ":" + str(now[4]) + ":" + str(now[5]) + "\n"
        writefile.write("! Input namelist describing the element connectivity ")
        writefile.write("information. \n")
        writefile.write("! Generated by the call: "+sys.argv[0] + " " +
                        ' '.join(args) + "\n")
        writefile.write("! on: " + date + "," + mytime)
        writefile.write("\n")

        linelist = readfile.readlines()
        for line in linelist:
            ngi = ngi + 1
            linetemp = line.split() # needed to get rid of newlines
            global_indices.append(linetemp[0]) # hardwired assumption!

        writefile.write("&number_global_indices" + "\n")
        writefile.write("     num_global_indices = " + str(ngi) + "\n")
        writefile.write("/" + "\n\n")

        writefile.write("&global_indices" +"\n")
        writefile.write("     global_indices_array = "+' '.join(global_indices))
        writefile.write("\n")
        writefile.write("/" + "\n\n")

        # Create a list of the filenames that will be created to store the
        # information originally contained in the IEN_i.txt files.
        for i in range(int(num_patches)):
            patch_li_names.append(inputname + "_local_indices_patch" + str(i) +
                                  ".nml")
            
        writefile.write("&local_index_files" + "\n")
        writefile.write("     local_index_file_list = " + 
                        ' '.join(patch_li_names) )
        writefile.write("\n")
        writefile.write("/" + "\n\n")

        # Create a list of the filenames that will be created to store the
        # information originally contained in the LM_i.txt files.
        for i in range(int(num_patches)):
            patch_loc_glob_names.append(inputname + "_local_to_global_patch" +
                                        str(i) + ".nml")
        writefile.write("&local_to_global_files" + "\n")
        writefile.write("     local_to_global_file_list = " + 
                        ' '.join(patch_loc_glob_names) )
        writefile.write("\n")
        writefile.write("/" + "\n\n")

    # At this pont the main connectivity nml file is done.
 
    # Proceed to create the individual files containing the local index 
    # information.
    for i in range(3, int(num_patches)+3):
        with open(args[i],'r') as readfile, open(patch_li_names[i-3],'w') \
            as writefile:
            writefile.write("! Input namelist describing the local index ")
            writefile.write("information. \n")
            writefile.write("! Generated by the call: "+sys.argv[0] + " " +
                            ' '.join(args) + "\n")
            writefile.write("! on: " + date + "," + mytime)
            writefile.write("\n")
            writefile.write("! This file contains the local index information")
            writefile.write(" contained originally in the file: " + args[i])
            writefile.write("\n")
            local_indices_array = []
            linelist = readfile.readlines()
            for line in linelist:
                linetemp = line.split()
                local_indices_array.append(linetemp[:])
            flattened = \
            [item for sublist in local_indices_array for item in sublist]
            writefile.write("&local_spline_indices" + "\n")
            writefile.write("     local_spline_indices_array = " + 
                            ' '.join([str(item) for item in flattened]) + "\n")
            writefile.write("/" + "\n\n")

    # Proceed to create the individual files containing the local 
    # to global index information.
    for i in range(int(num_patches)):
        with open(args[int(num_patches)+3+i],'r') as readfile, \
                open(patch_loc_glob_names[i],'w') as writefile:
            writefile.write("! Input namelist describing the local to global ")
            writefile.write("indexing information. \n")
            writefile.write("! Generated by the call: "+sys.argv[0] + " " +
                            ' '.join(args) + "\n")
            writefile.write("! on: " + date + "," + mytime)
            writefile.write("\n")
            writefile.write("! This file contains the local to global index ")
            writefile.write(" information")
            writefile.write(" contained originally in the file: " + 
                            args[int(num_patches)+3+i])
            writefile.write("\n")
            loc_glob_array = [] #change this name
            linelist = readfile.readlines()
            for line in linelist:
                linetemp = line.split()
                loc_glob_array.append(linetemp[:])
            flattened = \
            [item for sublist in loc_glob_array for item in sublist]
            writefile.write("&local_to_global_indices" + "\n")
            writefile.write("     local_to_global_index_array = " + 
                            ' '.join([str(item) for item in flattened]) + "\n")
            writefile.write("/" + "\n\n")



if __name__ == '__main__':
    try:
        start_time = time.time()
        parser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter(), usage=globals()['__doc__'], version='1.0')
        parser.add_option ('-v', '--verbose', action='store_true', default=False, help='verbose output')
        (options, args) = parser.parse_args()
        #if len(args) < 1:
        #    parser.error ('missing argument')
        if options.verbose: print( time.asctime())
        main()
        if options.verbose: print(* time.asctime())
        if options.verbose: print( 'execution time in seconds:')
        if options.verbose: print( (time.time() - start_time))
        sys.exit(0)
    except KeyboardInterrupt as e: # Ctrl-C
        raise e
    except SystemExit as e: # sys.exit()
        raise e
    except Exception as e:
        print( 'ERROR, UNEXPECTED EXCEPTION')
        print( str(e))
        traceback.print_exc()
        os._exit(1)


