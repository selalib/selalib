module sll_module_deboor_splines_1d

#include "sll_memory.h"
#include "sll_working_precision.h"
#include "sll_utilities.h"
#include "sll_assert.h"
implicit none 

contains
  
    
!*************************************************************************
!
! INTERV brackets a real value in an ascending vector of values.
!
!  Discussion:
!
!    The XT array is a set of increasing values.  The goal of the routine
!    is to determine the largest index I so that XT(I) <= X.
!
!    The routine is designed to be efficient in the common situation
!    that it is called repeatedly, with X taken from an increasing
!    or decreasing sequence.
!
!    This will happen when a piecewise polynomial is to be graphed.
!    The first guess for LEFT is therefore taken to be the value
!    returned at the previous call and stored in the local variable ILO.
!
!    A first check ascertains that ILO < LXT.  This is necessary
!    since the present call may have nothing to do with the previous
!    call.  Then, if
!
!      XT(ILO) <= X < XT(ILO+1),
!
!    we set LEFT = ILO and are done after just three comparisons.
!
!    Otherwise, we repeatedly double the difference ISTEP = IHI - ILO
!    while also moving ILO and IHI in the direction of X, until
!
!      XT(ILO) <= X < XT(IHI)
!
!    after which we use bisection to get, in addition, ILO + 1 = IHI.
!    The value LEFT = ILO is then returned.
!
!  Modified:
!
!    14 February 2007
!
!  Author:
!
!    Carl DeBoor
!
!  Reference:
!
!    Carl DeBoor,
!    A Practical Guide to Splines,
!    Springer, 2001,
!    ISBN: 0387953663.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) XT(LXT), a nondecreasing sequence of values.
!
!    Input, integer LXT, the dimension of XT.
!
!    Input, real ( kind = 8 ) X, the point whose location with
!    respect to the sequence XT is to be determined.
!
!    Output, integer LEFT, the index of the bracketing value:
!      1     if             X  <  XT(1)
!      I     if   XT(I)  <= X  < XT(I+1)
!      LXT   if  XT(LXT) <= X
!
!    Output, integer MFLAG, indicates whether X lies within the
!    range of the data.
!    -1:            X  <  XT(1)
!     0: XT(I)   <= X  < XT(I+1)
!    +1: XT(LXT) <= X
!
subroutine interv( xt, lxt, x, left, mflag )
    
  sll_real64, intent(in)  :: xt(:)
  sll_int32,  intent(in)  :: lxt
  sll_real64, intent(in)  :: x
  sll_int32,  intent(out) :: left
  sll_int32,  intent(out) :: mflag

  sll_int32               :: ihi
  sll_int32, save         :: ilo = 1
  sll_int32               :: istep
  sll_int32               :: middle
    
  ihi = ilo + 1
  if ( lxt <= ihi ) then
    if ( xt(lxt) <= x ) then
      go to 110
    end if
    if ( lxt <= 1 ) then
      mflag = -1
      left = 1
      return
    end if
       
    ilo = lxt - 1
    ihi = lxt
       
  end if
    
  if ( xt(ihi) <= x ) go to 20
    
  if ( xt(ilo) <= x ) then
    mflag = 0
    left = ilo
    return
  end if
  !
  !  Now X < XT(ILO).  Decrease ILO to capture X.
  !
  istep = 1
    
10  continue
    
  ihi = ilo
  ilo = ihi - istep
    
  if ( 1 < ilo ) then
    if ( xt(ilo) <= x ) then
      go to 50
    end if
    istep = istep * 2
    go to 10
  end if
    
  ilo = 1
    
  if ( x < xt(1) ) then
    mflag = -1
    left = 1
    return
  end if
    
  go to 50
  !
  !  Now XT(IHI) <= X.  Increase IHI to capture X.
  !
20 continue
    
  istep = 1
    
30 continue
    
  ilo = ihi
  ihi = ilo + istep
    
  if ( ihi < lxt ) then
       
    if ( x < xt(ihi) ) then
      go to 50
    end if
      
    istep = istep * 2
    go to 30
       
  end if
    
  if ( xt(lxt) <= x ) then
    go to 110
  end if
  !
  !  Now XT(ILO) < = X < XT(IHI).  Narrow the interval.
  !
  ihi = lxt
    
50 continue
    
  do
    middle = ( ilo + ihi ) / 2
    if ( middle == ilo ) then
       mflag = 0
       left = ilo
       return
    end if
    !
    !  It is assumed that MIDDLE = ILO in case IHI = ILO+1.
    !
    if ( xt(middle) <= x ) then
      ilo = middle
    else
      ihi = middle
    end if
       
  end do
  !
  !  Set output and return.
  !
110 continue
    
  mflag = 1
    
  if ( x == xt(lxt) ) mflag = 0
    
  do left = lxt, 1, -1
    if ( xt(left) < xt(lxt) ) return
  end do
    
end subroutine interv

!***********************************************************************
!
! BSPLVB evaluates B-splines at a point X with a given knot sequence.
!
!  Discusion:
!
!    BSPLVB evaluates all possibly nonzero B-splines at X of order
!
!      JOUT = MAX ( JHIGH, (J+1)*(INDEX-1) )
!
!    with knot sequence T.
!
!    The recurrence relation
!
!                     X - T(I)               T(I+J+1) - X
!    B(I,J+1)(X) = ----------- * B(I,J)(X) + --------------- * B(I+1,J)(X)
!                  T(I+J)-T(I)               T(I+J+1)-T(I+1)
!
!    is used to generate B(LEFT-J:LEFT,J+1)(X) from B(LEFT-J+1:LEFT,J)(X)
!    storing the new values in BIATX over the old.
!
!    The facts that
!
!      B(I,1)(X) = 1  if  T(I) <= X < T(I+1)
!
!    and that
!
!      B(I,J)(X) = 0  unless  T(I) <= X < T(I+J)
!
!    are used.
!
!    The particular organization of the calculations follows
!    algorithm 8 in chapter X of the text.
!
!  Modified:
!
!    14 February 2007
!
!  Author:
!
!    Carl DeBoor
!
!  Reference:
!
!    Carl DeBoor,
!    A Practical Guide to Splines,
!    Springer, 2001,
!    ISBN: 0387953663.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) T(LEFT+JOUT), the knot sequence.  T is assumed to
!    be nondecreasing, and also, T(LEFT) must be strictly less than
!    T(LEFT+1).
!
!    Input, integer JHIGH, INDEX, determine the order
!    JOUT = max ( JHIGH, (J+1)*(INDEX-1) )
!    of the B-splines whose values at X are to be returned.
!    INDEX is used to avoid recalculations when several
!    columns of the triangular array of B-spline values are
!    needed, for example, in BVALUE or in BSPLVD.
!    If INDEX = 1, the calculation starts from scratch and the entire
!    triangular array of B-spline values of orders
!    1, 2, ...,JHIGH is generated order by order, that is,
!    column by column.
!    If INDEX = 2, only the B-spline values of order J+1, J+2, ..., JOUT
!    are generated, the assumption being that BIATX, J,
!    DELTAL, DELTAR are, on entry, as they were on exit
!    at the previous call.  In particular, if JHIGH = 0,
!    then JOUT = J+1, that is, just the next column of B-spline
!    values is generated.
!    Warning: the restriction  JOUT <= JMAX (= 20) is
!    imposed arbitrarily by the dimension statement for DELTAL
!    and DELTAR, but is nowhere checked for.
!
!    Input, real ( kind = 8 ) X, the point at which the B-splines
!    are to be evaluated.
!
!    Input, integer LEFT, an integer chosen so that
!    T(LEFT) <= X <= T(LEFT+1).
!
!    Output, real ( kind = 8 ) BIATX(JOUT), with BIATX(I) containing the
!    value at X of the polynomial of order JOUT which agrees
!    with the B-spline B(LEFT-JOUT+I,JOUT,T) on the interval
!    (T(LEFT),T(LEFT+1)).
!
subroutine bsplvb ( t, jhigh, index, x, left, biatx )
    
  sll_real64, intent(in)  :: t(:)  ! left+jhigh
  sll_int32,  intent(in)  :: jhigh
  sll_int32,  intent(in)  :: index
  sll_real64, intent(in)  :: x
  sll_int32,  intent(in)  :: left
  sll_real64, intent(out) :: biatx(jhigh)

  sll_real64, save :: deltal(20)
  sll_real64, save :: deltar(20)
  sll_int32,  save :: j=1

  sll_int32   :: i
  sll_real64  :: saved
  sll_real64  :: term
    
  if ( index == 1 ) then
    j = 1
    biatx(1) = 1.0_8
    if ( jhigh <= j ) return
  end if
    
  SLL_ASSERT( t(left+1) > t(left) )

  !PN replaced by selalib assertion
  !if ( t(left+1) <= t(left) ) then
  !   print*,'x=',x
  !   write ( *, '(a)' ) ' '
  !   write ( *, '(a)' ) 'BSPLVB - Fatal error!'
  !   write ( *, '(a)' ) '  It is required that T(LEFT) < T(LEFT+1).'
  !   write ( *, '(a,i8)' ) '  But LEFT = ', left
  !   write ( *, '(a,g14.6)' ) '  T(LEFT) =   ', t(left)
  !   write ( *, '(a,g14.6)' ) '  T(LEFT+1) = ', t(left+1)
  !   stop
  !end if
    
  do
       
    deltar(j) = t(left+j) - x
    deltal(j) = x - t(left+1-j)
      
    saved = 0.0_f64
    do i = 1, j
      term = biatx(i) / ( deltar(i) + deltal(j+1-i) )
      biatx(i) = saved + deltar(i) * term
      saved = deltal(j+1-i) * term
    end do
    
    biatx(j+1) = saved
    j = j + 1
       
    if ( jhigh <= j ) exit
    
  end do
    
end subroutine bsplvb

!*************************************************************************
!
! BSPLVD calculates the nonvanishing B-splines and derivatives at X.
!
!  Discussion:
!
!    Values at X of all the relevant B-splines of order K:K+1-NDERIV
!    are generated via BSPLVB and stored temporarily in DBIATX.
!
!    Then the B-spline coefficients of the required derivatives
!    of the B-splines of interest are generated by differencing,
!    each from the preceding one of lower order, and combined with
!    the values of B-splines of corresponding order in DBIATX
!    to produce the desired values.
!
!  Modified:
!
!    14 February 2007
!
!  Author:
!
!    Carl DeBoor
!
!  Reference:
!
!    Carl DeBoor,
!    A Practical Guide to Splines,
!    Springer, 2001,
!    ISBN: 0387953663.
!
!  Parameters:
!
!Input, real ( kind = 8 ) T(LEFT+K), the knot sequence.  It is assumed that
!    T(LEFT) < T(LEFT+1).  Also, the output is correct only if
!    T(LEFT) <= X <= T(LEFT+1).
!
!    Input, integer K, the order of the B-splines to be evaluated.
!
!    Input, real ( kind = 8 ) X, the point at which these values are sought.
!
!    Input, integer LEFT, indicates the left endpoint of the interval of
!    interest.  The K B-splines whose support contains the interval
!    ( T(LEFT), T(LEFT+1) ) are to be considered.
!
!    Workspace, real ( kind = 8 ) A(K,K).
!
!    Output, real ( kind = 8 ) DBIATX(K,NDERIV).  DBIATX(I,M) contains
!    the value of the (M-1)st derivative of the (LEFT-K+I)-th B-spline
!    of order K for knot sequence T, I=M,...,K, M=1,...,NDERIV.
!
!    Input, integer NDERIV, indicates that values of B-splines and their
!    derivatives up to but not including the NDERIV-th are asked for.
!
subroutine bsplvd ( t, k, x, left, a, dbiatx, nderiv )
    
  sll_real64, intent(in)     :: t(:)  !dimension(left+k)
  sll_int32,  intent(in)     :: k
  sll_real64, intent(in)     :: x
  sll_int32,  intent(in)     :: left
  sll_real64, intent(inout)  :: a(:,:) !dimesnion(k,k)
  sll_int32,  intent(in)     :: nderiv
  sll_real64, intent(out)    :: dbiatx(k,nderiv)
    
  sll_real64:: factor
  sll_real64:: fkp1mm
  sll_int32 :: i
  sll_int32 :: ideriv
  sll_int32 :: il
  sll_int32 :: j
  sll_int32 :: jlow
  sll_int32 :: jp1mid
  sll_int32 :: ldummy
  sll_int32 :: m
  sll_int32 :: mhigh
    
  mhigh = max ( min ( nderiv, k ), 1 )
  !
  !  MHIGH is usually equal to NDERIV.
  !
  call bsplvb ( t, k+1-mhigh, 1, x, left, dbiatx )
    
  if ( mhigh == 1 ) return

  !  The first column of DBIATX always contains the B-spline values
  !  for the current order.  These are stored in column K+1-current
  !  order before BSPLVB is called to put values for the next
  !  higher order on top of it.

  ideriv = mhigh
  do m = 2, mhigh
    jp1mid = 1
    do j = ideriv, k
      dbiatx(j,ideriv) = dbiatx(jp1mid,1)
      jp1mid = jp1mid + 1
    end do
    ideriv = ideriv - 1
    call bsplvb ( t, k+1-ideriv, 2, x, left, dbiatx )
  end do
  !
  !  At this point, B(LEFT-K+I, K+1-J)(X) is in DBIATX(I,J) for
  !  I=J,...,K and J=1,...,MHIGH ('=' NDERIV).
  !
  !  In particular, the first column of DBIATX is already in final form.
  !
  !  To obtain corresponding derivatives of B-splines in subsequent columns,
  !  generate their B-representation by differencing, then evaluate at X.
  !
  jlow = 1
  do i = 1, k
    a(jlow:k,i) = 0.0D+00
    jlow = i
    a(i,i) = 1.0D+00
  end do
  !
  !  At this point, A(.,J) contains the B-coefficients for the J-th of the
  !  K B-splines of interest here.
  !
  do m = 2, mhigh
     
    fkp1mm = real ( k + 1 - m, kind = 8 )
    il = left
    i = k
    !
    !  For J = 1,...,K, construct B-coefficients of (M-1)st derivative of
    !  B-splines from those for preceding derivative by differencing
    !  and store again in  A(.,J).  The fact that  A(I,J) = 0 for
    !  I < J is used.
    !
    do ldummy = 1, k+1-m
         
      factor = fkp1mm / ( t(il+k+1-m) - t(il) )
      !
      !  The assumption that T(LEFT) < T(LEFT+1) makes denominator
      !  in FACTOR nonzero.
      !
      a(i,1:i) = ( a(i,1:i) - a(i-1,1:i) ) * factor
         
      il = il - 1
      i = i - 1
     
    end do
    !
    !  For I = 1,...,K, combine B-coefficients A(.,I) with B-spline values
    !  stored in DBIATX(.,M) to get value of (M-1)st derivative of
    !  I-th B-spline (of interest here) at X, and store in DBIATX(I,M).
    !
    !  Storage of this value over the value of a B-spline
    !  of order M there is safe since the remaining B-spline derivatives
    !  of the same order do not use this value due to the fact
    !  that  A(J,I) = 0  for J < I.
    !
    do i = 1, k
          
      jlow = max ( i, m )
       
      dbiatx(i,m) = dot_product ( a(jlow:k,i), dbiatx(jlow:k,m) )
        
    end do
    
  end do

end subroutine bsplvd

!*********************************************************************
!
! BVALUE evaluates a derivative of a spline from
! its B-spline representation.
!
!  Discussion:
!
!    The spline is taken to be continuous from the right.
!
!    The nontrivial knot interval (T(I),T(I+1)) containing X is
!    located with the aid of INTERV.  The K B-spline coefficients
!    of F relevant for this interval are then obtained from BCOEF,
!    or are taken to be zero if not explicitly available, and are
!    then differenced JDERIV times to obtain the B-spline
!    coefficients of (D**JDERIV)F relevant for that interval.
!
!    Precisely, with J = JDERIV, we have from X.(12) of the text that:
!
!      (D**J)F = sum ( BCOEF(.,J)*B(.,K-J,T) )
!
!    where
!                      / BCOEF(.),                    if J == 0
!                     /
!       BCOEF(.,J) = / BCOEF(.,J-1) - BCOEF(.-1,J-1)
!                   / -----------------------------,  if 0 < J
!                  /    (T(.+K-J) - T(.))/(K-J)
!
!    Then, we use repeatedly the fact that
!
!      sum ( A(.) * B(.,M,T)(X) ) = sum ( A(.,X) * B(.,M-1,T)(X) )
!
!    with
!                   (X - T(.))*A(.) + (T(.+M-1) - X)*A(.-1)
!      A(.,X) =   ---------------------------------------
!                   (X - T(.))      + (T(.+M-1) - X)
!
!    to write (D**J)F(X) eventually as a linear combination of
!    B-splines of order 1, and the coefficient for B(I,1,T)(X)
!    must then be the desired number (D**J)F(X).
!    See Chapter X, (17)-(19) of text.
!
!  Modified:
!
!    14 February 2007
!
!  Author:
!
!    Carl DeBoor
!
!  Reference:
!
!    Carl DeBoor,
!    A Practical Guide to Splines,
!    Springer, 2001,
!    ISBN: 0387953663.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) T(N+K), the knot sequence.  T is assumed
!    to be nondecreasing.
!
!    Input, real ( kind = 8 ) BCOEF(N), B-spline coefficient sequence.
!
!    Input, integer N, the length of BCOEF.
!
!    Input, integer K, the order of the spline.
!
!    Input, real ( kind = 8 ) X, the point at which to evaluate.
!
!    Input, integer JDERIV, the order of the derivative to
!    be evaluated.  JDERIV is assumed to be zero or positive.
!
!    Output, real ( kind = 8 ) BVALUE, the value of the (JDERIV)-th
!    derivative of the spline at X.
!
function bvalue( t, bcoef, n, k, x, jderiv ) result(res)
    
  sll_real64, intent(in) :: t(:)      !< knot sequence (n+k)
  sll_real64, intent(in) :: bcoef(:)  !< B-spline (n)
  sll_int32,  intent(in) :: n         !< B-spline length
  sll_int32,  intent(in) :: k         !< order of the spline
  sll_real64, intent(in) :: x         !< evalueation point
  sll_int32,  intent(in) :: jderiv    !< order of the derivative
  
  sll_real64 :: res
  sll_real64 :: aj(k)
  sll_real64 :: dl(k)
  sll_real64 :: dr(k)
  sll_int32  :: i
  sll_int32  :: ilo
  sll_int32  :: j
  sll_int32  :: jc
  sll_int32  :: jcmax
  sll_int32  :: jcmin
  sll_int32  :: jj
  sll_int32  :: mflag
  
  SLL_ASSERT(size(t)     == n+k)
  SLL_ASSERT(size(bcoef) == n  )

  res = 0.0_8
    
  aj(:)=0.0_8
  dl(:)=0.0_8
  dr(:)=0.0_8
    
  if ( k <= jderiv ) then
    return
  end if
  !
  !  Find I so that 1 <= I < N+K and T(I) < T(I+1) and T(I) <= X < T(I+1).
  !
  !  If no such I can be found, X lies outside the support of the
  !  spline F and  BVALUE = 0.  The asymmetry in this choice of I makes F
  !  right continuous.
  !
  call interv ( t, n+k, x, i, mflag )
   
  if ( mflag /= 0 ) then
     return
  end if
  !
  !  If K = 1 (and JDERIV = 0), BVALUE = BCOEF(I).
  !
  if ( k <= 1 ) then
    res = bcoef(i)
    return
  end if
  !
  !  Store the K B-spline coefficients relevant for the knot interval
  !  ( T(I),T(I+1) ) in AJ(1),...,AJ(K) and compute DL(J) = X - T(I+1-J),
  !  DR(J) = T(I+J)-X, J=1,...,K-1.  Set any of the AJ not obtainable
  !  from input to zero.
  !
  !  Set any T's not obtainable equal to T(1) or to T(N+K) appropriately.
  !
  jcmin = 1
    
  if ( k <= i ) then
       
    do j = 1, k-1
      dl(j) = x - t(i+1-j)
    end do
       
  else
       
    jcmin = 1 - ( i - k )
     
    do j = 1, i
      dl(j) = x - t(i+1-j)
    end do
       
    do j = i, k-1
      aj(k-j) = 0.0_8
      dl(j) = dl(i)
    end do
       
  end if
    
  jcmax = k
  
  if ( n < i ) then
       
    jcmax = k + n - i
    do j = 1, k + n - i
      dr(j) = t(i+j) - x
    end do
       
    do j = k+n-i, k-1
      aj(j+1) = 0.0_8
      dr(j) = dr(k+n-i)
    end do
       
  else
       
    do j = 1, k-1
      dr(j) = t(i+j) - x
    end do
       
  end if
    
  do jc = jcmin, jcmax
    aj(jc) = bcoef(i-k+jc)
  end do
  
  !  Difference the coefficients JDERIV times.
  
  do j = 1, jderiv
      
    ilo = k - j
    do jj = 1, k - j
      aj(jj) = ((aj(jj+1)-aj(jj))/(dl(ilo)+dr(jj)))*real(k-j,kind=8)
      ilo = ilo - 1
    end do
       
  end do
  
  !  Compute value at X in (T(I),T(I+1)) of JDERIV-th derivative,
  !  given its relevant B-spline coefficients in AJ(1),...,AJ(K-JDERIV).
  
  do j = jderiv+1, k-1
    ilo = k-j
    do jj = 1, k-j
      aj(jj) = (aj(jj+1)*dl(ilo)+aj(jj)*dr(jj))/(dl(ilo)+dr(jj))
      ilo = ilo - 1
    end do
  end do

  res = aj(1)
   
  return
    
end function bvalue
  
  
!> Compute interpolanats for Dirichlet boundar conditions
subroutine spli1d_dir(nx, kx, taux, g, bcoef, tx)

sll_int32               , intent(in)    :: nx    !< number of points
sll_int32               , intent(in)    :: kx    !< number of knots
sll_real64, dimension(:), intent(in)    :: taux  !< knots sequence
sll_real64, dimension(:), intent(in)    :: g     !< data ordinates
sll_real64, dimension(:), intent(inout) :: bcoef !< B-splines
sll_real64, dimension(:), intent(inout) :: tx    !< Knots positions
sll_int32                               :: i
    
    
! *** set up knots and interpolate between knots
tx(1:kx)       = taux(1)
tx(nx+1:nx+kx) = taux(nx)
  
if (mod(kx,2) == 0) then
  do i = kx+1, nx
    tx(i) = taux(i-kx/2) 
  end do
else
  do i = kx+1, nx
    tx(i) = 0.5*(taux(i-(kx-1)/2)+taux(i-1-(kx-1)/2))
  end do
end if
    
call splint(taux, g, tx, nx, kx, bcoef)
  
end subroutine spli1d_dir

!> @brief
!> Compute interpolants for periodic BC
!> @details
!> Construct knots and call De Boor routine splint
subroutine spli1d_per( L, nx, kx, taux, g, bcoef, tx)

sll_real64, intent(in)    :: L        !< Periodicity length
sll_int32,  intent(in)    :: nx       !< Number of data points
sll_int32,  intent(in)    :: kx       !< Splines degree
sll_real64, intent(in)    :: taux(:)  !< Points positions
sll_real64, intent(in)    :: g(:)     !< Data values at points
sll_real64, intent(inout) :: bcoef(:) !< Spline coefficients
sll_real64, intent(inout) :: tx(:)    !< Knots positions

sll_int32 :: i

SLL_ASSERT ( L /= 0.0_8 )
  
tx(1:kx)       = taux(1)
tx(nx+1:nx+kx) = taux(nx)
  
if (mod(kx,2) == 0) then
  do i = kx + 1, nx
    tx(i) = taux(i-kx/2) 
  end do
else
  do i = kx + 1, nx
    tx(i) = 0.5*(taux(i-(kx-1)/2)+taux(i-1-(kx-1)/2))
  end do
end if

call splint( taux, g, tx, nx, kx, bcoef)
    
end subroutine spli1d_per

!> @brief
!> Compute interpolants for non periodic BC
!> @details
!> Add conditions on values and their derivatives.
subroutine spli1d_der( nx,       &
                       nx_der,   &
                       kx,       &
                       taux,     &
                       g,        &
                       taux_der, &
                       g_der,    &
                       bcoef,    &
                       tx)

  sll_int32,  intent(in)    :: nx          !< Number of data points
  sll_int32,  intent(in)    :: kx          !< Spline degree
  sll_int32,  intent(in)    :: nx_der      !< Number of data derivatives points
  sll_real64, intent(in)    :: taux(:)     !< Positions of points for data values
  sll_real64, intent(in)    :: g(:)        !< Data values
  sll_int32,  intent(in)    :: taux_der(:) !< Node index to evaluate derivative
  sll_real64, intent(in)    :: g_der(:)    !< Values of data derivatives
  sll_real64, intent(inout) :: bcoef(:)    !< Splines coefficients
  sll_real64, intent(inout) :: tx(:)       !< Knots positions
  
  tx = 0.0_f64
  tx(1:kx) = taux(1)
  tx(nx+nx_der+1:nx+nx_der+kx) = taux(nx)
  
  if (nx+nx_der+kx == nx + 2*(kx-1)) then
    tx(kx+1:nx+nx_der) = taux(2:nx-1)
  else
    SLL_WARNING('problem with construction of knots')
  end if

  call splint_der ( taux,     &
                    g,        &
                    taux_der, &
                    g_der,    &
                    tx,       &
                    nx,       &
                    nx_der,   &
                    kx,       &
                    bcoef)
    
end subroutine spli1d_der

!*************************************************************************
!
! SPLINT produces the B-spline coefficients BCOEF of an 
! interpolating spline.
!
!  Discussion:
!
!    The spline is of order K with knots T(1:N+K), and takes on the 
!    value GTAU(I) at TAU(I), for I = 1 to N.
!
!    The I-th equation of the linear system 
!
!      A * BCOEF = B 
!
!    for the B-spline coefficients of the interpolant enforces interpolation
!    at TAU(1:N).
!
!    Hence, B(I) = GTAU(I), for all I, and A is a band matrix with 2*K-1
!    bands, if it is invertible.
!
!    The matrix A is generated row by row and stored, diagonal by diagonal,
!    in the rows of the array Q, with the main diagonal going
!    into row K.  See comments in the program.
!
!    The banded system is then solved by a call to BANFAC, which 
!    constructs the triangular factorization for A and stores it again in
!    Q, followed by a call to BANSLV, which then obtains the solution
!    BCOEF by substitution.
!
!    BANFAC does no pivoting, since the total positivity of the matrix
!    A makes this unnecessary.
!
!    The linear system to be solved is (theoretically) invertible if
!    and only if
!      T(I) < TAU(I) < TAU(I+K), for all I.
!    Violation of this condition is certain to lead to IFLAG = 2.
!
!  Modified:
!
!    14 February 2007
!
!  Author:
!
!    Carl DeBoor
!
!  Reference:
!
!    Carl DeBoor,
!    A Practical Guide to Splines,
!    Springer, 2001,
!    ISBN: 0387953663,
!    LC: QA1.A647.v27.
!
!  Parameters:
!
! Input, real ( kind = 8 ) TAU(N), the data point abscissas.The entries in
!    TAU should be strictly increasing.
!
!    Input, real ( kind = 8 ) GTAU(N), the data ordinates.
!
!    Input, real ( kind = 8 ) T(N+K), the knot sequence.
!
!    Input, integer ( kind = 4 ) N, the number of data points.
!
!    Input, integer ( kind = 4 ) K, the order of the spline.
!
!    Output, real ( kind = 8 ) Q((2*K-1)*N), the triangular factorization
!    of the coefficient matrix of the linear system for the B-coefficients 
!    of the spline interpolant.  The B-coefficients for the interpolant 
!    of an additional data set can be obtained without going through all 
!    the calculations in this routine, simply by loading HTAU into BCOEF 
!    and then executing the call:
!      call banslv ( q, 2*k-1, n, k-1, k-1, bcoef )
!
!    Output, real ( kind = 8 ) BCOEF(N), the B-spline coefficients of 
!    the interpolant.
!
!    Output, integer ( kind = 4 ) IFLAG, error flag.
!    1, = success.
!    2, = failure.
!
subroutine splint( tau, gtau, t, n, k, bcoef )
    
   
  sll_real64, dimension(:), intent(in)  :: tau   !< data points
  sll_real64, dimension(:), intent(in)  :: gtau  !< data ordinates
  sll_real64, dimension(:), intent(in)  :: t     !< knots sequence
  sll_int32,                intent(in)  :: n     !< number of points
  sll_int32,                intent(in)  :: k     !< spline order
  sll_real64, dimension(:), intent(out) :: bcoef !< Bsplines 

  sll_int32                        :: i
  sll_int32                        :: ilp1mx
  sll_int32                        :: j
  sll_int32                        :: jj
  sll_int32                        :: kpkm2
  sll_int32                        :: left
  sll_real64, dimension((2*k-1)*n) :: q
  sll_real64                       :: taui
  sll_int32                        :: iflag
 
  kpkm2 = 2 * ( k - 1 )
  left = k
  q(1:(2*k-1)*n) = 0.0_f64
  !
  !  Loop over I to construct the N interpolation equations.
  !
  do i = 1, n
       
    taui = tau(i)
    ilp1mx = min ( i + k, n + 1 )
    !
    !  Find LEFT in the closed interval (I,I+K-1) such that
    !
    !    T(LEFT) <= TAU(I) < T(LEFT+1)
    !
    !  The matrix is singular if this is not possible.
    !
    left = max ( left, i )
      
    if ( taui < t(left) ) then
      iflag = 2
      write ( *, '(a)' ) ' '
      write ( *, '(a)' ) 'SPLINT - Fatal Error!'
      write ( *, '(a)' ) '  The linear system is not invertible!'
      return
    end if
   
    do while ( t(left+1) <= taui )
          
      left = left + 1
     
      if ( left < ilp1mx ) cycle
          
      left = left - 1
       
      if ( t(left+1) < taui ) then
        iflag = 2
        write ( *, '(a)' ) ' '
        write ( *, '(a)' ) 'SPLINT - Fatal Error!'
        write ( *, '(a)' ) '  The linear system is not invertible!'
        return
      end if
          
      exit
          
    end do
    
    !  The I-th equation enforces interpolation at TAUI, hence for all J,
    !
    !    A(I,J) = B(J,K,T)(TAUI).
    
    !Only the K entries with J = LEFT-K+1,...,LEFT actually might be nonzero.
    
    !These K numbers are returned, in BCOEF 
    ! (used for temporary storage here),
    !  by the following.
    !
    call bsplvb ( t, k, 1, taui, left, bcoef )
    !
    !  We therefore want BCOEF(J) = B(LEFT-K+J)(TAUI) to go into
    !  A(I,LEFT-K+J), that is, into Q(I-(LEFT+J)+2*K,(LEFT+J)-K) since
    !  A(I+J,J) is to go into Q(I+K,J), for all I, J, if we consider Q
    !  as a two-dimensional array, with  2*K-1 rows.  See comments in
    !  BANFAC.
    !
    !  In the present program, we treat Q as an equivalent
    !  one-dimensional array, because of fortran restrictions on
    !  dimension statements.
    !
    !  We therefore want  BCOEF(J) to go into the entry of Q with index:
    !
    !    I -(LEFT+J)+2*K + ((LEFT+J)-K-1)*(2*K-1)
    !   = I-LEFT+1+(LEFT -K)*(2*K-1) + (2*K-2)*J
    
    jj = i - left + 1 + ( left - k ) * ( k + k - 1 )
       
    do j = 1, k
      jj = jj + kpkm2
      q(jj) = bcoef(j)
    end do
       
  end do
  !
  !  Obtain factorization of A, stored again in Q.
  !
  call banfac ( q, k+k-1, n, k-1, k-1, iflag )
    
  if ( iflag == 2 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SPLINT - Fatal Error!'
    write ( *, '(a)' ) '  The linear system is not invertible!'
    return
  end if
  
  !  Solve 
  !    A * BCOEF = GTAU
  !  by back substitution.
  
  bcoef(1:n) = gtau(1:n)
   
  call banslv ( q, k+k-1, n, k-1, k-1, bcoef )
  
end subroutine splint

    
!*************************************************************************
!
! SPLINT_der produces the B-spline coefficients BCOEF of an 
! interpolating spline with the values of a derivative in points
!
!  Discussion:
!
!    The spline is of order K with knots T(1:N+K+M), and takes on the 
!    value GTAU(I) at TAU(I), for I = 1 to N and 
!    value of the derivative GTAU_der(I) at TAU_der(I), for I = 1 to M
!
!    The I-th equation of the linear system 
!
!      A  * BCOEF = B
!      A' * BCOEF = B'
!
!    for the B-spline coefficients of the interpolant enforces interpolation
!    at TAU(1:N) and the derivative at TAU_der(I).
!
!    Hence, B(I) = GTAU(I) and B'(I) = GTAU_der(I) , for all I,
!    and A is a band matrix with 2*K-1
!    bands, if it is invertible.
!
!    The matrix A is generated row by row and stored, diagonal by diagonal,
!    in the rows of the array Q, with the main diagonal going
!    into row K.  See comments in the program.
!
!    The banded system is then solved by a call to BANFAC, which 
!    constructs the triangular factorization for A and stores it again in
!    Q, followed by a call to BANSLV, which then obtains the solution
!    BCOEF by substitution.
!
!    BANFAC does no pivoting, since the total positivity of the matrix
!    A makes this unnecessary.
!
!    The linear system to be solved is (theoretically) invertible if
!    and only if
!      T(I) < TAU(I) < TAU(I+K), for all I.
!    Violation of this condition is certain to lead to IFLAG = 2.
!
!  Modified:
!
!    10 April 2014
!
!  Author:
!
!    Aurore Back
!
!
!  Parameters:
!
!    Input, real ( kind = 8 ) TAU(N), the data point abscissas.The entries in
!    TAU should be strictly increasing.
!
!    Input, integer ( kind = 8 ) TAU_der(M), the node index to evaluate the derivative.
!    Input, real ( kind = 8 ) GTAU(N), the data ordinates.
!    Input, real ( kind = 8 ) GTAU_der(M), the data ordinates.
!    Input, real ( kind = 8 ) T(N+K+M), the knot sequence.
!    Input, integer ( kind = 4 ) N, the number of data points for the interpolation.
!    Input, integer ( kind = 4 ) M, the number of data points for the derivative.
!    Input, integer ( kind = 4 ) K, the order of the spline.
!
!    Output, real ( kind = 8 ) Q((2*K-1)*(N+M)), the triangular factorization
!    of the coefficient matrix of the linear system for the B-coefficients 
!    of the spline interpolant.  The B-coefficients for the interpolant 
!    of an additional data set can be obtained without going through all 
!    the calculations in this routine, simply by loading HTAU into BCOEF 
!    and then executing the call:
!      call banslv ( q, 2*k-1, n+m, k-1, k-1, bcoef )
!
!    Output, real ( kind = 8 ) BCOEF(N+M), the B-spline coefficients of 
!    the interpolant.
!
!    Output, integer ( kind = 4 ) IFLAG, error flag.
!    1, = success.
!    2, = failure.
!

subroutine splint_der(tau,gtau,tau_der,gtau_der,t,n,m,k,bcoef_spline)
    
  sll_real64, intent(in)     :: tau(:)
  sll_real64, intent(in)     :: gtau(:)
  sll_int32,  intent(in)     :: tau_der(:)
  sll_real64, intent(in)     :: gtau_der(:) 
  sll_real64, intent(in)     :: t(:)
  sll_int32,  intent(in)     :: n
  sll_int32,  intent(in)     :: m
  sll_int32,  intent(in)     :: k
  sll_real64, intent(inout)  :: bcoef_spline(n+m) 

  sll_real64, dimension(n+m)           :: bcoef
  sll_int32                            :: i
  sll_int32                            :: mflag
  sll_int32                            :: j
  sll_int32                            :: l
  sll_int32                            :: jj
  sll_int32                            :: kpkm2
  sll_int32                            :: left
  sll_real64, dimension((2*k-1)*(n+m)) :: q
  sll_real64                           :: taui
  sll_real64                           :: taui_der
  sll_real64, dimension(k,k)           :: a
  sll_real64, dimension(k,2)           :: bcoef_der
  sll_int32                            :: iflag
  
  kpkm2              = 2*(k-1)
  left               = k
  q(1:(2*k-1)*(n+m)) = 0.0_f64
  a(1:k,1:k)         = 0.0_f64
  bcoef_der(1:k,1:2) = 0.0_f64

  ! we must suppose that m is <= than n 
  SLL_ASSERT(m <= n)

  l = 1 ! index for the derivative
  !
  !  Loop over I to construct the N interpolation equations.
  !
  do i = 1, n-1
       
    taui = tau(i)
       
    !
    !  Find LEFT in the closed interval (I,I+K-1) such that
    !
    !    T(LEFT) <= TAU(I) < T(LEFT+1)
    !
    !  The matrix is singular if this is not possible.
    !  With help of the Schoenberg-Whitney theorem 
    !  we can prove that if the diagonal of the 
    !  matrix B_j(x_i) is null, we have a non-inversible matrix.  

    call interv( t, n+m+k, taui, left, mflag )

    !
    !  The I-th equation enforces interpolation at TAUI, hence for all J,
    !
    !    A(I,J) = B(J,K,T)(TAUI).
    !
    !Only the K entries with J = LEFT-K+1,...,LEFT actually might be nonzero.
    !
    !These K numbers are returned, in BCOEF 
    ! (used for temporary storage here),
    !  by the following.
    !
      
    call bsplvb ( t, k, 1, taui, left, bcoef )
       
    !
    !  We therefore want BCOEF(J) = B(LEFT-K+J)(TAUI) to go into
    !  A(I,LEFT-K+J), that is, into Q(I-(LEFT+J)+2*K,(LEFT+J)-K) since
    !  A(I+J,J) is to go into Q(I+K,J), for all I, J, if we consider Q
    !  as a two-dimensional array, with  2*K-1 rows.  See comments in
    !  BANFAC.
    !
    !  In the present program, we treat Q as an equivalent
    !  one-dimensional array, because of fortran restrictions on
    !  dimension statements.
    !
    !  We therefore want  BCOEF(J) to go into the entry of Q with index:
    !
    !    I -(LEFT+J)+2*K + ((LEFT+J)-K-1)*(2*K-1)
    !    =  begin_ligne +  (begin_col -1) * number_coef_different_0
    !   = I-LEFT+1+(LEFT -K)*(2*K-1) + (2*K-2)*J
    !
    jj = i - left + 1 + ( left - k ) * ( k + k - 1 ) + l - 1
       
    do j = 1, k
      jj = jj + kpkm2  ! kpkm2 = 2*(k-1)
      q(jj) = bcoef(j)
    end do

    bcoef_spline(i+l-1) = gtau(i)

    if ( tau_der(l) == i ) then   
      taui_der = taui
          
      call bsplvd( t, k, taui_der, left, a, bcoef_der, 2)

      l = l + 1
      jj = i - left + 1 + ( left - k ) * ( k + k - 1 ) + l - 1
       
      do j = 1, k
        jj = jj + kpkm2  ! kpkm2 = 2*(k-1)
        q(jj) = bcoef_der(j,2)
      end do
      bcoef_spline(i+ l-1) = gtau_der(l-1)
    end if
       
  end do

  taui = tau(n)
  call interv( t, n+m+k, taui, left, mflag )

  if ( tau_der(l)== n ) then   
    taui_der = taui
          
    call bsplvd( t, k, taui_der, left, a, bcoef_der, 2)
          
    jj = n - left + 1 + ( left - k ) * ( k + k - 1 ) + l - 1
       
    do j = 1, k
      jj = jj + kpkm2  ! kpkm2 = 2*(k-1)
      q(jj) = bcoef_der(j,2)
    end do
    bcoef_spline(n+ l-1) = gtau_der(l)
    l = l + 1
          
  end if
       
  call bsplvb ( t, k, 1, taui, left, bcoef )
  jj = n - left + 1 + ( left - k ) * ( k + k - 1 ) + l - 1
       
  do j = 1, k
    jj = jj + kpkm2  ! kpkm2 = 2*(k-1)
    q(jj) = bcoef(j)
  end do
  bcoef_spline(n+l-1) = gtau(n)
  !
  !  Obtain factorization of A, stored again in Q.
  !
  call banfac ( q, k+k-1, n+m, k-1, k-1, iflag )
    
  if ( iflag == 2 ) then
    SLL_ERROR("SPLINT - The linear system is not invertible!")
  end if
  
  !  Solve 
  !    A * BCOEF = GTAU
  !  by back substitution.

  call banslv ( q, k+k-1, n+m, k-1, k-1, bcoef_spline )
    
end subroutine splint_der

end module sll_module_deboor_splines_1d
