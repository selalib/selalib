!**************************************************************
!  This module defines a hexagonal mesh subdivided in
!  equilateral triangles. An hexagonal mesh has the 
!  particularity of being generated by 3 non orthogonal vectors
!
!  Authors : 
!     Laura S. Mendoza (mela@ipp.mpg.de)
!     Charles Prouveur (prouveur@math.univ-lyon1.fr)
!**************************************************************


module hex_mesh
#include "sll_working_precision.h"
#include "sll_memory.h"
  implicit none

  type hex_mesh_2d
     ! A hexagonal mesh (composed by equilateral triangles)
     ! is defined by three directional vectors (r1, r2, r3)
     ! the number of cells, the radius, and the coordinates of the center  
     sll_int32  :: num_cells   ! number of cells in any direction parting from origin
     sll_int32  :: num_pts_tot ! number of total points
     sll_real64 :: radius      ! distance between origin and external vertex
     sll_real64 :: center_x1   ! x1 cartesian coordinate of the origin
     sll_real64 :: center_x2   ! x2 cartesian coordinate of the origin
     sll_real64 :: delta       ! cell spacing
     ! generator vectors' (r1, r2, r3) coordinates (they need to be scaled by delta)
     sll_real64 :: r1_x1
     sll_real64 :: r1_x2
     sll_real64 :: r2_x1
     sll_real64 :: r2_x2
     sll_real64 :: r3_x1
     sll_real64 :: r3_x2
     ! Matrix containing mesh points coordinates in cartesian coordinates :
     sll_real64, pointer, dimension(:,:) :: cartesian_coord ! (1:2,1:num_pts_tot)
     ! Matrix containing mesh points coordinates in hexagonal coordinates (integers) :
     sll_int32, pointer, dimension(:,:)  :: hex_coord ! (1:2,1:num_pts_tot)
     ! Matrix containg global indices arranged from lower corner of hexagon 
     ! and following the r2, then r1 direction
     sll_int32, pointer, dimension(:) :: global_indices ! (1:num_pts_tot)
   contains
     procedure, pass(mesh) :: x1_node => x1_node
     procedure, pass(mesh) :: x2_node => x2_node
     procedure, pass(mesh) :: hex_to_global   => hex_to_global
     procedure, pass(mesh) :: global_to_hex1  => global_to_hex1
     procedure, pass(mesh) :: global_to_hex2  => global_to_hex2
     procedure, pass(mesh) :: global_to_x1    => global_to_x1
     procedure, pass(mesh) :: global_to_x2    => global_to_x2
     procedure, pass(mesh) :: cart_to_hex1    => cart_to_hex1
     procedure, pass(mesh) :: cart_to_hex2    => cart_to_hex2
     procedure, pass(mesh) :: global_to_local => global_to_local
     procedure, pass(mesh) :: local_to_global => local_to_global
  end type hex_mesh_2d

  type hex_mesh_2d_ptr
     type(hex_mesh_2d), pointer :: hm
  end type hex_mesh_2d_ptr

  interface delete
     module procedure delete_hex_mesh_2d
  end interface delete

  interface sll_display
      module procedure display_hex_mesh_2d
  end interface sll_display

contains

! Definition of a fonction to test if an argument is present
! if it is it will asign it to the object at the slot,
! else it will take a default value
#define TEST_PRESENCE_AND_ASSIGN_VAL( obj, arg, slot, default_val ) \
  if( present(arg) ) then ; \
    obj%slot = arg; \
  else; \
    obj%slot = default_val; \
end if

  function new_hex_mesh_2d( &
    num_cells, &
    center_x1, &
    center_x2, &
    r11, &
    r12, &
    r21, &
    r22, &
    r31, &
    r32, &
    radius ) result(m)

    type(hex_mesh_2d), pointer :: m
    sll_int32, intent(in)  :: num_cells
    sll_real64, optional, intent(in) :: radius
    sll_real64, optional, intent(in) :: center_x1
    sll_real64, optional, intent(in) :: center_x2
    sll_real64, optional, intent(in) :: r11, r12
    sll_real64, optional, intent(in) :: r21, r22
    sll_real64, optional, intent(in) :: r31, r32
    sll_int32 :: ierr

    SLL_ALLOCATE(m, ierr)

    call initialize_hex_mesh_2d( &
         m, &
         num_cells, &
         radius, &
         center_x1, &
         center_x2, &
         r11, &
         r12, &
         r21, &
         r22, &
         r31, &
         r32)

  end function new_hex_mesh_2d


  subroutine initialize_hex_mesh_2d( &
    m, & 
    num_cells, &
    radius,    &
    center_x1, &
    center_x2, &
    r1_x1,     &
    r1_x2,     &
    r2_x1,     &
    r2_x2,     &
    r3_x1,     &
    r3_x2)


    type(hex_mesh_2d), pointer :: m
    sll_int32, intent(in)  :: num_cells
    sll_real64, optional, intent(in) :: radius
    sll_real64, optional, intent(in) :: center_x1
    sll_real64, optional, intent(in) :: center_x2
    sll_real64, optional, intent(in) :: r1_x1, r1_x2
    sll_real64, optional, intent(in) :: r2_x1, r2_x2
    sll_real64, optional, intent(in) :: r3_x1, r3_x2
    sll_int32  :: ierr
    sll_int32  :: i, j, global
    sll_real64 :: position_x1
    sll_real64 :: position_x2
    ! variables for optmizing computing time :
    sll_int32  :: num_cells_plus1
    sll_int32  :: num_cells_plus2


    ! By default the hexagonal mesh is centered at the (0,0) point
    TEST_PRESENCE_AND_ASSIGN_VAL( m, center_x1, center_x1, 0.0_f64 )
    TEST_PRESENCE_AND_ASSIGN_VAL( m, center_x2, center_x2, 0.0_f64 )
    ! By default the hexagonal mesh has a radius of 1.
    TEST_PRESENCE_AND_ASSIGN_VAL( m, radius, radius, 1.0_f64 )
    ! By default the hexagonal mesh has for generator vectors :
    ! r1 = (r11, r12) = ( sqrt(3)/2, 1/2 )
    ! r2 = (r21, r22) = (-sqrt(3)/2, 1/2 )
    ! r3 = (r31, r32) = ( 0, 1 )
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r1_x1, r1_x1, sqrt(real(3, f64))*0.5) 
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r1_x2, r1_x2, 0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r2_x1, r2_x1, -sqrt(real(3, f64))*0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r2_x2, r2_x2, 0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r3_x1, r3_x1, 0.0)
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r3_x2, r3_x2, 1.0)

    m%num_cells = num_cells
    m%delta = m%radius/real(num_cells,f64)
    m%num_pts_tot = 6*m%num_cells*(m%num_cells+1)/2+1

    ! resizing :
    m%r1_x1 = m%r1_x1 * m%delta
    m%r1_x2 = m%r1_x2 * m%delta
    m%r2_x1 = m%r2_x1 * m%delta
    m%r2_x2 = m%r2_x2 * m%delta
    m%r3_x1 = m%r3_x1 * m%delta
    m%r3_x2 = m%r3_x2 * m%delta

    if ( m%radius <= 0.) then
       print*,'ERROR, initialize_hex_mesh_2d(): ', &
              'Problem to construct the mesh 2d '
       print*,'because radius <= 0.'
       STOP
    end if
    if ( m%num_cells <= 0) then
       print*,'ERROR, initialize_hex_mesh_2d(): ', &
            'Problem to construct the mesh 2d '
       print*,'because num_cells <= 0.'
       STOP
    end if

    ! Allocation and initialization of coordinate matrices
    ! and conectivity matrix
    SLL_ALLOCATE(m%cartesian_coord(2, m%num_pts_tot), ierr)
    SLL_ALLOCATE(m%hex_coord(2, m%num_pts_tot), ierr)
    SLL_ALLOCATE(m%global_indices(m%num_pts_tot), ierr)
    m%cartesian_coord(:,:)   = 0._f64
    m%hex_coord(:,:)         = 0
    m%global_indices(:) = -1

    ! Initializing coordinates of first mesh point (ie. center of hexagon)
    m%cartesian_coord(1,1) = m%center_x1
    m%cartesian_coord(2,1) = m%center_x2

    ! ---------------------------------------------------------------------
    ! BEGIN MATRICES INITIALIZATION ---------------------------------------
    global = 0
    position_x1 = m%center_x1
    position_x2 = m%center_x2 ! variable containing current position
    
    num_cells_plus1 = num_cells + 1
    num_cells_plus2 = num_cells + 2
    

    do i = 1, num_cells ! variable following r1
    
       ! Incrementation on r1 direction as we are going to the next hexagon
       position_x1 = position_x1 + m%r1_x1
       position_x2 = position_x2 + m%r1_x2
       
      
       ! We follow each hexagon edge :
       ! First edge
       do j = 1, i ! following r2, the number of points on edge = i
          global = global + 1
          
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
      
          m%hex_coord(1, global) = i
          m%hex_coord(2, global) = j-1
      
          position_x1 = position_x1 + m%r2_x1
          position_x2 = position_x2 + m%r2_x2
       end do

       ! Second edge
       do j = 1, i ! following -r1
          global = global + 1
          
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2

          m%hex_coord(1, global) = i-j+1
          m%hex_coord(2, global) = i
          
          position_x1 = position_x1 - m%r1_x1
          position_x2 = position_x2 - m%r1_x2
       end do

       ! Third edge
       do j = 1, i ! following -r3
          global = global + 1
          
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          
          m%hex_coord(1, global) = -j+1
          m%hex_coord(2, global) = i-j+1
          
          position_x1 = position_x1 - m%r3_x1
          position_x2 = position_x2 - m%r3_x2
       end do

       ! Fourth edge
       do j = 1, i ! following -r2
          global = global + 1
          
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          
          m%hex_coord(1, global) = -i
          m%hex_coord(2, global) = -j+1
                    
          position_x1 = position_x1 - m%r2_x1
          position_x2 = position_x2 - m%r2_x2
       end do

       ! Fifth edge
       do j = 1, i ! following r1
          global = global + 1
          
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          
          m%hex_coord(1, global) = -i+j-1
          m%hex_coord(2, global) = -i
          
          position_x1 = position_x1 + m%r1_x1
          position_x2 = position_x2 + m%r1_x2
       end do

       ! Sixth edge
       do j = 1, i ! following r2
          global = global + 1
          
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          
          m%hex_coord(1, global) = -j-1
          m%hex_coord(2, global) = -i+j-1
                    
          position_x1 = position_x1 + m%r2_x1
          position_x2 = position_x2 + m%r2_x2
       end do
    end do

    ! Filling the global_indices matrix
    tab_index = 1
    do k1 = -m%num_cells,m%num_cells
       do k2 = -m%num_cells,m%num_cells
          ! We compute the number of cells from point to center 
          ! which is equivalent to the hexagonal ring number
          if (k1*k2 .gt. 0) then
             hex_ring_number = max(abs(k1),abs(k2))
          else
             hex_ring_number = abs(k1) + abs(k2)
          end if
          ! Test if we are in domain
          if (hex_ring_number .le. m%num_cells) then
             global_index = 
             global_indices(tab_index) = global_index
             tab_index = tab_index + 1
          end if
       end do
    end do


    ! ----------------------------------------- END MATRICES INITIALIZATION 
    ! ---------------------------------------------------------------------
          
  end subroutine initialize_hex_mesh_2d


  function x1_node(mesh, k1, k2) result(val)
    ! The coordinates (k1, k2) correspond to the (r1, r2) basis
    ! This function returns the 1st coordinate on the cartesian system
    class(hex_mesh_2d)     :: mesh
    sll_int32, intent(in)  :: k1
    sll_int32, intent(in)  :: k2
    sll_real64 :: val

    val = mesh%r1_x1*k1 + mesh%r2_x1*k2 + mesh%center_x1
  end function x1_node

  function x2_node(mesh, k1, k2) result(val)
    ! The coordinates (k1, k2) correspond to the (r1, r2) basis
    ! This function the 2nd coordinate on the cartesian system
    class(hex_mesh_2d)     :: mesh
    sll_int32, intent(in)  :: k1
    sll_int32, intent(in)  :: k2
    sll_real64  :: val

    val = mesh%r1_x2*k1 + mesh%r2_x2*k2 + mesh%center_x1
  end function x2_node


  function hex_to_global(mesh, k1, k2) result(val)
    ! Takes the coordinates (k1,k2) on the (r1,r2) basis and 
    ! returns global index of that mesh point.
    ! By default the index of the center of the mesh is 0
    ! Then following the r1 direction and a counter-clockwise motion
    ! we assing an index to every point of the mesh.
    class(hex_mesh_2d)       :: mesh
    sll_int32, intent(in)   :: k1
    sll_int32, intent(in)   :: k2
    sll_int32 :: val
    
    val = mesh%hex_to_global_mat(k1+ mesh%num_cells +1, k2 + mesh%num_cells + 1)

!     ! We compute the number of cells from point to center 
!           ! which is equivalent to the hexagonal ring number
!           if (k1*k2 .gt. 0) then
!              hex_ring_number = max(abs(k1),abs(k2))
!           else
!              hex_ring_number = abs(k1) + abs(k2)
!           end if
!           ! Test if we are in domain
!           if (hex_ring_number .le. m%num_cells) then
!              global_indices(tab_index) = (2*m%num_cells + 1)*(k1 + m%num_cells)
!              do i = -m%num_cells, k1-1
!                 global_indices(tab_index) = global_indices(tab_index) - abs(i)
!              end do
!              global_indices(tab_index) = global_indices(tab_index) + k2 + m%num_cells + 1
!              tab_index = tab_index + 1
!           end if

  end function hex_to_global


  function global_to_hex1(mesh, index) result(k1)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the first coordinate (k1) on the (r1,r2) basis 
    class(hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: k1
    
    k1 = mesh%hex_coord(1,index+1)
  end function global_to_hex1

  function global_to_hex2(mesh, index) result(k2)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the second coordinate (k2) on the (r1,r2) basis 
    class(hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: k2
    
    k2 = mesh%hex_coord(2,index+1)
  end function global_to_hex2

  function global_to_x1(mesh, index) result(x1)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the first coordinate (x1) on the cartesian basis 
    class(hex_mesh_2d) :: mesh
    sll_int32  :: index
    sll_real64 :: x1
    
    x1 = mesh%cartesian_coord(1, index+1)
  end function global_to_x1

  function global_to_x2(mesh, index) result(x2)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the second coordinate (x2) on the cartesian basis 
      class(hex_mesh_2d) :: mesh
      sll_int32  :: index
      sll_real64 :: x2

    x2 = mesh%cartesian_coord(2, index+1)
  end function global_to_x2


  function cart_to_hex1(mesh, x1, x2) result(k1)
    ! Takes the coordinates (x1,x2) on the cartesian basis and 
    ! returns the first coordinate (k1) on the (r1, r2) basis
    class(hex_mesh_2d) :: mesh
    sll_real64 :: x1
    sll_real64 :: x2
    sll_int32  :: k1
    sll_real64 :: jacob
    
    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
    k1 = floor((mesh%r2_x2 * x1 - mesh%r2_x1 * x2)/jacob)
  end function cart_to_hex1

  function cart_to_hex2(mesh, x1, x2) result(k2)
    ! Takes the coordinates (x1,x2) on the cartesian basis and 
    ! returns the second coordinate (k2) on the (r1, r2) basis
    class(hex_mesh_2d) :: mesh
    sll_real64 :: x1
    sll_real64 :: x2
    sll_int32  :: k2
    sll_real64 :: jacob
    
    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
    k2 = floor((mesh%r1_x1 * x2 - mesh%r1_x2 * x1)/jacob)
  end function cart_to_hex2

  function global_to_local(mesh, ref_index, j) result(new_index)
    ! In the same manner we assign global indices (see hex_to_global(...))
    ! we assign local indices, but this time the initial point is 
    ! the point which index is ref_index
    ! ie. local_index(i,i) = 0
    class(hex_mesh_2d) :: mesh
    sll_int32 :: ref_index, j
    sll_int32 :: k1, k2
    sll_int32 :: k1_i, k2_i
    sll_int32 :: k1_j, k2_j
    sll_int32 :: new_index
    
    k1_i = mesh%global_to_hex1(ref_index)
    k2_i = mesh%global_to_hex2(ref_index)
    k1_j = mesh%global_to_hex1(j)
    k2_j = mesh%global_to_hex2(j)

    k1 = k1_i - k1_j + mesh%num_cells + 1 
    k2 = k2_i - k2_j + mesh%num_cells + 1

    new_index = mesh%hex_to_global(k1, k2)
  end function global_to_local


  function local_to_global(mesh, ref_index, local_index) result(global)
    ! returns the global index of the point which has as
    ! local index local_index in the ref_index system
    ! (see gloval_index(...) and global_to_local(...) for conventions) 
    ! ie. local_to_global(0, i) = i
    class(hex_mesh_2d) :: mesh
    sll_int32 :: ref_index, local_index
    sll_int32 :: k1, k2
    sll_int32 :: k1_i, k2_i
    sll_int32 :: k1_j, k2_j
    sll_int32 :: global
    
    print *,"global to hex1 ", mesh%num_pts_tot
    k1_i = mesh%global_to_hex1(ref_index)
    print *, " for ref = ", k1_i
    k2_i = mesh%global_to_hex2(ref_index)
    print *, " for ref = ", k2_i
    k1_j = mesh%global_to_hex1(local_index)
    k2_j = mesh%global_to_hex2(local_index)
    print *, " for local = ", k1_j, k2_j


    k1 = k1_i + k1_j + mesh%num_cells + 1
    k2 = k2_i + k2_j + mesh%num_cells + 1
    
    global = mesh%hex_to_global(k1,k2)
  end function local_to_global

      
  subroutine display_hex_mesh_2d(mesh)
    ! Displays mesh information on the terminal
    type(hex_mesh_2d), pointer :: mesh

    write(*,"(/,(a))") '2D mesh : num_cells   num_pts        center_x1       center_x2 &
     &       radius'
    write(*,"(10x,2(i4,10x),3(g13.3,1x))") mesh%num_cells,  &
                                         mesh%num_pts_tot,&
                                         mesh%center_x1,  &
                                         mesh%center_x2,  &
                                         mesh%radius
  end subroutine display_hex_mesh_2d


  subroutine write_hex_mesh_2d(mesh, name)
    ! Writes the mesh information in a file named "name"
    type(hex_mesh_2d), pointer :: mesh
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: num_pts_tot
    sll_int32  :: k1, k2
    sll_int32, parameter :: out_unit=20

    open (unit=out_unit,file=name,action="write",status="replace")

    num_pts_tot = mesh%num_pts_tot

    ! Optional writing every mesh point and its cartesian coordinates :
!    write(*,"(/,(a))") 'hex mesh : num_pnt    x1     x2'

    do i=0, num_pts_tot-1
       k1 = mesh%global_to_hex1(i)
       k2 = mesh%global_to_hex2(i)
       write (out_unit, "(2(i2,1x),2(g13.3,1x))") i,                &
                                           k1,                      &
                                           k2,                      &
                                           mesh%global_to_x1(i), &
                                           mesh%global_to_x2(i)
    end do

    close(out_unit)
  end subroutine write_hex_mesh_2d

  subroutine write_field_hex_mesh(mesh, field, name)
    ! Writes the points cartesian coordinates and
    ! field(vector) values in a file named "name"
    type(hex_mesh_2d), pointer :: mesh
    sll_real64,dimension(:) :: field
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: num_pts_tot
    sll_real64 :: x1, x2
    sll_int32, parameter :: out_unit=20

    open (unit=out_unit,file=name,action="write",status="replace")

    num_pts_tot = mesh%num_pts_tot
    do i=0, num_pts_tot-1
       x1 = mesh%global_to_x1(i)
       x2 = mesh%global_to_x2(i)
      write (out_unit, "(3(g13.3,1x))") x1, &
                                        x2, &
                                        field(i+1)
    end do

    close(out_unit)
  end subroutine write_field_hex_mesh


  subroutine delete_hex_mesh_2d( mesh )
    type(hex_mesh_2d), pointer :: mesh
    sll_int32 :: ierr

    if(.not. associated(mesh))then
       print *, 'delete_hex_mesh_2d'
       print *, 'ERROR: passed argument is not associated'
       print *, '       Crash imminent...'
       STOP
    end if


    SLL_DEALLOCATE(mesh%cartesian_coord, ierr)
    SLL_DEALLOCATE(mesh%hex_coord, ierr)
    SLL_DEALLOCATE(mesh%hex_to_global_mat, ierr)
    SLL_DEALLOCATE(mesh, ierr)
  end subroutine delete_hex_mesh_2d

  
#undef TEST_PRESENCE_AND_ASSIGN_VAL

end module hex_mesh
