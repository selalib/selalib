!**************************************************************
!  This module defines a hexagonal mesh subdivided in
!  equilateral triangles. An hexagonal mesh has the 
!  particularity of being generated by 3 non orthogonal vectors
!
!  Authors : 
!     Laura S. Mendoza (mela@ipp.mpg.de)
!     Charles Prouveur (prouveur@math.univ-lyon1.fr)
!**************************************************************


module hex_mesh
#include "sll_working_precision.h"
#include "sll_memory.h"
  implicit none

  type hex_mesh_2d
     ! A hexagonal mesh (composed by equilateral triangles)
     ! is defined by three directional vectors (r1, r2, r3)
     ! the number of cells, the radius, and the coordinates of the center  
     sll_int32  :: num_cells   ! number of cells in any direction parting from origin
     sll_int32  :: num_pts_tot ! number of total points
     sll_real64 :: radius      ! distance between origin and external vertex
     sll_real64 :: center_x1   ! x1 cartesian coordinate of the origin
     sll_real64 :: center_x2   ! x2 cartesian coordinate of the origin
     sll_real64 :: delta       ! cell spacing
     ! generator vectors' (r1, r2, r3) coordinates (they need to be scaled by delta)
     sll_real64 :: r1_x1
     sll_real64 :: r1_x2
     sll_real64 :: r2_x1
     sll_real64 :: r2_x2
     sll_real64 :: r3_x1
     sll_real64 :: r3_x2
     ! Matrix containing mesh points coordinates in cartesian coordinates :
     sll_real64, pointer, dimension(:,:) :: cartesian_coord ! (1:2,1:num_pts_tot)
     ! Matrix containing mesh points coordinates in hexagonal coordinates (integers) :
     sll_int32, pointer, dimension(:,:)  :: hex_coord ! (1:2,1:num_pts_tot)
     ! Matrix containg global indices from hexagonal coordinates
     sll_int32, pointer, dimension(:,:) :: hex_to_global ! (1:2*num_cells+1,1:2*num_cells+1)
   contains
     procedure, pass(mesh) :: get_hex_num => get_hex_num
     procedure, pass(mesh) :: global_index => global_index
     procedure, pass(mesh) :: from_global_index_k1 => from_global_index_k1
     procedure, pass(mesh) :: from_global_index_k2 => from_global_index_k2
     procedure, pass(mesh) :: from_global_x1 => from_global_x1
     procedure, pass(mesh) :: from_global_x2 => from_global_x2
     procedure, pass(mesh) :: from_cart_index_k1 => from_cart_index_k1
     procedure, pass(mesh) :: from_cart_index_k2 => from_cart_index_k2
     procedure, pass(mesh) :: global_to_local => global_to_local
     procedure, pass(mesh) :: local_to_global => local_to_global
  end type hex_mesh_2d

  type hex_mesh_2d_ptr
     type(hex_mesh_2d), pointer :: hm
  end type hex_mesh_2d_ptr

  interface delete
     module procedure delete_hex_mesh_2d
  end interface delete

  interface sll_display
      module procedure display_hex_mesh_2d
  end interface sll_display

contains

! Definition of a fonction to test if an argument is present
! if it is it will asign it to the object at the slot,
! else it will take a default value
#define TEST_PRESENCE_AND_ASSIGN_VAL( obj, arg, slot, default_val ) \
  if( present(arg) ) then ; \
    obj%slot = arg; \
  else; \
    obj%slot = default_val; \
end if

  function new_hex_mesh_2d( &
    num_cells, &
    center_x1, &
    center_x2, &
    r11, &
    r12, &
    r21, &
    r22, &
    r31, &
    r32, &
    radius ) result(m)

    type(hex_mesh_2d), pointer :: m
    sll_int32, intent(in)  :: num_cells
    sll_real64, optional, intent(in) :: radius
    sll_real64, optional, intent(in) :: center_x1
    sll_real64, optional, intent(in) :: center_x2
    sll_real64, optional, intent(in) :: r11, r12
    sll_real64, optional, intent(in) :: r21, r22
    sll_real64, optional, intent(in) :: r31, r32
    sll_int32 :: ierr

    SLL_ALLOCATE(m, ierr)
    call initialize_hex_mesh_2d( &
         m, &
         num_cells, &
         radius, &
         center_x1, &
         center_x2, &
         r11, &
         r12, &
         r21, &
         r22, &
         r31, &
         r32)

  end function new_hex_mesh_2d


  subroutine initialize_hex_mesh_2d( &
    m, & 
    num_cells, &
    radius,    &
    center_x1, &
    center_x2, &
    r1_x1,     &
    r1_x2,     &
    r2_x1,     &
    r2_x2,     &
    r3_x1,     &
    r3_x2)


    type(hex_mesh_2d), pointer :: m
    sll_int32, intent(in)  :: num_cells
    sll_real64, optional, intent(in) :: radius
    sll_real64, optional, intent(in) :: center_x1
    sll_real64, optional, intent(in) :: center_x2
    sll_real64, optional, intent(in) :: r1_x1, r1_x2
    sll_real64, optional, intent(in) :: r2_x1, r2_x2
    sll_real64, optional, intent(in) :: r3_x1, r3_x2
    sll_int32  :: ierr
    sll_int32  :: i, j, global
    sll_real64 :: position_x1
    sll_real64 :: position_x2
    ! variables for optmizing computing time :
    sll_int32  :: num_cells_plus1
    sll_int32  :: num_cells_plus2


    ! By default the hexagonal mesh is centered at the (0,0) point
    TEST_PRESENCE_AND_ASSIGN_VAL( m, center_x1, center_x1, 0.0_f64 )
    TEST_PRESENCE_AND_ASSIGN_VAL( m, center_x2, center_x2, 0.0_f64 )
    ! By default the hexagonal mesh has a radius of 1.
    TEST_PRESENCE_AND_ASSIGN_VAL( m, radius, radius, 1.0_f64 )
    ! By default the hexagonal mesh has for generator vectors :
    ! r1 = (r11, r12) = ( sqrt(3)/2, 1/2 )
    ! r2 = (r21, r22) = (-sqrt(3)/2, 1/2 )
    ! r3 = (r31, r32) = ( 0, 1 )
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r1_x1, r1_x1, sqrt(real(3, f64))*0.5) 
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r1_x2, r1_x2, 0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r2_x1, r2_x1, -sqrt(real(3, f64))*0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r2_x2, r2_x2, 0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r3_x1, r3_x1, 0.0)
    TEST_PRESENCE_AND_ASSIGN_VAL( m, r3_x2, r3_x2, 1.0)

    m%num_cells = num_cells
    m%delta = m%radius/real(num_cells,f64)
    m%num_pts_tot = 6*m%num_cells*(m%num_cells+1)/2+1

    ! resizing :
    m%r1_x1 = m%r1_x1 * m%delta
    m%r1_x2 = m%r1_x2 * m%delta
    m%r2_x1 = m%r2_x1 * m%delta
    m%r2_x2 = m%r2_x2 * m%delta
    m%r3_x1 = m%r3_x1 * m%delta
    m%r3_x2 = m%r3_x2 * m%delta

    if ( m%radius <= 0.) then
       print*,'ERROR, initialize_hex_mesh_2d(): ', &
              'Problem to construct the mesh 2d '
       print*,'because radius <= 0.'
       STOP
    end if
    if ( m%num_cells <= 0) then
       print*,'ERROR, initialize_hex_mesh_2d(): ', &
            'Problem to construct the mesh 2d '
       print*,'because num_cells <= 0.'
       STOP
    end if

    ! Allocation and initialization of coordinate matrices
    ! and conectivity matrix
    SLL_ALLOCATE(m%cartesian_coord(2, m%num_pts_tot), ierr)
    SLL_ALLOCATE(m%hex_coord(2, m%num_pts_tot), ierr)
    SLL_ALLOCATE(m%hex_to_global(num_cells*2 + 1, num_cells*2 + 1), ierr)
    m%cartesian_coord(:,:) = 0._f64
    m%hex_coord(:,:)       = 0
    m%hex_to_global(:,:)   = -1

    ! Initializing coordinates of first mesh point
    m%cartesian_coord(1,1) = m%center_x1
    m%cartesian_coord(2,1) = m%center_x2

    ! ---------------------------------------------------------------------
    ! BEGIN MATRICES INITIALIZATION ---------------------------------------

    global = 1
    position_x1 = m%center_x1
    position_x2 = m%center_x2 ! variable containing current position
    
    num_cells_plus1 = num_cells + 1
    num_cells_plus2 = num_cells + 2

    do i = 1, num_cells ! variable following r1
       ! Incrementation on r1 direction as we are going to the next hexagon
       position_x1 = position_x1 + r1_x1
       position_x2 = position_x2 + r1_x2
       
       ! We follow each hexagon edge :
       ! First edge
       do j = 1, i ! following r2, the number of points on edge = i
          global = global + 1
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          m%hex_coord(1, global) = i
          m%hex_coord(2, global) = j-1
          m%hex_to_global(num_cells_plus1 + i, num_cells + j) = global
          
          position_x1 = position_x1 + r2_x1
          position_x2 = position_x2 + r2_x2
       end do

       ! Second edge
       do j = 1, i ! following -r1
          global = global + 1
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          m%hex_coord(1, global) = i-j+1
          m%hex_coord(2, global) = i
          m%hex_to_global(num_cells_plus2 + i - j, num_cells_plus1 + i) = global
          
          position_x1 = position_x1 - r1_x1
          position_x2 = position_x2 - r1_x2
       end do

       ! Third edge
       do j = 1, i ! following -r3
          global = global + 1
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          m%hex_coord(1, global) = -j+1
          m%hex_coord(2, global) = i-j+1
          m%hex_to_global(num_cells_plus2 - j, num_cells_plus2 + i - j) = global
          
          position_x1 = position_x1 - r3_x1
          position_x2 = position_x2 - r3_x2
       end do

       ! Fourth edge
       do j = 1, i ! following -r2
          global = global + 1
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          m%hex_coord(1, global) = -i
          m%hex_coord(2, global) = -j+1
          m%hex_to_global(num_cells_plus1 - i, num_cells_plus2 - j) = global
          
          position_x1 = position_x1 - r2_x1
          position_x2 = position_x2 - r2_x2
       end do

       ! Fifth edge
       do j = 1, i ! following r1
          global = global + 1
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          m%hex_coord(1, global) = -i+j-1
          m%hex_coord(2, global) = -i
          m%hex_to_global(num_cells + i - j, num_cells_plus1 - i) = global
          
          position_x1 = position_x1 + r1_x1
          position_x2 = position_x2 + r1_x2
       end do

       ! Sixth edge
       do j = 1, i ! following r2
          global = global + 1
          m%cartesian_coord(1, global) = position_x1
          m%cartesian_coord(2, global) = position_x2
          m%hex_coord(1, global) = -j-1
          m%hex_coord(2, global) = -i+j-1
          m%hex_to_global(num_cells - j, num_cells - i + j) = global
          
          position_x1 = position_x1 + r2_x1
          position_x2 = position_x2 + r2_x2
       end do
    end do

    ! ----------------------------------------- END MATRICES INITIALIZATION 
    ! ---------------------------------------------------------------------
          
  end subroutine initialize_hex_mesh_2d


  function x1_node(mesh, k1, k2) result(val)
    ! The coordinates (k1, k2) correspond to the (r1, r2) basis
    ! This function returns the 1st coordinate on the cartesian system
    type(hex_mesh_2d), pointer :: mesh
    sll_int32, intent(in)  :: k1
    sll_int32, intent(in)  :: k2
    sll_real64 :: val

    val = mesh%r1_x1*k1 + mesh%r2_x1*k2 + mesh%center_x1
  end function x1_node

  function x2_node(mesh, k1, k2) result(val)
    ! The coordinates (k1, k2) correspond to the (r1, r2) basis
    ! This function the 2nd coordinate on the cartesian system
    type(hex_mesh_2d), pointer :: mesh
    sll_int32, intent(in)  :: k1
    sll_int32, intent(in)  :: k2
    sll_real64  :: val

    val = mesh%r1_x2*k1 + mesh%r2_x2*k2 + mesh%center_x1
  end function x2_node

  function global_index(mesh, k1, k2) result(val)
    ! Takes the coordinates (k1,k2) on the (r1,r2) basis and 
    ! returns global index of that mesh point.
    ! By default the index of the center of the mesh is 0
    ! Then following the r1 direction and a counter-clockwise motion
    ! we assing an index to every point of the mesh.
    class(hex_mesh_2d)       :: mesh
    sll_int32, intent(in)   :: k1
    sll_int32, intent(in)   :: k2
    sll_int32 :: val
    
    val = mesh%hex_to_global(k1+ mesh%num_cells +1, k2 + mesh%num_cells + 1)
  end function global_index


  function get_hex_num(mesh, index) result(hex_num)
    ! returns the number of nested hexagon on which the point is
    ! <=> returns the number of cells from center to point
    ! Warning : even if the index is beyond the mesh 
    ! this function will return a result
    class(hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: hex_num
    sll_int32 :: flag
    
    hex_num = 0
    flag = 0

    if (index .lt. 0) then
       print *, "ERROR : in get_hex_num(index)"
       print *, "Global index cannot be negative"
       STOP 'get_hex_num'         
    else if (index .eq. 0) then
       hex_num = 0
!     else if (index .le. num_pts_tot) then
!        hex_num =
    else
       hex_num = 1
       do while(flag .eq. 0)
          if (index .gt. 3*hex_num*(hex_num+1)) then
             hex_num = hex_num + 1
          else
             flag = 1
          endif
       enddo
    endif
  end function get_hex_num


  function from_global_index_k1(mesh, index) result(k1)
    ! Takes the global index of the point (see global_index(...) for conventions)
    ! returns the first coordinate (k1) on the (r1,r2) basis 
    class(hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: k1
    
    k1 = mesh%hex_coord(1,index)
  end function from_global_index_k1

  
  function from_global_index_k2(mesh, index) result(k2)
    ! Takes the global index of the point (see global_index(...) for conventions)
    ! returns the second coordinate (k2) on the (r1,r2) basis 
    class(hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: k2
    
    k2 = mesh%hex_coord(2,index)
  end function from_global_index_k2

  function from_global_x1(mesh, index) result(x1)
    ! Takes the global index of the point (see global_index(...) for conventions)
    ! returns the first coordinate (x1) on the cartesian basis 
    class(hex_mesh_2d) :: mesh
    sll_int32  :: index
    sll_real64 :: x1
    
    x1 = mesh%cartesian_coord(1, index)
  end function from_global_x1

  function from_global_x2(mesh, index) result(x2)
    ! Takes the global index of the point (see global_index(...) for conventions)
    ! returns the second coordinate (x2) on the cartesian basis 
      class(hex_mesh_2d) :: mesh
      sll_int32  :: index
      sll_real64 :: x2

    x2 = mesh%cartesian_coord(2, index)
  end function from_global_x2


  function from_cart_index_k1(mesh, x1, x2) result(k1)
    ! Takes the coordinates (x1,x2) on the cartesian basis and 
    ! returns the first coordinate (k1) on the (r1, r2) basis
    class(hex_mesh_2d) :: mesh
    sll_real64 :: x1
    sll_real64 :: x2
    sll_int32  :: k1
    sll_real64 :: jacob
    
    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
    k1 = floor((mesh%r2_x2 * x1 - mesh%r2_x1 * x2)/jacob)
  end function from_cart_index_k1

  function from_cart_index_k2(mesh, x1, x2) result(k2)
    ! Takes the coordinates (x1,x2) on the cartesian basis and 
    ! returns the second coordinate (k2) on the (r1, r2) basis
    class(hex_mesh_2d) :: mesh
    sll_real64 :: x1
    sll_real64 :: x2
    sll_int32  :: k2
    sll_real64 :: jacob
    
    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
    k2 = floor((mesh%r1_x1 * x2 - mesh%r1_x2 * x1)/jacob)
  end function from_cart_index_k2

  function global_to_local(mesh, ref_index,j) result(new_index)
    ! In the same manner we assign global indices (see global_index(...))
    ! we assign local indices, but this time the initial point is 
    ! the point which index is ref_index
    ! ie. local_index(i,i) = 0
    class(hex_mesh_2d) :: mesh
    sll_int32 :: ref_index, j
    sll_int32 :: k1_i, k2_i
    sll_int32 :: k1_j, k2_j
    sll_int32 :: new_index
    
    k1_i = mesh%from_global_index_k1(ref_index)
    k2_i = mesh%from_global_index_k2(ref_index)
    k1_j = mesh%from_global_index_k1(j)
    k2_j = mesh%from_global_index_k2(j)
    
    new_index = mesh%global_index(k1_i - k1_j, k2_i - k2_j)
  end function global_to_local


  function local_to_global(mesh, ref_index, local_index) result(global)
    ! returns the global index of the point which has as
    ! local index local_index in the ref_index system
    ! (see gloval_index(...) and global_to_local(...) for conventions) 
    ! ie. local_to_global(0, i) = i
    class(hex_mesh_2d) :: mesh
    sll_int32 :: ref_index, local_index
    sll_int32 :: k1_i, k2_i
    sll_int32 :: k1_j, k2_j
    sll_int32 :: global
    
    k1_i = mesh%from_global_index_k1(ref_index)
    k2_i = mesh%from_global_index_k2(ref_index)
    k1_j = mesh%from_global_index_k1(local_index)
    k2_j = mesh%from_global_index_k2(local_index)
    
    global = mesh%global_index(k1_i + k1_j, k2_i + k2_j)
  end function local_to_global

      
  subroutine display_hex_mesh_2d(mesh)
    ! Displays mesh information on the terminal
    type(hex_mesh_2d), pointer :: mesh

    write(*,"(/,(a))") '2D mesh : num_cells   num_pts        center_x1       center_x2 &
     &       radius'
    write(*,"(10x,2(i4,10x),3(g13.3,1x))") mesh%num_cells,  &
                                         mesh%num_pts_tot,&
                                         mesh%center_x1,  &
                                         mesh%center_x2,  &
                                         mesh%radius
  end subroutine display_hex_mesh_2d


  subroutine write_hex_mesh_2d(mesh, name)
    ! Writes the mesh information in a file named "name"
    type(hex_mesh_2d), pointer :: mesh
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: hex_num
    sll_int32  :: num_pts_tot
    sll_int32  :: k1, k2
    sll_int32, parameter :: out_unit=20

    open (unit=out_unit,file=name,action="write",status="replace")

    num_pts_tot = mesh%num_pts_tot

    ! Optional writing every mesh point and its cartesian coordinates :
!    write(*,"(/,(a))") 'hex mesh : num_pnt    x1     x2'

    do i=0, num_pts_tot-1
       hex_num = mesh%get_hex_num(i)
       k1 = mesh%from_global_index_k1(i)
       k2 = mesh%from_global_index_k2(i)
       write (out_unit, "(4(i2,1x),2(g13.3,1x))") i,                &
                                           hex_num,                 &
                                           k1,                      &
                                           k2,                      &
                                           mesh%from_global_x1(i), &
                                           mesh%from_global_x2(i)
    end do

    close(out_unit)
  end subroutine write_hex_mesh_2d

  subroutine write_field_hex_mesh(mesh, field, name)
    ! Writes the points cartesian coordinates and
    ! field(vector) values in a file named "name"
    type(hex_mesh_2d), pointer :: mesh
    sll_real64,dimension(:) :: field
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: num_pts_tot
    sll_real64 :: x1, x2
    sll_int32, parameter :: out_unit=20

    open (unit=out_unit,file=name,action="write",status="replace")

    num_pts_tot = mesh%num_pts_tot
    do i=0, num_pts_tot-1
       x1 = mesh%from_global_x1(i)
       x2 = mesh%from_global_x2(i)
      write (out_unit, "(3(g13.3,1x))") x1, &
                                        x2, &
                                        field(i+1)
    end do

    close(out_unit)
  end subroutine write_field_hex_mesh


  subroutine delete_hex_mesh_2d( mesh )
    type(hex_mesh_2d), pointer :: mesh
    sll_int32 :: ierr
    if(.not. associated(mesh))then
       print *, 'delete_hex_mesh_2d'
       print *, 'ERROR: passed argument is not associated'
       print *, '       Crash imminent...'
       STOP
    end if
    SLL_DEALLOCATE(mesh, ierr)
  end subroutine delete_hex_mesh_2d

  
#undef TEST_PRESENCE_AND_ASSIGN_VAL

end module hex_mesh
