!**************************************************************
!  This module defines a hexagonal mesh subdivided in
!  equilateral triangles. An hexagonal mesh has the 
!  particularity of being generated by 3 non orthogonal vectors
!
!  Authors : 
!     Laura S. Mendoza (mela@ipp.mpg.de)
!     Charles Prouveur (prouveur@math.univ-lyon1.fr)
!**************************************************************


module hex_mesh
#include "sll_working_precision.h"
#include "sll_memory.h"
  implicit none

  type hex_mesh_2d
     ! A hexagonal mesh (composed by equilateral triangles)
     ! is defined by three directional vectors (r1, r2, r3)
     ! the number of cells, the radius, and the coordinates of the center  
     sll_int32  :: num_cells     ! number of cells in any direction parting from origin
     sll_int32  :: num_pts_tot   ! number of total points
     sll_int32  :: num_triangles ! number of triangles
     sll_real64 :: radius        ! distance between origin and external vertex
     sll_real64 :: center_x1     ! x1 cartesian coordinate of the origin
     sll_real64 :: center_x2     ! x2 cartesian coordinate of the origin
     sll_real64 :: delta         ! cell spacing
     ! generator vectors' (r1, r2, r3) coordinates (they need to be scaled by delta)
     sll_real64 :: r1_x1
     sll_real64 :: r1_x2
     sll_real64 :: r2_x1
     sll_real64 :: r2_x2
     sll_real64 :: r3_x1
     sll_real64 :: r3_x2
     ! Matrix containing mesh points coordinates in cartesian coordinates :
     sll_real64, pointer, dimension(:,:) :: cartesian_coord ! (1:2,1:num_pts_tot)
     ! matrix containing the cartesian coordinates of the centers of tthe triangles
     sll_real64, pointer, dimension(:,:) :: center_cartesian_coord ! (1:2,1:num_triangles)     
     ! matrix containing the index of the respective center of the 2 triangles at the top of most points
     sll_int32, pointer, dimension(:,:) :: center_index! (1:2,1:num_pts_tot)
     ! Matrix containing mesh points coordinates in hexagonal coordinates (integers) :
     sll_int32, pointer, dimension(:,:)  :: hex_coord ! (1:2,1:num_pts_tot)
     ! Matrix containg global indices arranged from lower corner of hexagon 
     ! and following the r2, then r1 direction
     sll_int32, pointer, dimension(:) :: global_indices ! (1:num_pts_tot)
   contains
     procedure, pass(mesh) :: x1_node => x1_node
     procedure, pass(mesh) :: x2_node => x2_node
     procedure, pass(mesh) :: index_hex_to_global => index_hex_to_global
     procedure, pass(mesh) :: hex_to_global   => hex_to_global
     procedure, pass(mesh) :: global_to_hex1  => global_to_hex1
     procedure, pass(mesh) :: global_to_hex2  => global_to_hex2
     procedure, pass(mesh) :: global_to_x1    => global_to_x1
     procedure, pass(mesh) :: global_to_x2    => global_to_x2
     procedure, pass(mesh) :: cart_to_hex1    => cart_to_hex1
     procedure, pass(mesh) :: cart_to_hex2    => cart_to_hex2
     procedure, pass(mesh) :: global_to_local => global_to_local
     procedure, pass(mesh) :: local_to_global => local_to_global
  end type hex_mesh_2d

  type hex_mesh_2d_ptr
     type(hex_mesh_2d), pointer :: hm
  end type hex_mesh_2d_ptr

  interface delete
     module procedure delete_hex_mesh_2d
  end interface delete

  interface sll_display
     module procedure display_hex_mesh_2d
  end interface sll_display

contains

  ! Definition of a fonction to test if an argument is present
  ! if it is it will asign it to the object at the slot,
  ! else it will take a default value
#define TEST_PRESENCE_AND_ASSIGN_VAL( obj, arg, slot, default_val ) \
  if( present(arg) ) then ; \
     obj%slot = arg; \
  else; \
     obj%slot = default_val; \
  end if

  function new_hex_mesh_2d( &
       num_cells, &
       center_x1, &
       center_x2, &
       r11, &
       r12, &
       r21, &
       r22, &
       r31, &
       r32, &
       radius) result(mesh)

    type(hex_mesh_2d), pointer :: mesh
    sll_int32, intent(in)  :: num_cells
    sll_real64, optional, intent(in) :: radius
    sll_real64, optional, intent(in) :: center_x1
    sll_real64, optional, intent(in) :: center_x2
    sll_real64, optional, intent(in) :: r11, r12
    sll_real64, optional, intent(in) :: r21, r22
    sll_real64, optional, intent(in) :: r31, r32
    sll_int32 :: ierr

    SLL_ALLOCATE(mesh, ierr)

    call initialize_hex_mesh_2d( &
         mesh, &
         num_cells, &
         radius, &
         center_x1, &
         center_x2, &
         r11, &
         r12, &
         r21, &
         r22, &
         r31, &
         r32)

  end function new_hex_mesh_2d


  subroutine initialize_hex_mesh_2d( &
       mesh, & 
       num_cells, &
       radius,    &
       center_x1, &
       center_x2, &
       r1_x1,     &
       r1_x2,     &
       r2_x1,     &
       r2_x2,     &
       r3_x1,     &
       r3_x2)


    type(hex_mesh_2d), pointer :: mesh
    sll_int32, intent(in)  :: num_cells
    sll_real64, optional, intent(in) :: radius
    sll_real64, optional, intent(in) :: center_x1
    sll_real64, optional, intent(in) :: center_x2
    sll_real64, optional, intent(in) :: r1_x1, r1_x2
    sll_real64, optional, intent(in) :: r2_x1, r2_x2
    sll_real64, optional, intent(in) :: r3_x1, r3_x2
    sll_int32  :: ierr
    sll_int32  :: i, j, global
    sll_real64 :: position_x1
    sll_real64 :: position_x2
    sll_int32  :: k1, k2
    sll_int32  :: index_tab
    ! variables for optmizing computing time :
    sll_int32  :: num_cells_plus1
    sll_int32  :: num_cells_plus2

    sll_int32  :: center_index
    sll_real64 :: x1, x2, x3, y1, y2, y3, xx, yy, r1x1
    sll_real64 :: jacob, k1c, k2c
    logical    :: inside


    ! By default the hexagonal mesh is centered at the (0,0) point
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, center_x1, center_x1, 0.0_f64 )
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, center_x2, center_x2, 0.0_f64 )
    ! By default the hexagonal mesh has a radius of 1.
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, radius, radius, 1.0_f64 )
    ! By default the hexagonal mesh has for generator vectors :
    ! r1 = (r11, r12) = ( sqrt(3)/2, 1/2 )
    ! r2 = (r21, r22) = (-sqrt(3)/2, 1/2 )
    ! r3 = (r31, r32) = ( 0, 1 )
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, r1_x1, r1_x1, sqrt(real(3, f64))*0.5) 
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, r1_x2, r1_x2, 0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, r2_x1, r2_x1, -sqrt(real(3, f64))*0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, r2_x2, r2_x2, 0.5)
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, r3_x1, r3_x1, 0.0)
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, r3_x2, r3_x2, 1.0)

    mesh%num_cells = num_cells
    mesh%delta = mesh%radius/real(num_cells,f64)
    ! The formula is = 6*sum(num_cells)+1 which simplifies to :
    mesh%num_pts_tot = 3 * mesh%num_cells * (mesh%num_cells + 1) + 1
    mesh%num_triangles = 6 * num_cells * num_cells

    ! resizing :
    mesh%r1_x1 = mesh%r1_x1 * mesh%delta
    mesh%r1_x2 = mesh%r1_x2 * mesh%delta
    mesh%r2_x1 = mesh%r2_x1 * mesh%delta
    mesh%r2_x2 = mesh%r2_x2 * mesh%delta
    mesh%r3_x1 = mesh%r3_x1 * mesh%delta
    mesh%r3_x2 = mesh%r3_x2 * mesh%delta

    if ( mesh%radius <= 0.) then
       print*,'ERROR, initialize_hex_mesh_2d(): ', &
            'Problem to construct the mesh 2d '
       print*,'because radius <= 0.'
       STOP
    end if
    if ( mesh%num_cells <= 0) then
       print*,'ERROR, initialize_hex_mesh_2d(): ', &
            'Problem to construct the mesh 2d '
       print*,'because num_cells <= 0.'
       STOP
    end if

    ! Allocation and initialization of coordinate matrices
    ! and conectivity matrix
    SLL_ALLOCATE(mesh%cartesian_coord(2, mesh%num_pts_tot), ierr)
    SLL_ALLOCATE(mesh%hex_coord(2, mesh%num_pts_tot), ierr)
    SLL_ALLOCATE(mesh%global_indices(mesh%num_pts_tot), ierr)
    SLL_ALLOCATE(mesh%center_cartesian_coord(2, mesh%num_triangles), ierr)
    SLL_ALLOCATE(mesh%center_index(2, mesh%num_pts_tot), ierr)
    mesh%cartesian_coord(:,:)          = 0._f64
    mesh%center_cartesian_coord(:,:)   = 0._f64
    mesh%hex_coord(:,:)                = 0
    mesh%global_indices(:)             = -1
    mesh%center_index(:,:)             = -1
    ! Initializing coordinates of first mesh point (ie. center of hexagon)
    mesh%cartesian_coord(1,1) = mesh%center_x1
    mesh%cartesian_coord(2,1) = mesh%center_x2

    !Useful variables
    num_cells_plus1 = num_cells + 1
    num_cells_plus2 = num_cells + 2

    ! ---------------------------------------------------------------------
    ! BEGIN MATRICES INITIALIZATION ---------------------------------------

    ! Initializing coordinates of first mesh point (ie. center of hexagon)
    global = 1
    position_x1 = mesh%center_x1
    position_x2 = mesh%center_x2 ! variable containing current position
    mesh%cartesian_coord(1,global) = position_x1
    mesh%cartesian_coord(2,global) = position_x2

    do i = 1, num_cells ! variable following r1
       ! Incrementation on r1 direction as we are going to the next hexagon
       position_x1 = position_x1 + mesh%r1_x1
       position_x2 = position_x2 + mesh%r1_x2

       ! We follow each hexagon edge :
       ! First edge
       do j = 1, i ! following r2, the number of points on edge = i
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = i
          mesh%hex_coord(2, global) = j-1

          position_x1 = position_x1 + mesh%r2_x1
          position_x2 = position_x2 + mesh%r2_x2
       end do

       ! Second edge
       do j = 1, i ! following -r1
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = i-j+1
          mesh%hex_coord(2, global) = i

          position_x1 = position_x1 - mesh%r1_x1
          position_x2 = position_x2 - mesh%r1_x2
       end do

       ! Third edge
       do j = 1, i ! following -r3
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = -j+1
          mesh%hex_coord(2, global) = i-j+1

          position_x1 = position_x1 - mesh%r3_x1
          position_x2 = position_x2 - mesh%r3_x2
       end do

       ! Fourth edge
       do j = 1, i ! following -r2
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = -i
          mesh%hex_coord(2, global) = -j+1

          position_x1 = position_x1 - mesh%r2_x1
          position_x2 = position_x2 - mesh%r2_x2
       end do

       ! Fifth edge
       do j = 1, i ! following r1
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = -i+j-1
          mesh%hex_coord(2, global) = -i

          position_x1 = position_x1 + mesh%r1_x1
          position_x2 = position_x2 + mesh%r1_x2
       end do

       ! Sixth edge
       do j = 1, i ! following r3
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = j-1
          mesh%hex_coord(2, global) = -i+j-1

          position_x1 = position_x1 + mesh%r3_x1
          position_x2 = position_x2 + mesh%r3_x2
       end do
    end do

    ! Filling the global_indices table.
    do global = 1, mesh%num_pts_tot 

       k1 = mesh%hex_coord(1, global)
       k2 = mesh%hex_coord(2, global)

       ! in order to switch from hexa coordinates to the global index
       ! we need a routine that will compute a unique number index_tab
       ! from the hexa coordinates. this unique number will index the array
       ! global_indices which contains the numerotation
       
       call index_hex_to_global(mesh, k1, k2, index_tab)

       mesh%global_indices(index_tab)= global

    enddo

    center_index = 0
    r1x1 =  mesh%r1_x1*real(mesh%num_cells,f64)

    do global = 1, mesh%num_pts_tot
       ! almost each point is the base of a lozenge , thus two triangle
       ! from which we get two center points

       k1 = mesh%hex_coord(1, global)
       k2 = mesh%hex_coord(2, global)

       ! center point in the left triangle
       
       x1 = k1*mesh%r1_x1 + k2*mesh%r2_x1
       x2 = k1*mesh%r1_x1 + (k2+1)*mesh%r2_x1
       x3 = (k1+1)*mesh%r1_x1 + (k2+1)*mesh%r2_x1
       y1 = k1*mesh%r1_x2 + k2*mesh%r2_x2
       y2 = k1*mesh%r1_x2 + (k2+1)*mesh%r2_x2
       y3 = (k1+1)*mesh%r1_x2 + (k2+1)*mesh%r2_x2

       xx = x2 + ( (x3+x1)*0.5_f64 - x2 )* 2.0_f64 / 3.0_f64
       yy = y2 + ( (y3+y1)*0.5_f64 - y2 )* 2.0_f64 / 3.0_f64

       !test to check if the triangle on the left is inside
       
       inside = .true.
       
       jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
       k1c = (mesh%r2_x2 * xx - mesh%r2_x1 * yy)/jacob
       k2c = (mesh%r1_x1 * yy - mesh%r1_x2 * xx)/jacob

       if ( abs(k1c) >  mesh%num_cells ) inside = .false.
       if ( abs(k2c) >  mesh%num_cells ) inside = .false.
       if ( abs(xx) > r1x1 ) inside = .false.

       if ( inside ) then
          center_index = center_index + 1
          mesh%center_cartesian_coord(1,center_index) = xx
          mesh%center_cartesian_coord(2,center_index) = yy
          mesh%center_index(1, global) = center_index
       endif
       

       ! center point in the right triangle
       x1 = k1*mesh%r1_x1 + k2*mesh%r2_x1
       x2 = (k1+1)*mesh%r1_x1 + k2*mesh%r2_x1
       x3 = (k1+1)*mesh%r1_x1 + (k2+1)*mesh%r2_x1
       y1 = k1*mesh%r1_x2 + k2*mesh%r2_x2
       y2 = (k1+1)*mesh%r1_x2 + k2*mesh%r2_x2
       y3 = (k1+1)*mesh%r1_x2 + (k2+1)*mesh%r2_x2

       xx = x2 + ( (x3+x1)*0.5_f64 - x2 )* 2.0_f64 / 3.0_f64
       yy = y2 + ( (y3+y1)*0.5_f64 - y2 )* 2.0_f64 / 3.0_f64

       ! test to check if the triangle on the left is inside

       inside = .true.

       jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
       k1c = (mesh%r2_x2 * xx - mesh%r2_x1 * yy)/jacob
       k2c = (mesh%r1_x1 * yy - mesh%r1_x2 * xx)/jacob

       if ( abs(k1c) >  mesh%num_cells ) inside = .false.
       if ( abs(k2c) >  mesh%num_cells ) inside = .false.
       if ( abs(xx) > r1x1 ) inside = .false.

       if ( inside ) then
          center_index = center_index + 1
          mesh%center_cartesian_coord(1,center_index) = xx
          mesh%center_cartesian_coord(2,center_index) = yy
          mesh%center_index(2, global) = center_index
       endif
       
    enddo

    ! ----------------------------------------- END MATRICES INITIALIZATION 
    ! ---------------------------------------------------------------------

  end subroutine initialize_hex_mesh_2d


  subroutine index_hex_to_global(mesh, k1, k2, index_tab)

    implicit none
    class(hex_mesh_2d)     :: mesh
    sll_int32, intent(in)  :: k1, k2
    sll_int32, intent(out) :: index_tab
    sll_int32              :: k
    sll_int32              :: nk1, nk2
    sll_int32              :: n0
    sll_int32              :: num_cells
    sll_int32              :: num_cells_plus1

    num_cells = mesh%num_cells
    num_cells_plus1 = num_cells + 1

    ! nk1 is the number of points before the edge corresponding to k1
    ! nk2 is the number of points on the edge k1 :
    ! if k1<=0 the points are in [-num_cells,k2] 
    ! if k1>0  ...               [-num_cells+k1,k2]

    if (k1.le.0) then
       k   = num_cells + k1
       nk1  = floor( num_cells*k + k*(k+1)*0.5 ) !this value is always an integer, floor avoids the transformation
       nk2  = k2 + num_cells_plus1
    elseif (k1.gt.0) then 
       ! n0 is the total number of points from (-num_cells,-num_cells) to 
       ! ( 0,numcells)
       n0  = floor( num_cells**2 + num_cells*num_cells_plus1*0.5 )
       nk1 = n0 + k1*(2*num_cells + 1) - floor( k1*(k1-1)*0.5 )
       nk2 = k2 + num_cells_plus1 - k1
    endif

    index_tab = nk1 + nk2

  end subroutine index_hex_to_global


  function x1_node(mesh, k1, k2) result(val)
    ! The coordinates (k1, k2) correspond to the (r1, r2) basis
    ! This function returns the 1st coordinate on the cartesian system
    class(hex_mesh_2d)     :: mesh
    sll_int32, intent(in)  :: k1
    sll_int32, intent(in)  :: k2
    sll_real64 :: val

    val = mesh%r1_x1*k1 + mesh%r2_x1*k2 + mesh%center_x1
  end function x1_node

  function x2_node(mesh, k1, k2) result(val)
    ! The coordinates (k1, k2) correspond to the (r1, r2) basis
    ! This function the 2nd coordinate on the cartesian system
    class(hex_mesh_2d)     :: mesh
    sll_int32, intent(in)  :: k1
    sll_int32, intent(in)  :: k2
    sll_real64  :: val

    val = mesh%r1_x2*k1 + mesh%r2_x2*k2 + mesh%center_x1
  end function x2_node


  function cells_to_origin(k1, k2) result(val)
    ! Takes the coordinates (k1,k2) on the (r1,r2) basis and 
    ! returns the number of cells between that point and
    ! the origin. If (k1, k2) = 0, val = 0
    sll_int32, intent(in)   :: k1
    sll_int32, intent(in)   :: k2
    sll_int32               :: val

    ! We compute the number of cells from point to center 
    if (k1*k2 .gt. 0) then
       val = max(abs(k1),abs(k2))
    else
       val = abs(k1) + abs(k2)
    end if

  end function cells_to_origin


  function hex_to_global(mesh, k1, k2) result(val)
    ! Takes the coordinates (k1,k2) on the (r1,r2) basis and 
    ! returns global index of that mesh point.
    ! By default the index of the center of the mesh is 0
    ! Then following the r1 direction and a counter-clockwise motion
    ! we assing an index to every point of the mesh.
    class(hex_mesh_2d)      :: mesh
    sll_int32, intent(in)   :: k1
    sll_int32, intent(in)   :: k2
    sll_int32               :: distance
    sll_int32               :: index_tab
    sll_int32               :: val
    
    distance = cells_to_origin(k1,k2)

    ! Test if we are in domain
    if (distance .le. mesh%num_cells) then

       call index_hex_to_global(mesh, k1, k2,index_tab)
       val = mesh%global_indices(index_tab)

    else
       val = -1
    end if

  end function hex_to_global


  function global_to_hex1(mesh, index) result(k1)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the first coordinate (k1) on the (r1,r2) basis 
    class(hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: k1

    k1 = mesh%hex_coord(1,index)
  end function global_to_hex1

  function global_to_hex2(mesh, index) result(k2)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the second coordinate (k2) on the (r1,r2) basis 
    class(hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: k2

    k2 = mesh%hex_coord(2,index)
  end function global_to_hex2

  function global_to_x1(mesh, index) result(x1)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the first coordinate (x1) on the cartesian basis 
    class(hex_mesh_2d) :: mesh
    sll_int32  :: index
    sll_real64 :: x1

    x1 = mesh%cartesian_coord(1, index)
  end function global_to_x1

  function global_to_x2(mesh, index) result(x2)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the second coordinate (x2) on the cartesian basis 
    class(hex_mesh_2d) :: mesh
    sll_int32  :: index
    sll_real64 :: x2

    x2 = mesh%cartesian_coord(2, index)
  end function global_to_x2


  function cart_to_hex1(mesh, x1, x2) result(k1)
    ! Takes the coordinates (x1,x2) on the cartesian basis and 
    ! returns the first coordinate (k1) on the (r1, r2) basis
    class(hex_mesh_2d) :: mesh
    sll_real64 :: x1
    sll_real64 :: x2
    sll_int32  :: k1
    sll_real64 :: jacob

    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
    k1 = floor((mesh%r2_x2 * x1 - mesh%r2_x1 * x2)/jacob)
  end function cart_to_hex1

  function cart_to_hex2(mesh, x1, x2) result(k2)
    ! Takes the coordinates (x1,x2) on the cartesian basis and 
    ! returns the second coordinate (k2) on the (r1, r2) basis
    class(hex_mesh_2d) :: mesh
    sll_real64 :: x1
    sll_real64 :: x2
    sll_int32  :: k2
    sll_real64 :: jacob

    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
    k2 = floor((mesh%r1_x1 * x2 - mesh%r1_x2 * x1)/jacob)
  end function cart_to_hex2

  function global_to_local(mesh, ref_index, global) result(local)
    ! In the same manner we assign global indices (see hex_to_global(...))
    ! we assign local indices, but this time the initial point is 
    ! the point which index is ref_index
    ! ie. local_index(i,i) = 1
    class(hex_mesh_2d) :: mesh
    sll_int32 :: ref_index
    sll_int32 :: global
    sll_int32 :: k1_ref,  k2_ref
    sll_int32 :: k1_glob, k2_glob
    sll_int32 :: local

    if ((ref_index.le.mesh%num_pts_tot).and.(ref_index.gt.0) &
         .and.(global.le.mesh%num_pts_tot).and.(global.gt.0)) then

       k1_ref = mesh%global_to_hex1(ref_index)
       k2_ref = mesh%global_to_hex2(ref_index)
       k1_glob = mesh%global_to_hex1(global)
       k2_glob = mesh%global_to_hex2(global)

       local = mesh%hex_to_global(k1_ref - k1_glob, k2_ref - k2_glob)
    else
       ! Out of domain
       local = -1
    end if

  end function global_to_local


  function local_to_global(mesh, ref_index, local) result(global)
    ! returns the global index of the point which has as
    ! local index local_index in the ref_index system
    ! (see gloval_index(...) and global_to_local(...) for conventions) 
    ! ie. local_to_global(1, i) = i
    class(hex_mesh_2d) :: mesh
    sll_int32 :: ref_index, local
    sll_int32 :: k1_ref, k2_ref
    sll_int32 :: k1_loc, k2_loc
    sll_int32 :: global

    if ((ref_index.le.mesh%num_pts_tot).and.(ref_index.gt.0) &
         .and.(local.le.mesh%num_pts_tot).and.(local.gt.0)) then
       k1_ref = mesh%global_to_hex1(ref_index)
       k2_ref = mesh%global_to_hex2(ref_index)
       k1_loc = mesh%global_to_hex1(local)
       k2_loc = mesh%global_to_hex2(local)

       global = mesh%hex_to_global(k1_ref + k1_loc, k2_ref + k2_loc) 
    else
       ! Out of domain
       global = -1
    end if

  end function local_to_global

  subroutine get_cell_vertices_index( x, y, mesh, s1, s2, s3 )
    type(hex_mesh_2d), pointer            :: mesh
    sll_real64, intent(in)                :: x, y
    sll_int32, intent(out)                :: s1, s2, s3
    sll_real64                            :: h1, h2, xi, radius, step
    sll_int32                             :: num_cells 
    sll_int32                             :: i, j

    num_cells = mesh%num_cells
    radius    = mesh%radius
    step      = mesh%delta

    ! converting (x,y) to hexagonal coordinates
    ! find the lowest point in the lozenge that contains (x,y)
    i = cart_to_hex1(mesh, x, y)
    j = cart_to_hex2(mesh, x, y)

    ! coordinates of the vertices of the lozenge : 
    !(/i,j/),(/i,j+1/),(/i+1,j/), (/i+1,j+1/)

    ! coordinate of the abscisse that parts the lozenge
    ! in two equilateral triangle

    xi = ( real(i,f64) - real(j,f64) ) * step*sqrt(3.0_f64)*0.5_f64

    ! testing which triangle (x,y) is in, which gives us its vertices'
    ! coordinates

    if ( x > xi ) then
       s1 = hex_to_global(mesh,i,j) 
       s2 = hex_to_global(mesh,i+1,j) 
       s3 = hex_to_global(mesh,i+1,j+1) 
    else if ( x < xi ) then
       s1 = hex_to_global(mesh,i,j) 
       s2 = hex_to_global(mesh,i,j+1)
       s3 = hex_to_global(mesh,i+1,j+1)
    else if ( x == xi ) then
       if (x < 0) then
          s1 = hex_to_global(mesh,i,j) 
          s2 = hex_to_global(mesh,i+1,j) 
          s3 = hex_to_global(mesh,i+1,j+1) 
       elseif (x >= 0) then
          s1 = hex_to_global(mesh,i,j)
          s2 = hex_to_global(mesh,i,j+1) 
          s3 = hex_to_global(mesh,i+1,j+1) 
       endif
    endif


  end subroutine get_cell_vertices_index


  subroutine get_triangle_index(k1,k2,mesh,x,triangle_index)
    type(hex_mesh_2d), pointer :: mesh
    sll_real64, intent(in)     :: x !cartessian_abscisse_other_vertice
    sll_int32, intent(in)      :: k1, k2
    sll_int32, intent(out)     :: triangle_index
    sll_int32                  :: global

    ! almost every point is the lowest point of a lozenge , i.e. 2 triangles
    ! we get therefore 2 indices per points
    ! in order to have the correct one we test in which triangle we are 

    global = hex_to_global(mesh,k1,k2)

    if ( x < mesh%cartesian_coord(1,global) ) then
       triangle_index = mesh%center_index(1,global) !left triangle
    else
       triangle_index = mesh%center_index(2,global) !right triangle
    endif

    if (triangle_index == -1 ) print*, "problem in get_triangle_index l701"

  end subroutine get_triangle_index


  subroutine display_hex_mesh_2d(mesh)
    ! Displays mesh information on the terminal
    type(hex_mesh_2d), pointer :: mesh

    write(*,"(/,(a))") '2D mesh : num_cells   num_pts        center_x1       center_x2 &
         &       radius'
    write(*,"(10x,2(i4,10x),3(g13.3,1x))") mesh%num_cells,  &
         mesh%num_pts_tot,&
         mesh%center_x1,  &
         mesh%center_x2,  &
         mesh%radius
  end subroutine display_hex_mesh_2d


  subroutine write_hex_mesh_2d(mesh, name)
    ! Writes the mesh information in a file named "name"
    type(hex_mesh_2d), pointer :: mesh
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: num_pts_tot
    sll_int32  :: k1, k2
    sll_int32, parameter :: out_unit=20

    open (unit=out_unit,file=name,action="write",status="replace")

    num_pts_tot = mesh%num_pts_tot

    ! Optional writing every mesh point and its cartesian coordinates :
    !    write(*,"(/,(a))") 'hex mesh : num_pnt    x1     x2'

    do i=1, num_pts_tot
       k1 = mesh%global_to_hex1(i)
       k2 = mesh%global_to_hex2(i)
       write (out_unit, "(3(i6,1x),2(g13.3,1x))") i,                &
            k1,                      &
            k2,                      &
            mesh%global_to_x1(i), &
            mesh%global_to_x2(i)
    end do

    close(out_unit)
  end subroutine write_hex_mesh_2d

  subroutine write_field_hex_mesh(mesh, field, name)
    ! Writes the points cartesian coordinates and
    ! field(vector) values in a file named "name"
    type(hex_mesh_2d), pointer :: mesh
    sll_real64,dimension(:) :: field
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: num_pts_tot
    sll_real64 :: x1, x2
    sll_int32, parameter :: out_unit=20

    open (unit=out_unit,file=name,action="write",status="replace")

    num_pts_tot = mesh%num_pts_tot
    do i=1, num_pts_tot
       x1 = mesh%global_to_x1(i)
       x2 = mesh%global_to_x2(i)
       write (out_unit, "(3(g13.3,1x))") x1, &
            x2, &
            field(i)
    end do

    close(out_unit)
  end subroutine write_field_hex_mesh


  subroutine delete_hex_mesh_2d( mesh )
    type(hex_mesh_2d), pointer :: mesh
    sll_int32 :: ierr

    if(.not. associated(mesh))then
       print *, 'delete_hex_mesh_2d'
       print *, 'ERROR: passed argument is not associated'
       print *, '       Crash imminent...'
       STOP
    end if


    SLL_DEALLOCATE(mesh%cartesian_coord, ierr)
    SLL_DEALLOCATE(mesh%hex_coord, ierr)
    SLL_DEALLOCATE(mesh%global_indices, ierr)
    SLL_DEALLOCATE(mesh, ierr)
  end subroutine delete_hex_mesh_2d


#undef TEST_PRESENCE_AND_ASSIGN_VAL

end module hex_mesh
