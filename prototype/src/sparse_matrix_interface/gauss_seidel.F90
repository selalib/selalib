MODULE GAUSS_SEIDEL_MODULE
USE SPM_DEF
USE SPM_TOOLS
IMPLICIT NONE

PRIVATE

PUBLIC :: GS_INITIALIZE, GS_SOLVE, GS_FREE


CONTAINS
! ---------------------------------------
SUBROUTINE GS_INITIALIZE(N, NNZ, A, JA, IA &
                        , NNZ_U, U, JU, IU &
                        , NNZ_L, L, JL, IL &
                        , DIAGA)
IMPLICIT NONE
INTEGER(KIND=SPM_INTS_KIND) :: N
INTEGER(KIND=SPM_INTL_KIND) :: NNZ
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: A
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IA
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JA
INTEGER(KIND=SPM_INTL_KIND) :: NNZ_U
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: U 
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IU
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JU
INTEGER(KIND=SPM_INTL_KIND) :: NNZ_L
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: L
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IL
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JL
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: DIAGA 

ALLOCATE(DIAGA(N))

CALL GS_CREATE_U(N, NNZ, A, JA, IA, NNZ_U, U, JU, IU, .FALSE.)
CALL GS_CREATE_L(N, NNZ, A, JA, IA, NNZ_L, L, JL, IL, .TRUE.)

CALL GS_INIT_SOLVE(N, L, JL, IL, DIAGA)

END SUBROUTINE GS_INITIALIZE
! ---------------------------------------

! ---------------------------------------
SUBROUTINE GS_FREE(U, JU, IU, L, JL, IL, DIAGA)
IMPLICIT NONE
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: U 
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IU
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JU
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: L
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IL
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JL
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: DIAGA

DEALLOCATE(DIAGA)
DEALLOCATE(U,IU,JU)
DEALLOCATE(L,IL,JL)

END SUBROUTINE GS_FREE
! ---------------------------------------

! ---------------------------------------
!       EXTRACT THE UPPER MATRIX
! ---------------------------------------
SUBROUTINE GS_CREATE_U(N, NNZ, A, JA, IA, NNZ_U, U, JU, IU, NOUDIAG)
IMPLICIT NONE
INTEGER(KIND=SPM_INTS_KIND) :: N
INTEGER(KIND=SPM_INTL_KIND) :: NNZ
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: A
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IA
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JA
INTEGER(KIND=SPM_INTL_KIND) :: NNZ_U
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: U 
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IU
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JU
LOGICAL :: NOUDIAG
! LOCAL
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: Un
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IUn
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JUn
INTEGER :: I

ALLOCATE(Un(NNZ))
ALLOCATE(JUn(NNZ))
ALLOCATE(IUn(N+1))
CALL getu (N,A,JA,IA,Un,JUn,IUn)
NNZ_U = NNZ
IF (.not. NOUDIAG) THEN
        DO I = 1, N
        Un(IUn(I)) = 0.0
        END DO
        CALL remove_zeros ( N, N, Un, JUn, IUn, NNZ_U)
        ! multiply by -1
        Un = - Un        
ELSE
        NNZ_U = IUn(N+1) - 1        
END IF
ALLOCATE(U(NNZ_U))
ALLOCATE(JU(NNZ_U))
ALLOCATE(IU(N+1))
IU ( 1 : N + 1 ) = IUn ( 1 : N + 1 )
JU ( 1 : NNZ_U ) = JUn ( 1 : NNZ_U )
U  ( 1 : NNZ_U ) = Un  ( 1 : NNZ_U ) 
DEALLOCATE(Un,IUn,JUn)
END SUBROUTINE GS_CREATE_U
! ---------------------------------------

! ---------------------------------------
!       EXTRACT THE LOWER MATRIX
! ---------------------------------------
SUBROUTINE GS_CREATE_L(N, NNZ, A, JA, IA, NNZ_L, L, JL, IL, NOLDIAG)
IMPLICIT NONE
INTEGER(KIND=SPM_INTS_KIND) :: N
INTEGER(KIND=SPM_INTL_KIND) :: NNZ
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: A
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IA
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JA
INTEGER(KIND=SPM_INTL_KIND) :: NNZ_L
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: L
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IL
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JL
LOGICAL :: NOLDIAG
! LOCAL
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: Ln
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: ILn
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JLn
INTEGER :: I

ALLOCATE(Ln(NNZ))
ALLOCATE(JLn(NNZ))
ALLOCATE(ILn(N+1))

CALL getl (N,A,JA,IA,Ln,JLn,ILn)

NNZ_L = NNZ
IF (.not. NOLDIAG) THEN
        DO i = 1, N
        Ln(ILn(I)) = 0.0
        END DO
        CALL remove_zeros ( N, N, Ln, JLn, ILn, NNZ_L)
        ! multiply by -1
        Ln = - Ln
ELSE
        NNZ_L = ILn(N+1) - 1        
ENDIF
ALLOCATE(L(NNZ_L))
ALLOCATE(JL(NNZ_L))
ALLOCATE(IL(N+1))
IL ( 1 : N + 1 ) = ILn ( 1 : N + 1 )
JL ( 1 : NNZ_L ) = JLn ( 1 : NNZ_L )
L  ( 1 : NNZ_L ) = Ln  ( 1 : NNZ_L ) 
DEALLOCATE(Ln,ILn,JLn)
END SUBROUTINE GS_CREATE_L

! -----

SUBROUTINE GS_INIT_SOLVE(N, L, JL, IL, DIAGA)
! extracts the diagonal terms and scales L
IMPLICIT NONE
INTEGER(KIND=SPM_INTS_KIND) :: N
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: L
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IL
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JL
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: DIAGA 
! LOCAL
REAL(KIND=SPM_COEF_KIND) :: DIAG 
INTEGER :: I
INTEGER :: len 
INTEGER :: ioff
INTEGER :: job
INTEGER :: k_1, k_2 
INTEGER :: k, J
REAL(KIND=SPM_COEF_KIND)  :: v
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: Z 
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: DIAGT
INTEGER, DIMENSION(N) :: IDIAGT

! lsol needs unit matrix
! we need to convert the matrix
job = 0
ioff = 0
CALL getdia (N,N,job,L,JL,IL,len,DIAGT,IDIAGT,ioff)
IF (len<N) THEN
        PRINT *, 'Found zero element on the diagonal.'
        STOP
END IF

DIAGA = 0.0
DO I=1,N
        DIAG=L(IDIAGT(I))
        DIAGA (I) = DIAG

        k_1 = IL(I) ; k_2 = IL(I + 1) - 1
        L(k_1: k_2) = L(k_1: k_2) / DIAG
     
ENDDO

END SUBROUTINE GS_INIT_SOLVE

! ---------------------------------------

SUBROUTINE GS_SOLVE( N, A, JA, IA &
                   , U, JU, IU    &
                   , L, JL, IL    &
                   , DIAGA        &
                   , X, B, TOL    &
                   , ITS, ITERS   &
                   , RESNORM, RESIDUALS)
! Solves T^-1 (Ax+f)
! where T is triangular : upper or lower
! flag = 0 : T is lower triangular
! flag = 1 : T is upper triangular
IMPLICIT NONE
INTEGER(KIND=SPM_INTS_KIND) :: N
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: A
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JA
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IA
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: U 
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IU
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JU
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: L
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IL
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JL
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: DIAGA
REAL(KIND=SPM_COEF_KIND), DIMENSION(:), POINTER :: X 
REAL(KIND=SPM_COEF_KIND), DIMENSION(:), POINTER :: B
INTEGER(KIND=SPM_INTS_KIND) :: ITS 
REAL(KIND=SPM_COEF_KIND)    :: TOL
INTEGER(KIND=SPM_INTS_KIND) :: ITERS 
REAL(KIND=SPM_COEF_KIND) :: RESNORM
REAL(KIND=SPM_COEF_KIND), DIMENSION(:), POINTER :: RESIDUALS 
! LOCAL
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: XNEW 
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: ERR 
REAL(KIND=SPM_COEF_KIND) :: lr_NormInfr, lr_NormInfb
LOGICAL :: ll_continue
INTEGER :: li_err

lr_NormInfb = maxval( dabs( B ) )
ITERS=0
ll_continue=.true.
DO while(ll_continue)
        ITERS = ITERS + 1
        CALL GS_SOLVE_ATOM(N, U, JU, IU, L, JL, IL, DIAGA, X, B, XNEW)

        CALL CSR_GEMV(0, N, A, JA, IA, X, ERR, li_err)
        ERR = B - ERR
        lr_NormInfr = maxval(dabs( ERR ))
        RESIDUALS(ITERS) = lr_NormInfr
        X = XNEW
        ll_continue=( ( lr_NormInfr / lr_NormInfb ) >= tol ) .AND. ( ITERS < ITS )
ENDDO

X = XNEW
RESNORM = lr_NormInfr

END SUBROUTINE GS_SOLVE 

! -------------

SUBROUTINE GS_SOLVE_ATOM(N, U, JU, IU, L, JL, IL, DIAGA, X, B, XNEW)
! Solves T^-1 (Ax+f)
! where T is triangular : upper or lower
! flag = 0 : T is lower triangular
! flag = 1 : T is upper triangular
IMPLICIT NONE

INTEGER :: N
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: U 
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IU
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JU
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: L
INTEGER(KIND=SPM_INTS_KIND), DIMENSION(:), POINTER :: IL
INTEGER(KIND=SPM_INTL_KIND), DIMENSION(:), POINTER :: JL
REAL(KIND=SPM_COEF_KIND)   , DIMENSION(:), POINTER :: DIAGA
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: X 
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: B
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: XNEW 
! LOCAL
REAL(KIND=SPM_COEF_KIND) :: DIAG 
INTEGER :: I
INTEGER :: len 
INTEGER :: ioff
INTEGER :: job
INTEGER :: k_1, k_2 
INTEGER :: k, J
REAL(KIND=SPM_COEF_KIND)  :: v
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: Z 
REAL(KIND=SPM_COEF_KIND), DIMENSION(N) :: DIAGT
INTEGER, DIMENSION(N) :: IDIAGT
INTEGER :: li_err

XNEW = 0.0
Z = 0.0
! Z <-- A * X
CALL CSR_GEMV(0, N, U, JU, IU, X, Z, li_err)
!PRINT *, 'UX = ', Z
! Z <-- Z + B
Z = Z + B 

DO I=1,N
        Z(I)=Z(I)/DIAGA(I)
ENDDO
!PRINT *, 'Z = ', Z

! Solves the triangular system
CALL lsol (N, XNEW, Z, L, JL, IL)

!PRINT *, XNEW
END SUBROUTINE GS_SOLVE_ATOM 


END MODULE GAUSS_SEIDEL_MODULE
