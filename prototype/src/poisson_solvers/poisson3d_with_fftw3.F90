PROGRAM POISSON3D_WITH__FFTW3

IMPLICIT NONE

INTEGER :: I, J, K, MX, MY, MZ, IERR
INTEGER :: NX, NY, NZ
INTEGER :: NCOUNT, T0, TN, ISTEP, NSTEP
INTEGER :: NTHREADS = 4

INTEGER(8) :: FORWARD, BACKWARD

REAL(8) :: X, Y, Z, TBEGIN, TEND, ERR
REAL(8) :: DX, DY, DZ, TIME, DT, PI 
REAL(8) :: CX, CY, CZ, VPX, VPY, VPZ

REAL(8), DIMENSION(:,:,:), ALLOCATABLE :: B, C, D
REAL(8), ALLOCATABLE :: U(:,:,:)
REAL(8), ALLOCATABLE :: F(:,:,:)
REAL(8), ALLOCATABLE :: G(:,:,:)


NX = 130; NY = 130; NZ = 130
DX = 1d0 / NX ; DY = 1d0 / NY ; DZ = 1d0 / NZ
DT = 0.1; NSTEP = 10
PI = 4d0 * DATAN(1d0)

ALLOCATE(U(NX,NY,NZ)); U = 0.
ALLOCATE(F(NX,NY,NZ)); F = 0.
ALLOCATE(G(NX,NY,NZ)); G = 0.

CALL INIT_POISSON_FFTW(NX,NY,NZ)
CALL SYSTEM_CLOCK(COUNT=T0, COUNT_RATE=NCOUNT)
CALL CPU_TIME(TBEGIN)

TIME = 0.0
DO ISTEP = 1, NSTEP !Loop over time

   DO K = 1, NZ
      Z = (K-1)*DZ
      DO J = 1, NY
         Y = (J-1)*DY
         DO I = 1, NX
            X = (I-1)*DX
            F(I,J,K) = 12.*PI*PI*SIN(2*PI*X)*SIN(2*PI*Y)*SIN(2*PI*Z)*COS(2*PI*TIME)
            G(I,J,K) = SIN(2*PI*X)*SIN(2*PI*Y)*SIN(2*PI*Z)*COS(2*PI*TIME)
         ENDDO
      ENDDO
   ENDDO

   CALL SOLVE_POISSON_FFTW(U, F, NX, NY, NZ )

   WRITE(*,'("ISTEP = ",I4," TIME = ",G15.5," NX,NY,NZ =",3I4)') &
		ISTEP, TIME, NX, NY, NZ

   ERR = MAXVAL(U-G)
   PRINT  '(3X,"Norm(|ux - u_a|)               : ",2X,1PE10.3,//)', ERR

   TIME = TIME+DT

END DO !Next time step

CALL FINALIZE_POISSON_FFTW()

CALL SYSTEM_CLOCK(COUNT=TN, COUNT_RATE=NCOUNT)
WRITE(*,"(' ELAPSED TIME ', G15.5, ' s')") (TN - T0)/FLOAT(NCOUNT)
CALL CPU_TIME(TEND)
WRITE(*,"(' CPU TIME ', G15.5, ' s')") TEND-TBEGIN

CONTAINS

SUBROUTINE INIT_POISSON_FFTW(NX,NY,NZ)
#include "fftw3.f"
INTEGER, INTENT(IN) :: NX,NY,NZ

MX = NX-2; MY = NY-2; MZ = NZ-2

CX = 1.0 / (DX*DX)
CY = 1.0 / (DY*DY)
CZ = 1.0 / (DZ*DZ)

!RHS
ALLOCATE(B(MX,MY,MZ), D(MX,MY,MZ),C(MX,MY,MZ))

!Compute eigen values, build the matrix
DO K=1,MZ
   DO J=1,MY
      DO I=1,MX
         VPX=1.0-COS(FLOAT(I)*PI/FLOAT(MX+1))
         VPY=1.0-COS(FLOAT(J)*PI/FLOAT(MY+1))
         VPZ=1.0-COS(FLOAT(K)*PI/FLOAT(MZ+1))
         D(I,J,K)= 2.0 * (CZ*VPZ + CX*VPX + CY*VPY) &
                   * (8*(MX+1)*(MY+1)*(MZ+1))
      END DO
   END DO
END DO

!Initialize FFTs
CALL DFFTW_INIT_THREADS(IERR)
IF (IERR == 0) STOP 'FFTW CAN''T USE THREADS'
CALL DFFTW_PLAN_WITH_NTHREADS(NTHREADS)
CALL DFFTW_PLAN_R2R_3D(FORWARD,MX,MY,MZ,C,B, &
                       FFTW_RODFT00, FFTW_RODFT00,FFTW_RODFT00,&
                       FFTW_PATIENT )
CALL DFFTW_PLAN_R2R_3D(BACKWARD,MX,MY,MZ,B,C, &
                       FFTW_RODFT00, FFTW_RODFT00,FFTW_RODFT00,&
                       FFTW_PATIENT )

END SUBROUTINE INIT_POISSON_FFTW

SUBROUTINE SOLVE_POISSON_FFTW(PSI, RHS, NX, NY, NZ)
#include "fftw3.f"
INTEGER, INTENT(IN)  :: NX, NY, NZ
REAL(8), INTENT(OUT) :: PSI(NX,NY,NZ)
REAL(8), INTENT(IN)  :: RHS(NX,NY,NZ)

!Boundary conditions
DO I=1,MX
   DO J=1,MY
      DO K = 1, MZ
         C(I,J,K) = RHS(I+1,J+1,K+1)
         IF ( I == 1) THEN
            C(I,J,K) = C(I,J,K) + CX * PSI( 1,J+1,K+1)
         ELSE IF (I == MX) THEN
            C(I,J,K) = C(I,J,K) + CX * PSI(NX,J+1,K+1)
         ELSE IF ( J == 1) THEN
            C(I,J,K) = C(I,J,K) + CY * PSI( I+1,1,K+1)
         ELSE IF (J == MY) THEN
            C(I,J,K) = C(I,J,K) + CY * PSI(I+1,NY,K+1)
         ELSE IF ( K == 1) THEN
            C(I,J,K) = C(I,J,K) + CZ * PSI(I+1,J+1,1)
         ELSE IF (K == MZ) THEN
            C(I,J,K) = C(I,J,K) + CZ * PSI(I+1,J+1,NZ)
         END IF
      END DO
   END DO
END DO
!Forward FFT on the right hand side term
CALL DFFTW_EXECUTE_R2R(FORWARD,C,B)

B = B / D 

!Backward FFT on the solution
CALL DFFTW_EXECUTE_R2R(BACKWARD,B,PSI(2:NX-1,2:NY-1,2:NZ-1))


RETURN

END SUBROUTINE SOLVE_POISSON_FFTW

SUBROUTINE FINALIZE_POISSON_FFTW()
#include "fftw3.f"

CALL DFFTW_DESTROY_PLAN(FORWARD)
CALL DFFTW_DESTROY_PLAN(BACKWARD)
CALL DFFTW_CLEANUP_THREADS(IERR)

END SUBROUTINE

END PROGRAM POISSON3D_WITH__FFTW3
