!------------------------------------------------------------------------------
! SELALIB
!------------------------------------------------------------------------------
! MODULE: sll_hex_meshes
!
! DESCRIPTION:
!> @file sll_hex_meshes.F90
!>
!> @author
!> - Laura S. Mendoza (mela@ipp.mpg.de)
!> - Charles Prouveur (prouveur@math.univ-lyon1.fr)
!>
!> @brief
!>  This module defines a hexagonal mesh.
!>
!> @details
!>  An hexagonal mesh is a triangular mesh with an hexagonally-shaped
!>  boundary subdivided in equilateral triangles. It has the
!>  particularity of being generated by 3 non-orthogonal vectors.
!------------------------------------------------------------------------------
module sll_hex_meshes
#include "sll_working_precision.h"
#include "sll_memory.h"

use sll_constants
use sll_utilities
use sll_meshes_base
use sll_tri_mesh_xmf

  implicit none

  !> @brief 2d hexagonal mesh
  type,extends(sll_mesh_2d_base) ::  sll_hex_mesh_2d
     ! A hexagonal mesh (composed by equilateral triangles)
     ! is defined by three directional vectors (r1, r2, r3)
     ! the number of cells, the radius, and the coordinates of the center
     sll_int32  :: num_cells     !< number of cells in any direction parting from origin
     sll_int32  :: num_pts_tot   !< number of total points
     sll_int32  :: num_triangles !< number of triangles
     sll_int32  :: num_edges     !< number of edges
     sll_real64 :: radius        !< distance between origin and external vertex
     sll_real64 :: center_x1     !< x1 cartesian coordinate of the origin
     sll_real64 :: center_x2     !< x2 cartesian coordinate of the origin
     sll_real64 :: delta         !< cell spacing
     sll_real64 :: r1_x1 !< first coordinate of first generator vector
     sll_real64 :: r1_x2 !< second coordinate of first generator vector
     sll_real64 :: r2_x1 !< first coordinate of second generator vector
     sll_real64 :: r2_x2 !< second coordinate of second generator vector
     sll_real64 :: r3_x1 !< first coordinate of third generator vector
     sll_real64 :: r3_x2 !< second coordinate of third generator vector

     ! Matrix containing mesh points coordinates in cartesian coordinates :
     sll_real64, pointer, dimension(:,:) :: cartesian_coord !< (1:2,1:num_pts_tot)
     ! Matrix containing mesh points coordinates in hexagonal coordinates (integers) :
     sll_int32, pointer, dimension(:,:)  :: hex_coord !< (1:2,1:num_pts_tot)
     ! Matrix containg global indices arranged from lower corner of hexagon
     ! and following the r2, then r1 direction
     sll_int32, pointer, dimension(:) :: global_indices !< (1:num_pts_tot)

     ! matrix containing the cartesian coordinates of the centers of the triangles
     sll_real64, pointer, dimension(:,:) :: center_cartesian_coord !< (1:2,1:num_triangles)     
     ! matrix containing the index of the respective center
     ! of the 2 triangles at the top of most points
     sll_int32, pointer, dimension(:,:) :: center_index!< (1:2,1:num_pts_tot)

     ! The following two tables are not always needed, to avoid useless allocation
     ! and initialization we define a flag to know if they are required
     sll_int32 :: EXTRA_TABLES
     sll_real64, pointer, dimension(:,:) :: edge_center_cartesian_coord !< (1:2,1:num_edges)     
     ! matrix containing the index of the respective center of the 2 triangles at the top of most points
     sll_int32, pointer, dimension(:,:) :: edge_center_index!< (1:3,1:num_pts_tot)

   contains
     procedure, pass(mesh) :: eta1_node => eta1_node_hex
     procedure, pass(mesh) :: eta2_node => eta2_node_hex
     procedure, pass(mesh) :: eta1_cell_one_arg => eta1_cell_hex
     procedure, pass(mesh) :: eta1_cell_two_arg => eta1_cell_hex_two_arg
     procedure, pass(mesh) :: eta2_cell_one_arg => eta2_cell_hex
     procedure, pass(mesh) :: eta2_cell_two_arg => eta2_cell_hex_two_arg
     procedure, pass(mesh) :: index_hex_to_global
     procedure, pass(mesh) :: hex_to_global
     procedure, pass(mesh) :: global_to_hex1
     procedure, pass(mesh) :: global_to_hex2
     procedure, pass(mesh) :: global_to_x1
     procedure, pass(mesh) :: global_to_x2
     procedure, pass(mesh) :: cart_to_hex1
     procedure, pass(mesh) :: cart_to_hex2
     procedure, pass(mesh) :: global_to_local
     procedure, pass(mesh) :: local_to_global
     procedure, pass(mesh) :: local_hex_to_global
     procedure, pass(mesh) :: display => display_hex_mesh_2d
     procedure, pass(mesh) :: delete => delete_hex_mesh_2d
  end type sll_hex_mesh_2d

  type hex_mesh_2d_ptr
     type(sll_hex_mesh_2d), pointer :: hm
  end type hex_mesh_2d_ptr

  interface delete
     module procedure delete_hex_mesh_2d
  end interface delete

  interface sll_display
     module procedure display_hex_mesh_2d
  end interface sll_display

  ! interface eta1_cell
  !    module procedure eta1_cell_one_arg, eta1_cell_two_arg
  ! end interface eta1_cell

  ! interface eta2_cell
  !    module procedure eta2_cell_one_arg, eta2_cell_two_arg
  ! end interface eta2_cell


contains

  ! Definition of a fonction to test if an argument is present
  ! if it is it will asign it to the object at the slot,
  ! else it will take a default value
#define TEST_PRESENCE_AND_ASSIGN_VAL( obj, arg, slot, default_val ) \
  if( present(arg) ) then ; \
     obj%slot = arg; \
  else; \
     obj%slot = default_val; \
  end if


  !-------------------------------------------------------------------------
  !> @brief Creates and initializes a new hexagonal mesh
  !> @details An hexagonal mesh is defined using the number of cells 
  !>          in each direction, the coordinates of its center, the 
  !>          generator vectors values, and the radius
  !> @param num_cells integer denoting the number of cells in 
  !> any direction parting from origin
  !> @param center_x1 optional real: first cartesian coordinate of the origin
  !> @param center_x2 optional real: second cartesian coordinate of the origin
  !> @param r11 optional real: first cartesian coordinate of the first generating vector
  !> @param r12 optional real: second cartesian coordinate of the first generating vector
  !> @param r21 optional real: first cartesian coordinate of the second generating vector
  !> @param r22 optional real: second cartesian coordinate of the second generating vector
  !> @param r31 optional real: first cartesian coordinate of the third generating vector
  !> @param r32 optional real: second cartesian coordinate of the third generating vector
  !> @param radius optional real: distance between origin and external vertex
  !> @param EXTRA_TABLES integer flag: if set to 1 additional tables (for edges'
  !> center) will be created
  !> return a pointer to the newly allocated object.
  function new_hex_mesh_2d( &
       num_cells, &
       center_x1, &
       center_x2, &
       r11, &
       r12, &
       r21, &
       r22, &
       r31, &
       r32, &
       radius, &
       EXTRA_TABLES) result(mesh)

    type(sll_hex_mesh_2d), pointer :: mesh
    sll_int32, intent(in)  :: num_cells
    sll_real64, optional, intent(in) :: radius
    sll_real64, optional, intent(in) :: center_x1
    sll_real64, optional, intent(in) :: center_x2
    sll_real64, optional, intent(in) :: r11, r12
    sll_real64, optional, intent(in) :: r21, r22
    sll_real64, optional, intent(in) :: r31, r32
    sll_int32,  optional, intent(in) :: EXTRA_TABLES
    sll_int32 :: ierr

    SLL_ALLOCATE(mesh, ierr)

    call initialize_hex_mesh_2d( &
         mesh, &
         num_cells, &
         radius, &
         center_x1, &
         center_x2, &
         r11, &
         r12, &
         r21, &
         r22, &
         r31, &
         r32, &
         EXTRA_TABLES)

  end function new_hex_mesh_2d

  !-------------------------------------------------------------------------
  !> @brief initializes a previously allocated 2d hex-mesh
  !> @param num_cells integer denoting the number of cells in 
  !> any direction parting from origin
  !> @param center_x1 optional real: first cartesian coordinate of the origin
  !> @param center_x2 optional real: second cartesian coordinate of the origin
  !> @param r11 optional real: first cartesian coordinate of the first generating vector
  !> @param r12 optional real: second cartesian coordinate of the first generating vector
  !> @param r21 optional real: first cartesian coordinate of the second generating vector
  !> @param r22 optional real: second cartesian coordinate of the second generating vector
  !> @param r31 optional real: first cartesian coordinate of the third generating vector
  !> @param r32 optional real: second cartesian coordinate of the third generating vector
  !> @param radius optional real: distance between origin and external vertex
  !> @param EXTRA_TABLES integer flag: if set to 1 additional tables (for edges'
  !> center) will be created
  !> return a pointer to the newly allocated object.
  subroutine initialize_hex_mesh_2d( &
       mesh, &
       num_cells, &
       radius,    &
       center_x1, &
       center_x2, &
       r1_x1,     &
       r1_x2,     &
       r2_x1,     &
       r2_x2,     &
       r3_x1,     &
       r3_x2,     &
       EXTRA_TABLES)


    type(sll_hex_mesh_2d), pointer :: mesh
    sll_int32, intent(in)  :: num_cells
    sll_real64, optional, intent(in) :: radius
    sll_real64, optional, intent(in) :: center_x1
    sll_real64, optional, intent(in) :: center_x2
    sll_real64, optional, intent(in) :: r1_x1, r1_x2
    sll_real64, optional, intent(in) :: r2_x1, r2_x2
    sll_real64, optional, intent(in) :: r3_x1, r3_x2
    sll_int32,  optional, intent(in) :: EXTRA_TABLES
    sll_int32  :: ierr
    sll_int32  :: i, j, global
    sll_real64 :: position_x1
    sll_real64 :: position_x2
    sll_int32  :: k1, k2
    sll_int32  :: index_tab
    ! variables for optmizing computing time :
    sll_int32  :: num_cells_plus1
    sll_int32  :: num_cells_plus2


    ! By default the hexagonal mesh is centered at the (0,0) point
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, center_x1, center_x1, 0.0_f64 )
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, center_x2, center_x2, 0.0_f64 )

    ! By default the hexagonal mesh has a radius of 1.
    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, radius, radius, 1.0_f64 )

    ! By default the hexagonal mesh has for generator vectors :
    ! r1 = (r11, r12) = ( sqrt(3)/2, 1/2 )
    ! r2 = (r21, r22) = (-sqrt(3)/2, 1/2 )
    ! r3 = (r31, r32) = ( 0, 1 )
    TEST_PRESENCE_AND_ASSIGN_VAL(mesh, r1_x1, r1_x1, sll_sqrt3 * 0.5_f64)
    TEST_PRESENCE_AND_ASSIGN_VAL(mesh, r1_x2, r1_x2, 0.5_f64)
    TEST_PRESENCE_AND_ASSIGN_VAL(mesh, r2_x1, r2_x1, -sll_sqrt3 * 0.5_f64)
    TEST_PRESENCE_AND_ASSIGN_VAL(mesh, r2_x2, r2_x2, 0.5_f64)
    TEST_PRESENCE_AND_ASSIGN_VAL(mesh, r3_x1, r3_x1, 0.0_f64)
    TEST_PRESENCE_AND_ASSIGN_VAL(mesh, r3_x2, r3_x2, 1.0_f64)

    mesh%num_cells = num_cells
    mesh%delta = mesh%radius/real(num_cells,f64)

    ! The formula is = 6*sum(num_cells)+1 which simplifies to :
    mesh%num_pts_tot   = 3 * mesh%num_cells * (mesh%num_cells + 1) + 1

    ! resizing :
    mesh%r1_x1 = mesh%r1_x1 * mesh%delta
    mesh%r1_x2 = mesh%r1_x2 * mesh%delta
    mesh%r2_x1 = mesh%r2_x1 * mesh%delta
    mesh%r2_x2 = mesh%r2_x2 * mesh%delta
    mesh%r3_x1 = mesh%r3_x1 * mesh%delta
    mesh%r3_x2 = mesh%r3_x2 * mesh%delta

    if ( mesh%radius <= 0.) then
       print*,'ERROR, initialize_hex_mesh_2d(): ', &
            'Problem to construct the mesh 2d '
       print*,'because radius <= 0.'
       STOP
    end if
    if ( mesh%num_cells <= 0) then
       print*,'ERROR, initialize_hex_mesh_2d(): ', &
            'Problem to construct the mesh 2d '
       print*,'because num_cells <= 0.'
       STOP
    end if

    ! Allocation and initialization of coordinate matrices
    ! and conectivity matrix
    SLL_ALLOCATE(mesh%cartesian_coord(2, mesh%num_pts_tot), ierr)
    SLL_ALLOCATE(mesh%hex_coord(2, mesh%num_pts_tot), ierr)
    SLL_ALLOCATE(mesh%global_indices(mesh%num_pts_tot), ierr)
    mesh%cartesian_coord(:,:)          = 0._f64
    mesh%hex_coord(:,:)                = 0
    mesh%global_indices(:)             = -1

    ! Initializing coordinates of first mesh point (ie. center of hexagon)
    mesh%cartesian_coord(1,1) = mesh%center_x1
    mesh%cartesian_coord(2,1) = mesh%center_x2

    !Useful variables
    num_cells_plus1 = num_cells + 1
    num_cells_plus2 = num_cells + 2

    ! ---------------------------------------------------------------------
    ! BEGIN MATRICES INITIALIZATION ---------------------------------------

    ! Initializing coordinates of first mesh point (ie. center of hexagon)
    global = 1
    position_x1 = mesh%center_x1
    position_x2 = mesh%center_x2 ! variable containing current position
    mesh%cartesian_coord(1,global) = position_x1
    mesh%cartesian_coord(2,global) = position_x2

    do i = 1, num_cells ! variable following r1
       ! Incrementation on r1 direction as we are going to the next hexagon
       position_x1 = position_x1 + mesh%r1_x1
       position_x2 = position_x2 + mesh%r1_x2

       ! We follow each hexagon edge :
       ! First edge
       do j = 1, i ! following r2, the number of points on edge = i
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = i
          mesh%hex_coord(2, global) = j-1

          position_x1 = position_x1 + mesh%r2_x1
          position_x2 = position_x2 + mesh%r2_x2
       end do

       ! Second edge
       do j = 1, i ! following -r1
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = i-j+1
          mesh%hex_coord(2, global) = i

          position_x1 = position_x1 - mesh%r1_x1
          position_x2 = position_x2 - mesh%r1_x2
       end do

       ! Third edge
       do j = 1, i ! following -r3
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = -j+1
          mesh%hex_coord(2, global) = i-j+1

          position_x1 = position_x1 - mesh%r3_x1
          position_x2 = position_x2 - mesh%r3_x2
       end do

       ! Fourth edge
       do j = 1, i ! following -r2
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = -i
          mesh%hex_coord(2, global) = -j+1

          position_x1 = position_x1 - mesh%r2_x1
          position_x2 = position_x2 - mesh%r2_x2
       end do

       ! Fifth edge
       do j = 1, i ! following r1
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = -i+j-1
          mesh%hex_coord(2, global) = -i

          position_x1 = position_x1 + mesh%r1_x1
          position_x2 = position_x2 + mesh%r1_x2
       end do

       ! Sixth edge
       do j = 1, i ! following r3
          global = global + 1

          mesh%cartesian_coord(1, global) = position_x1
          mesh%cartesian_coord(2, global) = position_x2

          mesh%hex_coord(1, global) = j-1
          mesh%hex_coord(2, global) = -i+j-1

          position_x1 = position_x1 + mesh%r3_x1
          position_x2 = position_x2 + mesh%r3_x2
       end do
    end do

    ! Filling the global_indices table.
    do global = 1, mesh%num_pts_tot 

       k1 = mesh%hex_coord(1, global)
       k2 = mesh%hex_coord(2, global)

       ! in order to switch from hexa coordinates to the global index
       ! we need a routine that will compute a unique number index_tab
       ! from the hexa coordinates. this unique number will index the array
       ! global_indices which contains the numerotation

       call index_hex_to_global(mesh, k1, k2, index_tab)

       mesh%global_indices(index_tab)= global

    end do

    mesh%num_triangles = 6 * num_cells * num_cells
    SLL_ALLOCATE(mesh%center_cartesian_coord(2, mesh%num_triangles), ierr)
    SLL_ALLOCATE(mesh%center_index(2, mesh%num_pts_tot), ierr)
    ! we  compute the cartesian coordinates and the indices
    ! of the centers of the triangles of the mesh
    call init_center_points_triangle(mesh)


    ! if needed we can compute the cartesian coordinates and the indices
    ! of the edges' center of each triangle
    mesh%num_edges = 3 * num_cells * ( 3 * num_cells + 1 )

    TEST_PRESENCE_AND_ASSIGN_VAL( mesh, EXTRA_TABLES, EXTRA_TABLES, 0 )
    if (mesh%EXTRA_TABLES.eq.1) then
       SLL_ALLOCATE(mesh%edge_center_cartesian_coord(2, mesh%num_edges), ierr)
       SLL_ALLOCATE(mesh%edge_center_index(3, mesh%num_pts_tot), ierr)
       call init_edge_center_triangle(mesh)
    end if


    ! ----------------------------------------- END MATRICES INITIALIZATION
    ! ---------------------------------------------------------------------

  end subroutine initialize_hex_mesh_2d



  subroutine init_center_points_triangle(mesh)
    class(sll_hex_mesh_2d) :: mesh
    sll_int32          :: center_index, global
    sll_int32          :: k1, k2
    sll_real64         :: x1, x2, x3
    sll_real64         :: y1, y2, y3
    sll_real64         :: xx, yy, r1x1
    sll_real64         :: jacob, k1c, k2c
    logical            :: inside

    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2

    mesh%center_cartesian_coord(:,:)   = 0._f64
    mesh%center_index(:,:)             = -1

    center_index = 0

    r1x1 =  mesh%r1_x1*real(mesh%num_cells,f64)

    do global = 1, mesh%num_pts_tot
       ! almost each point is the base of a lozenge , thus two triangle
       ! from which we get two center points

       k1 = mesh%hex_coord(1, global)
       k2 = mesh%hex_coord(2, global)

       ! center point in the left triangle

       x1 = k1*mesh%r1_x1 + k2*mesh%r2_x1
       x2 = k1*mesh%r1_x1 + (k2+1)*mesh%r2_x1
       x3 = (k1+1)*mesh%r1_x1 + (k2+1)*mesh%r2_x1
       y1 = k1*mesh%r1_x2 + k2*mesh%r2_x2
       y2 = k1*mesh%r1_x2 + (k2+1)*mesh%r2_x2
       y3 = (k1+1)*mesh%r1_x2 + (k2+1)*mesh%r2_x2

       xx = x2 + ( (x3+x1)*0.5_f64 - x2 )* 2.0_f64 / 3.0_f64
       yy = y2 + ( (y3+y1)*0.5_f64 - y2 )* 2.0_f64 / 3.0_f64

       !test to check if the triangle on the left is inside

       inside = .true.

       k1c = (mesh%r2_x2 * xx - mesh%r2_x1 * yy)/jacob
       k2c = (mesh%r1_x1 * yy - mesh%r1_x2 * xx)/jacob

       if ( abs(k1c) >  mesh%num_cells ) inside = .false.
       if ( abs(k2c) >  mesh%num_cells ) inside = .false.
       if ( abs(xx) > r1x1 ) inside = .false.

       if ( inside ) then
          center_index = center_index + 1
          mesh%center_cartesian_coord(1,center_index) = xx
          mesh%center_cartesian_coord(2,center_index) = yy
          mesh%center_index(1, global) = center_index
       endif


       ! center point in the right triangle
       x1 = k1*mesh%r1_x1     + k2*mesh%r2_x1
       x2 = (k1+1)*mesh%r1_x1 + k2*mesh%r2_x1
       x3 = (k1+1)*mesh%r1_x1 + (k2+1)*mesh%r2_x1
       y1 = k1*mesh%r1_x2     + k2*mesh%r2_x2
       y2 = (k1+1)*mesh%r1_x2 + k2*mesh%r2_x2
       y3 = (k1+1)*mesh%r1_x2 + (k2+1)*mesh%r2_x2

       xx = x2 + ( (x3+x1)*0.5_f64 - x2 )* 2.0_f64 / 3.0_f64
       yy = y2 + ( (y3+y1)*0.5_f64 - y2 )* 2.0_f64 / 3.0_f64

       ! test to check if the triangle on the left is inside

       inside = .true.


       k1c = (mesh%r2_x2 * xx - mesh%r2_x1 * yy)/jacob
       k2c = (mesh%r1_x1 * yy - mesh%r1_x2 * xx)/jacob

       if ( abs(k1c) >  mesh%num_cells ) inside = .false.
       if ( abs(k2c) >  mesh%num_cells ) inside = .false.
       if ( abs(xx) > r1x1 ) inside = .false.

       if ( inside ) then
          center_index = center_index + 1
          mesh%center_cartesian_coord(1,center_index) = xx
          mesh%center_cartesian_coord(2,center_index) = yy
          mesh%center_index(2, global) = center_index
       endif

    enddo

  end subroutine init_center_points_triangle



  subroutine init_edge_center_triangle(mesh)
    class(sll_hex_mesh_2d) :: mesh
    sll_int32          :: edge_index
    sll_int32          :: global, num_cells
    sll_int32          :: k1, k2, k1c, k2c
    sll_real64         :: x1, x2_l,x2_r, x3, y1, y2_l, y2_r, y3, xx, yy
    logical            :: inside

    num_cells = mesh%num_cells

    mesh%edge_center_cartesian_coord(:,:)   = 0._f64
    mesh%edge_center_index(:,:)             = -1
    edge_index = 0

    do global = 1, mesh%num_pts_tot
       ! almost each point is the base of a lozenge , thus two triangle
       ! from which we get two center points

       k1 = mesh%hex_coord(1, global)
       k2 = mesh%hex_coord(2, global)

       x1   = real(k1,f64)*mesh%r1_x1 + real(k2,f64)*mesh%r2_x1
       x2_l = real(k1,f64)*mesh%r1_x1 + real((k2+1),f64)*mesh%r2_x1
       x2_r = real((k1+1),f64)*mesh%r1_x1 + real(k2,f64)*mesh%r2_x1
       x3   = real((k1+1),f64)*mesh%r1_x1 + real((k2+1),f64)*mesh%r2_x1
       y1   = real(k1,f64)*mesh%r1_x2 + real(k2,f64)*mesh%r2_x2
       y2_l = real(k1,f64)*mesh%r1_x2 + real((k2+1),f64)*mesh%r2_x2
       y2_r = real((k1+1),f64)*mesh%r1_x2 + real(k2,f64)*mesh%r2_x2
       y3   = real((k1+1),f64)*mesh%r1_x2 + real((k2+1),f64)*mesh%r2_x2

       !test to check if the left edge is inside

       inside = .true.

       k1c = k1
       k2c = k2 + 1

       if ( abs(k1c) > num_cells .or. abs(k2c) > num_cells .or. &
            (k1c)*(k2c)<0 .and.( abs(k1c)+abs(k2c) > num_cells) ) inside=.false.

       if ( inside ) then
          ! center point of the left edge
          xx = (x1+x2_l)*0.5_f64
          yy = (y1+y2_l)*0.5_f64
          edge_index = edge_index + 1
          mesh%edge_center_cartesian_coord(1,edge_index) = xx
          mesh%edge_center_cartesian_coord(2,edge_index) = yy
          mesh%edge_center_index(1, global) = edge_index
       endif


       !test to check if the middle edge is inside

       inside = .true.

       k1c = k1 + 1
       k2c = k2 + 1

       if ( abs(k1c) > num_cells .or. abs(k2c) > num_cells .or. &
           (k1c)*(k2c)<0 .and.( abs(k1c)+abs(k2c) > num_cells) ) inside=.false.

       if ( inside ) then
          ! center point of the middle edge
          xx = (x1+x3)*0.5_f64
          yy = (y1+y3)*0.5_f64
          edge_index = edge_index + 1
          mesh%edge_center_cartesian_coord(1,edge_index) = xx
          mesh%edge_center_cartesian_coord(2,edge_index) = yy
          mesh%edge_center_index(2, global) = edge_index
       endif


       !test to check if the right edge is inside

       inside = .true.

       k1c = k1 + 1
       k2c = k2

       if ( abs(k1c) > num_cells .or. abs(k2c) > num_cells .or. &
            (k1c)*(k2c)<0 .and.( abs(k1c)+abs(k2c) > num_cells) ) inside=.false.

       if ( inside ) then
          ! center point of the right edge
          xx = (x1+x2_r)*0.5_f64
          yy = (y1+y2_r)*0.5_f64
          edge_index = edge_index + 1
          mesh%edge_center_cartesian_coord(1,edge_index) = xx
          mesh%edge_center_cartesian_coord(2,edge_index) = yy
          mesh%edge_center_index(3, global) = edge_index
       endif

    enddo


  end subroutine init_edge_center_triangle


  !> @brief Finds thex index in the global array of the point which
  !> coordinates where passed as parameter
  !> @details To every mesh point of associated hexagonal coordinates (k1,k2)
  !> we can associate a global index. This notation association can be
  !> accessed through an array initialized at the initialization of the object
  !> This function, computes the connectivity between the hexagonal mesh
  !> and the table.
  !> @param k1 integer denoting the first hexagonal coordinate of a point
  !> @param k2 integer denoting the second hexagonal coordinate of a point
  !> @param index_tab out integer denoting the index to get the global index of
  !> the point situated at (k1, k2)
  subroutine index_hex_to_global(mesh, k1, k2, index_tab)
    class(sll_hex_mesh_2d)     :: mesh
    sll_int32, intent(in)  :: k1, k2
    sll_int32, intent(out) :: index_tab
    sll_int32              :: k
    sll_int32              :: nk1, nk2
    sll_int32              :: n0
    sll_int32              :: num_cells
    sll_int32              :: num_cells_plus1

    num_cells = mesh%num_cells
    num_cells_plus1 = num_cells + 1

    ! nk1 is the number of points before the edge corresponding to k1
    ! nk2 is the number of points on the edge k1 :
    ! if k1<=0 the points are in [-num_cells,k2]
    ! if k1>0  ...               [-num_cells+k1,k2]

    if (k1.le.0) then
       k    = num_cells + k1
       !this value is always an integer, floor avoids the transformation
       nk1  = floor( num_cells*k + k*(k+1)*0.5 )
       nk2  = k2 + num_cells_plus1
    else
       ! n0 is the total number of points from (-num_cells,-num_cells) to
       ! ( 0, numcells)
       n0  = floor( num_cells**2 + num_cells*num_cells_plus1*0.5 )
       nk1 = n0 + k1*(2*num_cells + 1) - floor( k1*(k1-1)*0.5 )
       nk2 = k2 + num_cells_plus1 - k1
    endif

    index_tab = nk1 + nk2

  end subroutine index_hex_to_global


  !> @brief Computes the first coordinate of a given point
  !> @details Computes the first coordinate on the cartesian system 
  !> of a point which has for hexagonal coordinates (i,j)
  !> @param i integer denoting the first hexagonal coordinate of a point
  !> @param j integer denoting the second hexagonal coordinate of a point
  !> returns res real containing the coordinate "eta1"
  function eta1_node_hex(mesh, i, j) result(res)
    ! The coordinates (i, j) correspond to the (r1, r2) basis
    ! This function returns the 1st coordinate on the cartesian system
    class(sll_hex_mesh_2d), intent(in) :: mesh
    sll_int32, intent(in)  :: i
    sll_int32, intent(in)  :: j
    sll_real64 :: res

    res = mesh%r1_x1*i + mesh%r2_x1*j + mesh%center_x1
  end function eta1_node_hex

  !> @brief Computes the second coordinate of a given point
  !> @details Computes the second coordinate on the cartesian system 
  !> of a point which has for hexagonal coordinates (i,j)
  !> @param i integer denoting the first hexagonal coordinate of a point
  !> @param j integer denoting the second hexagonal coordinate of a point
  !> returns res real containing the coordinate "eta2"
  function eta2_node_hex(mesh, i, j) result(res)
    ! The coordinates (k1, k2) correspond to the (r1, r2) basis
    ! This function the 2nd coordinate on the cartesian system
    class(sll_hex_mesh_2d), intent(in)     :: mesh
    sll_int32, intent(in)  :: i
    sll_int32, intent(in)  :: j
    sll_real64  :: res

    res = mesh%r1_x2*i + mesh%r2_x2*j + mesh%center_x2
  end function eta2_node_hex


  function eta1_cell_hex(mesh, cell_num) result(res)
    ! The index num_ele corresponds to the index of triangle
    ! This function returns the 1st coordinate on the cartesian system
    ! of the center of the triangle at num_ele
    class(sll_hex_mesh_2d),intent(in)     :: mesh
    sll_int32, intent(in)      :: cell_num
    sll_real64 :: res

    res = mesh%center_cartesian_coord(1, cell_num)
  end function eta1_cell_hex

  function eta2_cell_hex(mesh, cell_num) result(res)
    ! The index num_ele corresponds to the index of triangle
    ! This function returns the 2nd coordinate on the cartesian system
    ! of the center of the triangle at num_ele
    class(sll_hex_mesh_2d),intent(in)     :: mesh
    sll_int32, intent(in)      :: cell_num
    sll_real64 :: res

    res = mesh%center_cartesian_coord(2, cell_num)
  end function eta2_cell_hex


  function eta1_cell_hex_two_arg(mesh, i, j) result(res)
    class(sll_hex_mesh_2d),intent(in)     :: mesh
    sll_int32, intent(in)      :: i, j
    sll_real64 :: res

    res = 0.0_f64
    print *, "Error : eta1_cell for a hexagonal mesh only works with ONE parameter (num_cell)"
    STOP
  end function eta1_cell_hex_two_arg

  function eta2_cell_hex_two_arg(mesh, i, j) result(res)
    class(sll_hex_mesh_2d),intent(in)     :: mesh
    sll_int32, intent(in)      :: i, j
    sll_real64 :: res

    res = 0.0_f64
    print *, "Error : eta2_cell for a hexagonal mesh only works with ONE parameter (num_cell)"
    STOP
  end function eta2_cell_hex_two_arg


  function cells_to_origin(k1, k2) result(val)
    ! Takes the coordinates (k1,k2) on the (r1,r2) basis and 
    ! returns the number of cells between that point and
    ! the origin. If (k1, k2) = 0, val = 0
    sll_int32, intent(in)   :: k1
    sll_int32, intent(in)   :: k2
    sll_int32               :: val

    ! We compute the number of cells from point to center 
    if (k1*k2 .gt. 0) then
       val = max(abs(k1),abs(k2))
    else
       val = abs(k1) + abs(k2)
    end if

  end function cells_to_origin


  function hex_to_global(mesh, k1, k2) result(val)
    ! Takes the coordinates (k1,k2) on the (r1,r2) basis and 
    ! returns global index of that mesh point.
    ! By default the index of the center of the mesh is 0
    ! Then following the r1 direction and a counter-clockwise motion
    ! we assing an index to every point of the mesh.
    class(sll_hex_mesh_2d)      :: mesh
    sll_int32, intent(in)   :: k1
    sll_int32, intent(in)   :: k2
    sll_int32               :: distance
    sll_int32               :: index_tab
    sll_int32               :: val
    
    distance = cells_to_origin(k1,k2)

    ! Test if we are in domain
    if (distance .le. mesh%num_cells) then

       call index_hex_to_global(mesh, k1, k2,index_tab)
       val = mesh%global_indices(index_tab)

    else
       val = -1
    end if

  end function hex_to_global


  function global_to_hex1(mesh, index) result(k1)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the first coordinate (k1) on the (r1,r2) basis 
    class(sll_hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: k1

    k1 = mesh%hex_coord(1,index)
  end function global_to_hex1

  function global_to_hex2(mesh, index) result(k2)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the second coordinate (k2) on the (r1,r2) basis 
    class(sll_hex_mesh_2d) :: mesh
    sll_int32 :: index
    sll_int32 :: k2

    k2 = mesh%hex_coord(2,index)
  end function global_to_hex2

  function global_to_x1(mesh, index) result(x1)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the first coordinate (x1) on the cartesian basis 
    class(sll_hex_mesh_2d) :: mesh
    sll_int32  :: index
    sll_real64 :: x1

    x1 = mesh%cartesian_coord(1, index)
  end function global_to_x1

  function global_to_x2(mesh, index) result(x2)
    ! Takes the global index of the point (see hex_to_global(...) for conventions)
    ! returns the second coordinate (x2) on the cartesian basis 
    class(sll_hex_mesh_2d) :: mesh
    sll_int32  :: index
    sll_real64 :: x2

    x2 = mesh%cartesian_coord(2, index)
  end function global_to_x2


  function cart_to_hex1(mesh, x1, x2) result(k1)
    ! Takes the coordinates (x1,x2) on the cartesian basis and 
    ! returns the first coordinate (k1) on the (r1, r2) basis
    class(sll_hex_mesh_2d) :: mesh
    sll_real64 :: x1
    sll_real64 :: x2
    sll_int32  :: k1
    sll_real64 :: jacob

    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
    k1 = floor((mesh%r2_x2 * x1 - mesh%r2_x1 * x2)/jacob)
  end function cart_to_hex1

  function cart_to_hex2(mesh, x1, x2) result(k2)
    ! Takes the coordinates (x1,x2) on the cartesian basis and 
    ! returns the second coordinate (k2) on the (r1, r2) basis
    class(sll_hex_mesh_2d) :: mesh
    sll_real64 :: x1
    sll_real64 :: x2
    sll_int32  :: k2
    sll_real64 :: jacob

    jacob = mesh%r1_x1 * mesh%r2_x2 - mesh%r2_x1 * mesh%r1_x2
    k2 = floor((mesh%r1_x1 * x2 - mesh%r1_x2 * x1)/jacob)
  end function cart_to_hex2

  function global_to_local(mesh, ref_index, global) result(local)
    ! In the same manner we assign global indices (see hex_to_global(...))
    ! we assign local indices, but this time the initial point is 
    ! the point which index is ref_index
    ! ie. local_index(i,i) = 1
    class(sll_hex_mesh_2d) :: mesh
    sll_int32 :: ref_index
    sll_int32 :: global
    sll_int32 :: k1_ref,  k2_ref
    sll_int32 :: k1_glob, k2_glob
    sll_int32 :: local

    if ((ref_index.le.mesh%num_pts_tot).and.(ref_index.gt.0) &
         .and.(global.le.mesh%num_pts_tot).and.(global.gt.0)) then

       k1_ref = mesh%global_to_hex1(ref_index)
       k2_ref = mesh%global_to_hex2(ref_index)
       k1_glob = mesh%global_to_hex1(global)
       k2_glob = mesh%global_to_hex2(global)

       local = mesh%hex_to_global(k1_ref - k1_glob, k2_ref - k2_glob)
    else
       ! Out of domain
       local = -1
    end if

  end function global_to_local


  function local_to_global(mesh, ref_index, local) result(global)
    ! returns the global index of the point which has as
    ! local index local_index in the ref_index system
    ! (see gloval_index(...) and global_to_local(...) for conventions) 
    ! ie. local_to_global(1, i) = i
    class(sll_hex_mesh_2d) :: mesh
    sll_int32 :: ref_index, local
    sll_int32 :: k1_ref, k2_ref
    sll_int32 :: k1_loc, k2_loc
    sll_int32 :: global

    if ((ref_index.le.mesh%num_pts_tot).and.(ref_index.gt.0) &
         .and.(local.le.mesh%num_pts_tot).and.(local.gt.0)) then
       k1_ref = mesh%global_to_hex1(ref_index)
       k2_ref = mesh%global_to_hex2(ref_index)
       k1_loc = mesh%global_to_hex1(local)
       k2_loc = mesh%global_to_hex2(local)

       global = mesh%hex_to_global(k1_ref + k1_loc, k2_ref + k2_loc) 
    else
       ! Out of domain
       global = -1
    end if

  end function local_to_global

  function local_hex_to_global(mesh, k1_ref, k2_ref, local) result(global)
    ! returns the global index of the point which has as
    ! local index local_index in the ref_index system
    ! (see gloval_index(...) and global_to_local(...) for conventions) 
    ! ie. local_to_global(1, i) = i
    class(sll_hex_mesh_2d) :: mesh
    sll_int32 :: k1_ref, k2_ref
    sll_int32 :: k1_loc, k2_loc
    sll_int32 :: local
    sll_int32 :: global


    k1_loc = mesh%global_to_hex1(local)
    k2_loc = mesh%global_to_hex2(local)
    
    if (cells_to_origin(k1_ref + k1_loc, k2_ref + k2_loc).lt.mesh%num_cells) then
       global = mesh%hex_to_global(k1_ref + k1_loc, k2_ref + k2_loc)
    else
       ! Out of domain
       global = -1
    end if

  end function local_hex_to_global


  subroutine get_cell_vertices_index( x, y, mesh, s1, s2, s3 )
    type(sll_hex_mesh_2d), pointer            :: mesh
    sll_real64, intent(in)                :: x, y
    sll_int32, intent(out)                :: s1, s2, s3
    sll_real64                            :: xi, radius, step
    sll_int32                             :: num_cells 
    sll_int32                             :: i, j

    num_cells = mesh%num_cells
    radius    = mesh%radius
    step      = mesh%delta

    ! converting (x,y) to hexagonal coordinates
    ! find the lowest point in the lozenge that contains (x,y)
    i = cart_to_hex1(mesh, x, y)
    j = cart_to_hex2(mesh, x, y)

    ! coordinates of the vertices of the lozenge : 
    !(/i,j/),(/i,j+1/),(/i+1,j/), (/i+1,j+1/)

    ! coordinate of the abscisse that parts the lozenge
    ! in two equilateral triangle

    xi = ( real(i,f64) - real(j,f64) ) * step * sll_sqrt3 * 0.5_f64

    ! testing which triangle (x,y) is in, which gives us its vertices'
    ! coordinates

    if ( x > xi ) then
       s1 = hex_to_global(mesh,i,j) 
       s2 = hex_to_global(mesh,i+1,j) 
       s3 = hex_to_global(mesh,i+1,j+1) 
    else if ( x < xi ) then
       s1 = hex_to_global(mesh,i,j) 
       s2 = hex_to_global(mesh,i,j+1)
       s3 = hex_to_global(mesh,i+1,j+1)
    else if ( x == xi ) then
       if (x < 0) then
          s1 = hex_to_global(mesh,i,j) 
          s2 = hex_to_global(mesh,i+1,j) 
          s3 = hex_to_global(mesh,i+1,j+1) 
       elseif (x >= 0) then
          s1 = hex_to_global(mesh,i,j)
          s2 = hex_to_global(mesh,i,j+1) 
          s3 = hex_to_global(mesh,i+1,j+1) 
       endif
    endif


  end subroutine get_cell_vertices_index


  subroutine get_triangle_index(k1,k2,mesh,x,triangle_index)
    type(sll_hex_mesh_2d), pointer :: mesh
    sll_real64, intent(in)     :: x !cartessian_abscisse_other_vertice
    sll_int32, intent(in)      :: k1, k2
    sll_int32, intent(out)     :: triangle_index
    sll_int32                  :: global

    ! almost every point is the lowest point of a lozenge , i.e. 2 triangles
    ! we get therefore 2 indices per points
    ! in order to have the correct one we test in which triangle we are 

    global = hex_to_global(mesh,k1,k2)

    if ( x < mesh%cartesian_coord(1,global) ) then
       triangle_index = mesh%center_index(1,global) !left triangle
    else
       triangle_index = mesh%center_index(2,global) !right triangle
    endif

    if (triangle_index == -1 ) print*, "problem in get_triangle_index at line",&
         __LINE__

  end subroutine get_triangle_index



  subroutine get_edge_index(k1,k2,mesh,x,edge_index1,edge_index2,edge_index3)
    type(sll_hex_mesh_2d), pointer :: mesh
    sll_real64, intent(in)     :: x !cartessian_abscisse_other_vertice
    sll_int32, intent(in)      :: k1, k2
    sll_int32, intent(out)     :: edge_index1,edge_index2,edge_index3
    sll_int32                  :: global, global2

    ! in short :
    ! returns the three indices of the edge  of the triangle which contains
    ! a point of abscisse x and which lowest vertex is of hexa. coordinate
    ! k1, k2
 
    ! almost every point is the lowest point of a lozenge , i.e. 3 edges
    ! we get therefore 3 indices per points
    ! but we want the three indices of the triangle which contains a point
    ! of abscisse x 
    ! we therefore test in which kind of triangle we are 
    ! ( oriented left or right ) then we get directly the indices of the first 
    ! two edges then we deduce from the kind of triangle which point is to the 
    ! left ( respectively to the right ) and get the index of the third edge

    global = hex_to_global(mesh,k1,k2)

    if ( x < mesh%cartesian_coord(1,global) ) then
       edge_index1 = mesh%edge_center_index(1,global)
       edge_index2 = mesh%edge_center_index(2,global)
       global2 = hex_to_global(mesh,k1,k2+1)
       edge_index3 = mesh%edge_center_index(3,global2)
    else
       edge_index1 = mesh%edge_center_index(3,global)
       edge_index2 = mesh%edge_center_index(2,global)
       global2 = hex_to_global(mesh,k1+1,k2)
       edge_index3 = mesh%edge_center_index(1,global2)
    endif

    if (edge_index1 == -1 ) print*, "problem in get_edge_index  l", __LINE__
    if (edge_index2 == -1 ) print*, "problem in get_edge_index  l", __LINE__
    if (edge_index3 == -1 ) print*, "problem in get_edge_index  l", __LINE__

  end subroutine get_edge_index


  subroutine display_hex_mesh_2d(mesh)
    ! Displays mesh information on the terminal
    class(sll_hex_mesh_2d), intent(in) :: mesh

    write(*,"(/,(a))") '2D mesh : num_cells   num_pts        center_x1       center_x2 &
         &       radius'
    write(*,"(10x,2(i6,9x),3(g13.3,1x))") mesh%num_cells,  &
         mesh%num_pts_tot,&
         mesh%center_x1,  &
         mesh%center_x2,  &
         mesh%radius
  end subroutine display_hex_mesh_2d


  subroutine write_hex_mesh_2d(mesh, name)
    ! Writes the mesh information in a file named "name"
    type(sll_hex_mesh_2d), pointer :: mesh
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: num_pts_tot
    sll_int32  :: k1, k2
    sll_int32, parameter :: out_unit=20

    open (unit=out_unit,file=name,action="write",status="replace")

    num_pts_tot = mesh%num_pts_tot

    ! Optional writing every mesh point and its cartesian coordinates :
    !    write(*,"(/,(a))") 'hex mesh : num_pnt    x1     x2'

    do i=1, num_pts_tot
       k1 = mesh%global_to_hex1(i)
       k2 = mesh%global_to_hex2(i)
       write (out_unit, "(3(i6,1x),2(g13.3,1x))") i,                &
            k1,                      &
            k2,                      &
            mesh%global_to_x1(i), &
            mesh%global_to_x2(i)
    end do

    close(out_unit)
  end subroutine write_hex_mesh_2d

  subroutine write_field_hex_mesh(mesh, field, name)
    ! Writes the points cartesian coordinates and
    ! field(vector) values in a file named "name"
    type(sll_hex_mesh_2d), pointer :: mesh
    sll_real64,dimension(:) :: field
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: num_pts_tot
    sll_real64 :: x1, x2
    sll_int32, parameter :: out_unit=20

    open (unit=out_unit,file=name,action="write",status="replace")

    num_pts_tot = mesh%num_pts_tot
    do i=1, num_pts_tot
       x1 = mesh%global_to_x1(i)
       x2 = mesh%global_to_x2(i)
       write (out_unit, "(3(g13.3,1x))") x1, &
            x2, &
            field(i)
    end do

    close(out_unit)
  end subroutine write_field_hex_mesh

  subroutine write_field_hex_mesh_xmf(mesh, field, name)
    ! Writes the points cartesian coordinates and
    ! field(vector) values in a file named "name"
    type(sll_hex_mesh_2d), pointer :: mesh
    sll_real64,dimension(:) :: field
    character(len=*) :: name
    sll_int32  :: i
    sll_int32  :: num_triangles
    sll_int32  :: num_pts_tot
    sll_int32  :: out_unit
    sll_real64, allocatable :: coor(:,:)
    sll_int32,  allocatable :: ntri(:,:)
    sll_int32  :: error
    sll_real64 :: x1, x2

    call sll_new_file_id(out_unit, error)

    num_pts_tot = mesh%num_pts_tot
    num_triangles = mesh%num_triangles
    SLL_ALLOCATE(coor(2,num_pts_tot),error)
    SLL_ALLOCATE(ntri(3,num_triangles),error)

    do i=1, num_pts_tot
       coor(1,i) = mesh%global_to_x1(i)
       coor(2,i) = mesh%global_to_x2(i)
    end do

    do i=1, num_triangles
       x1      = mesh%center_cartesian_coord(1, i)
       x2      = mesh%center_cartesian_coord(2, i)
       call get_cell_vertices_index( x1, x2, mesh, ntri(1,i), ntri(2,i), ntri(3,i))
    end do

    call write_tri_mesh_xmf(name, coor, ntri, num_pts_tot, num_triangles, field, 'values')

    close(out_unit)

  end subroutine write_field_hex_mesh_xmf


  subroutine write_hex_mesh_mtv(mesh, mtv_file)

    type(sll_hex_mesh_2d), pointer :: mesh
    sll_real64                 :: coor(2,mesh%num_pts_tot)
    sll_int32                  :: ntri(3,mesh%num_triangles)
    sll_real64                 :: x1
    sll_real64                 :: y1
    sll_int32                  :: is1
    sll_int32                  :: is2
    sll_int32                  :: is3
    character(len=*)           :: mtv_file
    sll_int32                  :: out_unit
    sll_int32                  :: error
    sll_int32                  :: i
    
    call sll_new_file_id(out_unit, error)

    open( out_unit, file=mtv_file)
    
    !--- Trace du maillage ---
    
    write(out_unit,"(a)")"$DATA=CURVE3D"
    write(out_unit,"(a)")"%equalscale=T"
    write(out_unit,"(a)")"%toplabel='Maillage' "
    
    do i = 1, mesh%num_triangles
    
       x1 = mesh%center_cartesian_coord(1, i)
       y1 = mesh%center_cartesian_coord(2, i)
    
       call get_cell_vertices_index( x1, y1, mesh, is1, is2, is3)
    
       ntri(1,i) = is1
       ntri(2,i) = is2
       ntri(3,i) = is3
    
       coor(1,is1) = mesh%global_to_x1(is1)
       coor(2,is1) = mesh%global_to_x2(is1)
       coor(1,is2) = mesh%global_to_x1(is2)
       coor(2,is2) = mesh%global_to_x2(is2)
       coor(1,is3) = mesh%global_to_x1(is3)
       coor(2,is3) = mesh%global_to_x2(is3)
    
       write(out_unit,"(3f10.5)")coor(:,ntri(1,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(2,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(3,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(1,i)),0.
       write(out_unit,*)
    
    end do
    
    !--- Numeros des noeuds et des triangles
    
    write(out_unit,"(a)")"$DATA=CURVE3D"
    write(out_unit,"(a)")"%equalscale=T"
    write(out_unit,"(a)")"%toplabel='Numeros des noeuds et des triangles' "
    
    do i = 1, mesh%num_triangles
       write(out_unit,"(3f10.5)")coor(:,ntri(1,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(2,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(3,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(1,i)),0.
       write(out_unit,*)
    end do
    
    do i = 1, mesh%num_triangles
       x1 = (  coor(1,ntri(1,i))  &
             + coor(1,ntri(2,i))  &
         + coor(1,ntri(3,i))    )/3.
       y1 = (  coor(2,ntri(1,i))  &
             + coor(2,ntri(2,i))  &
         + coor(2,ntri(3,i))    )/3.
       write(out_unit,"(a)"   , advance="no")"@text x1="
       write(out_unit,"(f8.5)", advance="no") x1
       write(out_unit,"(a)"   , advance="no")" y1="
       write(out_unit,"(f8.5)", advance="no") y1
       write(out_unit,"(a)"   , advance="no")" z1=0. lc=4 ll='"
       write(out_unit,"(i4)"  , advance="no") i
       write(out_unit,"(a)")"'"
    end do
    
    do i = 1, mesh%num_pts_tot
       x1 = coor(1,i)
       y1 = coor(2,i)
       write(out_unit,"(a)"   , advance="no")"@text x1="
       write(out_unit,"(g15.3)", advance="no") x1
       write(out_unit,"(a)"   , advance="no")" y1="
       write(out_unit,"(g15.3)", advance="no") y1
       write(out_unit,"(a)"   , advance="no")" z1=0. lc=5 ll='"
       write(out_unit,"(i4)"  , advance="no") i
       write(out_unit,"(a)")"'"
    end do
    
    !--- Numeros des noeuds 
    
    write(out_unit,*)"$DATA=CURVE3D"
    write(out_unit,*)"%equalscale=T"
    write(out_unit,*)"%toplabel='Numeros des noeuds' "
    
    do i = 1, mesh%num_triangles
       write(out_unit,"(3f10.5)")coor(:,ntri(1,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(2,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(3,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(1,i)),0.
       write(out_unit,*)
    end do
    
    do i = 1, mesh%num_pts_tot
       x1 = coor(1,i)
       y1 = coor(2,i)
       write(out_unit,"(a)"   , advance="no")"@text x1="
       write(out_unit,"(g15.3)", advance="no") x1
       write(out_unit,"(a)"   , advance="no")" y1="
       write(out_unit,"(g15.3)", advance="no") y1
       write(out_unit,"(a)"   , advance="no")" z1=0. lc=5 ll='"
       write(out_unit,"(i4)"  , advance="no") i
       write(out_unit,"(a)")"'"
    end do
    
    !--- Numeros des triangles
    
    write(out_unit,*)"$DATA=CURVE3D"
    write(out_unit,*)"%equalscale=T"
    write(out_unit,*)"%toplabel='Numeros des triangles' "
    
    do i = 1, mesh%num_triangles
       write(out_unit,"(3f10.5)")coor(:,ntri(1,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(2,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(3,i)),0.
       write(out_unit,"(3f10.5)")coor(:,ntri(1,i)),0.
       write(out_unit,*)
    end do
    
    do i = 1, mesh%num_triangles
       x1 = (  coor(1,ntri(1,i))  &
             + coor(1,ntri(2,i))  &
         + coor(1,ntri(3,i))    )/3.
       y1 = (  coor(2,ntri(1,i))  &
             + coor(2,ntri(2,i))  &
         + coor(2,ntri(3,i))    )/3.
       write(out_unit,"(a)"   , advance="no")"@text x1="
       write(out_unit,"(g15.3)", advance="no") x1
       write(out_unit,"(a)"   , advance="no")" y1="
       write(out_unit,"(g15.3)", advance="no") y1
       write(out_unit,"(a)"   , advance="no")" z1=0. lc=4 ll='"
       write(out_unit,"(i4)"  , advance="no") i
       write(out_unit,"(a)")"'"
    end do
    
    write(out_unit,*)"$END"
    close(out_unit)
   
end subroutine write_hex_mesh_mtv


subroutine delete_hex_mesh_2d( mesh )
  class(sll_hex_mesh_2d), intent(inout) :: mesh
  sll_int32 :: ierr

  SLL_DEALLOCATE(mesh%cartesian_coord, ierr)
  SLL_DEALLOCATE(mesh%hex_coord, ierr)
  SLL_DEALLOCATE(mesh%global_indices, ierr)
  if ( mesh%EXTRA_TABLES.eq.1) then
     SLL_DEALLOCATE(mesh%center_cartesian_coord, ierr)
     SLL_DEALLOCATE(mesh%center_index, ierr)
     SLL_DEALLOCATE(mesh%edge_center_cartesian_coord, ierr)
     SLL_DEALLOCATE(mesh%edge_center_index, ierr)
  end if

end subroutine delete_hex_mesh_2d


#undef TEST_PRESENCE_AND_ASSIGN_VAL

end module sll_hex_meshes
