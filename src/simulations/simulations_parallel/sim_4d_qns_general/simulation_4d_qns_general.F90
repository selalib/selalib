module sll_m_sim_4d_qns_general

#include "sll_working_precision.h"
#include "sll_assert.h"
#include "sll_memory.h"
#include "sll_field_2d.h"
#include "sll_utilities.h"

use sll_m_collective
use sll_m_interpolators_1d_base
use sll_m_cubic_spline_interpolator_1d
use sll_m_sim_base
use sll_m_parallel_array_initializer
use sll_m_gnuplot_parallel
use sll_m_general_coordinate_elliptic_solver
use sll_m_scalar_field_2d_base
use sll_m_scalar_field_2d
use sll_m_arbitrary_degree_spline_interpolator_2d
use sll_m_timer

implicit none

type, extends(sll_simulation_base_class) :: sll_simulation_4d_qns_general

  ! Parallel environment parameters
  sll_int32  :: world_size
  sll_int32  :: my_rank
  sll_int32  :: power2 ! 2^power2 = number of processes available
  ! Processor mesh sizes
  sll_int32  :: nproc_x1
  sll_int32  :: nproc_x2
  sll_int32  :: nproc_x3
  sll_int32  :: nproc_x4 
  ! Physics/numerical parameters
  sll_real64 :: dt
  sll_int32  :: num_iterations
  ! for QNS spline_degre in each direction
  sll_int32  :: spline_degree_eta1
  sll_int32  :: spline_degree_eta2
  ! the degree of interpolation in vx and vy
  sll_int32  :: spline_degree_vx
  sll_int32  :: spline_degree_vy
  ! for QNS boundary conditions
  sll_int32  :: bc_eta1_0
  sll_int32  :: bc_eta1_1
  sll_int32  :: bc_eta2_0
  sll_int32  :: bc_eta2_1
  sll_int32  :: bc_vx_0
  sll_int32  :: bc_vx_1
  sll_int32  :: bc_vy_0
  sll_int32  :: bc_vy_1
  ! the logical meshes are split in two one for space, one for velocity
  type(sll_cartesian_mesh_2d), pointer    :: mesh2d_x
  type(sll_cartesian_mesh_2d), pointer    :: mesh2d_v
  ! This simulation only applies a coordinate transformation to the spatial
  ! coordinates.
  class(sll_coordinate_transformation_2d_base), pointer :: transfx
  type(general_coordinate_elliptic_solver), pointer      :: qns

  !  number dignostics for the simulation
  sll_int32  ::number_diags

  !  type quadrature for solver in direction eta1 and eta2
  sll_int32 :: quadrature_type1,quadrature_type2 

  ! distribution functions. There are several because each array represents
  ! a differently shaped chunk of memory. In this example, each chunk 
  ! allows sequential operations in one given direction. f_x1x2 should 
  ! permit to carry out sequential operations in x1 and x2 for ex.
  sll_real64, dimension(:,:,:,:), pointer     :: f_x1x2 
  sll_real64, dimension(:,:,:,:), pointer     :: f_x3x4
  sll_real64, dimension(:,:,:), allocatable   :: partial_reduction
  sll_real64, dimension(:,:), pointer         :: rho_full 
  sll_real64, dimension(:,:), allocatable     :: rho_x2 
  sll_real64, dimension(:,:), allocatable     :: rho_split

  !--> diagnostics norm
  sll_real64, dimension(:),pointer :: diag_masse
  sll_real64, dimension(:),pointer :: diag_norm_L1
  sll_real64, dimension(:),pointer :: diag_norm_L2
  sll_real64, dimension(:),pointer :: diag_norm_Linf
  sll_real64, dimension(:),pointer :: diag_entropy_kin

  !--> diagnostics energydiag_nrj_kin
  sll_real64, dimension(:),pointer :: diag_nrj_kin
  sll_real64, dimension(:),pointer :: diag_nrj_pot
  sll_real64, dimension(:),pointer :: diag_nrj_tot

  !---> For diagnostic saving
  sll_int32 :: count_save_diag

  !---> To stocke the values of Jacobian in mesh points

  sll_real64,dimension(:,:,:,:),pointer :: values_jacobian_mat
  sll_real64,dimension(:,:),    pointer :: values_jacobian
  sll_real64,dimension(:,:,:,:),pointer :: values_jacobian_matinv
  sll_real64,dimension(:,:),pointer     :: point_x,point_y
  sll_real64,dimension(:,:), pointer    :: values_ex,values_ey

  ! ---> point mesh logical
  sll_real64,dimension(:),pointer :: pt_eta1
  sll_real64,dimension(:),pointer :: pt_eta2
  ! for remap
  type(layout_4D), pointer :: sequential_x1x2
  type(layout_4D), pointer :: sequential_x3x4
  type(layout_2D), pointer :: rho_full_layout
  type(layout_2D), pointer :: rho_seq_x2
  type(layout_2D), pointer :: split_rho_layout ! not sequential in any dir.
  type(remap_plan_2D_real64), pointer :: split_to_full
  type(remap_plan_2D_real64), pointer :: seqx1_to_seqx2
  ! remaps for the electric field data
  ! type(remap_plan_2D), pointer :: efld_split_to_seqx1
  type(remap_plan_2D_comp64), pointer :: efld_seqx1_to_seqx2
  type(remap_plan_2D_comp64), pointer :: efld_seqx2_to_split
  type(remap_plan_4D_real64), pointer :: seqx1x2_to_seqx3x4
  type(remap_plan_4D_real64), pointer :: seqx3x4_to_seqx1x2
  ! interpolators and their pointers
  !type(sll_cubic_spline_interpolator_2d) :: interp_x1x2
  type(sll_arbitrary_degree_spline_interpolator_2d) :: interp_x1x2
  type(sll_cubic_spline_interpolator_1d) :: interp_x3
  !type(sll_arbitrary_degree_spline_interpolator_1d) :: interp_x3
  type(sll_cubic_spline_interpolator_1d) :: interp_x4
  ! interpolation any arbitrary spline
  type(sll_arbitrary_degree_spline_interpolator_2d)     :: interp_rho
  type(sll_arbitrary_degree_spline_interpolator_2d)     :: interp_phi
  ! for distribution function initializer:
  procedure(sll_scalar_initializer_4d), nopass, pointer :: init_func
  sll_real64, dimension(:), pointer :: params
  ! for general coordinate QNS, analytical fields
  procedure(two_var_parametrizable_function),nopass,pointer :: a11_f
  procedure(two_var_parametrizable_function),nopass,pointer :: a12_f
  procedure(two_var_parametrizable_function),nopass,pointer :: a21_f
  procedure(two_var_parametrizable_function),nopass,pointer :: a22_f
  procedure(two_var_parametrizable_function),nopass,pointer :: b1_f
  procedure(two_var_parametrizable_function),nopass,pointer :: b2_f
  procedure(two_var_parametrizable_function),nopass,pointer :: der1_b1_f
  procedure(two_var_parametrizable_function),nopass,pointer :: der1_b2_f
  procedure(two_var_parametrizable_function),nopass,pointer :: der2_b1_f
  procedure(two_var_parametrizable_function),nopass,pointer :: der2_b2_f
  procedure(two_var_parametrizable_function),nopass,pointer :: c_f
  procedure(two_var_parametrizable_function),nopass,pointer :: elec_field_ext_1
  procedure(two_var_parametrizable_function),nopass,pointer :: elec_field_ext_2
  sll_real64, dimension(:), pointer :: a11_f_params
  sll_real64, dimension(:), pointer :: a12_f_params
  sll_real64, dimension(:), pointer :: a21_f_params
  sll_real64, dimension(:), pointer :: a22_f_params
  sll_real64, dimension(:), pointer :: b1_f_params
  sll_real64, dimension(:), pointer :: b2_f_params
  sll_real64, dimension(:), pointer :: c_f_params
  sll_real64, dimension(:), pointer :: elec_field_ext_f_params

contains

  procedure, pass(sim) :: run => run_4d_qns_general
  procedure, pass(sim) :: init_from_file => init_4d_qns_gen

end type sll_simulation_4d_qns_general

interface sll_delete
  module procedure delete_4d_qns_gen
end interface sll_delete

interface initialize
  module procedure initialize_4d_qns_general
end interface initialize

contains

! Tentative function to initialize the simulation object 'manually'.
subroutine initialize_4d_qns_general( sim,                    &
&                                     transformation_x,       &
&                                     init_func,              &
&                                     params,                 &
&                                     a11_f, a11_f_params,    &
&                                     a12_f, a12_f_params,    &
&                                     a21_f, a21_f_params,    &
&                                     a22_f, a22_f_params,    &
&                                     b1_f,  b1_f_params,     &
&                                     der1_b1_f, der2_b1_f,   &
&                                     b2_f,  b2_f_params,     &
&                                     der1_b2_f, der2_b2_f,   &
&                                     c_f, c_f_params,        &
&                                     quadrature_type1,       &
&                                     quadrature_type2,       &
&                                     electric_field_ext_1,   &
&                                     electric_field_ext_2,   &
&                                     elec_field_ext_f_params,&
&                                     number_diags)
    
type(sll_simulation_4d_qns_general), intent(inout)    :: sim
type(sll_cartesian_mesh_2d), pointer                  :: mesh2d_x
type(sll_cartesian_mesh_2d), pointer                  :: mesh2d_v
class(sll_coordinate_transformation_2d_base), pointer :: transformation_x
procedure(sll_scalar_initializer_4d)                  :: init_func
sll_real64, dimension(:), target                      :: params
procedure(two_var_parametrizable_function)            :: a11_f
procedure(two_var_parametrizable_function)            :: a12_f
procedure(two_var_parametrizable_function)            :: a21_f
procedure(two_var_parametrizable_function)            :: a22_f
procedure(two_var_parametrizable_function)            :: b1_f
procedure(two_var_parametrizable_function)            :: b2_f
procedure(two_var_parametrizable_function)            :: der1_b1_f
procedure(two_var_parametrizable_function)            :: der1_b2_f
procedure(two_var_parametrizable_function)            :: der2_b1_f
procedure(two_var_parametrizable_function)            :: der2_b2_f
procedure(two_var_parametrizable_function)            :: c_f
procedure(two_var_parametrizable_function)            :: electric_field_ext_1
procedure(two_var_parametrizable_function)            :: electric_field_ext_2
sll_real64, dimension(:), intent(in)                  :: a11_f_params
sll_real64, dimension(:), intent(in)                  :: a12_f_params
sll_real64, dimension(:), intent(in)                  :: a21_f_params
sll_real64, dimension(:), intent(in)                  :: a22_f_params
sll_real64, dimension(:), intent(in)                  :: b1_f_params
sll_real64, dimension(:), intent(in)                  :: b2_f_params
sll_real64, dimension(:), intent(in)                  :: c_f_params
sll_real64, dimension(:), intent(in)                  :: elec_field_ext_f_params
sll_int32                                             :: spline_degre_eta1
sll_int32                                             :: spline_degre_eta2
sll_int32                                             :: spline_degre_vx
sll_int32                                             :: spline_degre_vy
sll_int32                                             :: number_diags
sll_int32                                             :: bc_eta1_0
sll_int32                                             :: bc_eta1_1
sll_int32                                             :: bc_eta2_0
sll_int32                                             :: bc_eta2_1
sll_int32                                             :: bc_vx_0
sll_int32                                             :: bc_vx_1
sll_int32                                             :: bc_vy_0
sll_int32                                             :: bc_vy_1
sll_int32                                             :: quadrature_type1
sll_int32                                             :: quadrature_type2
sll_int32 :: ierr
    
sim%transfx    => transformation_x
sim%init_func  => init_func
sim%params     => params
sim%a11_f      => a11_f
sim%a12_f      => a12_f
sim%a21_f      => a21_f
sim%a22_f      => a22_f
sim%b1_f       => b1_f
sim%b2_f       => b2_f
sim%der1_b1_f  => der1_b1_f
sim%der1_b2_f  => der1_b2_f
sim%der2_b1_f  => der2_b1_f
sim%der2_b2_f  => der2_b2_f
sim%c_f        => c_f

sim%number_diags     = number_diags
sim%quadrature_type1 = quadrature_type1
sim%quadrature_type2 = quadrature_type2
sim%count_save_diag  = 0

sim%elec_field_ext_1 => electric_field_ext_1
sim%elec_field_ext_2 => electric_field_ext_2

SLL_ALLOCATE(sim%a11_f_params(size(a11_f_params)),ierr)
SLL_ALLOCATE(sim%a12_f_params(size(a12_f_params)),ierr)
SLL_ALLOCATE(sim%a21_f_params(size(a21_f_params)),ierr)
SLL_ALLOCATE(sim%a22_f_params(size(a22_f_params)),ierr)
SLL_ALLOCATE(sim%b1_f_params(size(b1_f_params)),ierr)
SLL_ALLOCATE(sim%b2_f_params(size(b2_f_params)),ierr)
SLL_ALLOCATE(sim%c_f_params(size(c_f_params)),ierr)
SLL_ALLOCATE(sim%elec_field_ext_f_params(size(elec_field_ext_f_params)),ierr)

sim%a11_f_params(:) = a11_f_params
sim%a12_f_params(:) = a12_f_params
sim%a21_f_params(:) = a21_f_params
sim%a22_f_params(:) = a22_f_params
sim%b1_f_params(:)  = b1_f_params
sim%b2_f_params(:)  = b2_f_params
sim%c_f_params(:)   = c_f_params
sim%elec_field_ext_f_params(:) = elec_field_ext_f_params

call sim%interp_phi%initialize(  &
     sim%mesh2d_x%num_cells1 +1, &
     sim%mesh2d_x%num_cells2 +1, &
     sim%mesh2d_x%eta1_min,      &
     sim%mesh2d_x%eta1_max,      &
     sim%mesh2d_x%eta2_min,      &
     sim%mesh2d_x%eta2_max,      &
     sim%bc_eta1_0,              &
     sim%bc_eta1_1,              &
     sim%bc_eta2_0,              &
     sim%bc_eta2_1,              &
     sim%spline_degree_eta1,     &
     sim%spline_degree_eta2)

call sim%interp_rho%initialize(  &
     sim%mesh2d_x%num_cells1 +1, &
     sim%mesh2d_x%num_cells2 +1, &
     sim%mesh2d_x%eta1_min,      &
     sim%mesh2d_x%eta1_max,      &
     sim%mesh2d_x%eta2_min,      &
     sim%mesh2d_x%eta2_max,      &
     sim%bc_eta1_0,              &
     sim%bc_eta1_1,              &
     sim%bc_eta2_0,              &
     sim%bc_eta2_1,              &
     sim%spline_degree_eta1,     &
     sim%spline_degree_eta2)

SLL_ALLOCATE(sim%values_jacobian_mat(sim%mesh2d_x%num_cells1+1,sim%mesh2d_x%num_cells2 +1,2,2),ierr)
sim%values_jacobian_mat(:,:,:,:) = 0.0_f64
SLL_ALLOCATE(sim%values_jacobian_matinv(sim%mesh2d_x%num_cells1+1,sim%mesh2d_x%num_cells2 +1,2,2),ierr)
sim%values_jacobian_matinv(:,:,:,:) = 0.0_f64
SLL_ALLOCATE(sim%values_jacobian(sim%mesh2d_x%num_cells1+1,sim%mesh2d_x%num_cells2 +1),ierr)
sim%values_jacobian(:,:) = 0.0_f64
SLL_ALLOCATE(sim%pt_eta1(sim%mesh2d_x%num_cells1+1),ierr)
SLL_ALLOCATE(sim%pt_eta2(sim%mesh2d_x%num_cells2+1),ierr)
SLL_ALLOCATE(sim%point_x(sim%mesh2d_x%num_cells1+1,sim%mesh2d_x%num_cells2+1),ierr)
SLL_ALLOCATE(sim%point_y(sim%mesh2d_x%num_cells1+1,sim%mesh2d_x%num_cells2+1),ierr)
SLL_ALLOCATE(sim%values_ex(sim%mesh2d_x%num_cells1+1,sim%mesh2d_x%num_cells2+1),ierr)
sim%values_ex = 0.0_f64
SLL_ALLOCATE(sim%values_ey(sim%mesh2d_x%num_cells1 +1,sim%mesh2d_x%num_cells2+1),ierr)
sim%values_ey = 0.0_f64

end subroutine initialize_4d_qns_general

subroutine init_4d_qns_gen( sim, filename )

class(sll_simulation_4d_qns_general), intent(inout) :: sim
character(len=*), intent(in)                                   :: filename
sll_int32             :: IO_stat
sll_real64            :: dt
sll_int32             :: number_iterations
sll_int32             :: num_cells_x1
sll_int32             :: num_cells_x2
sll_int32             :: num_cells_x3
sll_int32             :: num_cells_x4
sll_real64            :: eta1_min
sll_real64            :: eta1_max
sll_real64            :: eta2_min
sll_real64            :: eta2_max
sll_real64            :: vx_min
sll_real64            :: vx_max
sll_real64            :: vy_min
sll_real64            :: vy_max 
sll_int32             :: bc_eta1_0
sll_int32             :: bc_eta1_1
sll_int32             :: bc_eta2_0
sll_int32             :: bc_eta2_1
sll_int32             :: bc_vx_0
sll_int32             :: bc_vx_1
sll_int32             :: bc_vy_0
sll_int32             :: bc_vy_1
sll_real64            :: diag2D_step
sll_int32             :: deg_eta1
sll_int32             :: deg_eta2
sll_int32             :: deg_vx
sll_int32             :: deg_vy
sll_int32, parameter  :: input_file = 99

namelist /sim_params/ dt, number_iterations
namelist /grid_dims/ num_cells_x1, num_cells_x2, num_cells_x3, num_cells_x4
namelist /mesh_grid/eta1_min,eta1_max,eta2_min,eta2_max,vx_min,vx_max,vy_min,vy_max 
namelist /space_boundary_conditions/ bc_eta1_0,bc_eta1_1,bc_eta2_0,bc_eta2_1
namelist /velocity_boundary_conditions/ bc_vx_0, bc_vx_1,bc_vy_0, bc_vy_1
namelist /diagnostics/ diag2D_step
namelist /spline_degree/ deg_eta1, deg_eta2, deg_vx,deg_vy
! Try to add here other parameters to initialize the mesh values like
! xmin, xmax and also for the distribution function initializer.
open(unit = input_file, file=trim(filename),IOStat=IO_stat)
if( IO_stat /= 0 ) then
   print *, 'init_vp4d_par_cart() failed to open file ', filename
   STOP
end if
read(input_file,sim_params)
read(input_file,grid_dims)
read(input_file,mesh_grid)
read(input_file,space_boundary_conditions)
read(input_file,velocity_boundary_conditions)
read(input_file, diagnostics)
read(input_file,spline_degree)
close(input_file)

sim%dt = dt
sim%num_iterations = number_iterations
print*, 'number iterations', number_iterations

sim%mesh2d_x => new_cartesian_mesh_2d( num_cells_x1, num_cells_x2,  & 
     eta1_min= eta1_min, eta1_max= eta1_max, &
     eta2_min= eta2_min, eta2_max= eta2_max )

sim%mesh2d_v => new_cartesian_mesh_2d( num_cells_x3, num_cells_x4,  & 
     eta1_min= vx_min, eta1_max= vx_max, &
     eta2_min= vy_min, eta2_max= vy_max )

sim%bc_eta1_0  = bc_eta1_0
sim%bc_eta1_1  = bc_eta1_1
sim%bc_eta2_0  = bc_eta2_0
sim%bc_eta2_1  = bc_eta2_1

sim%bc_vx_0  = bc_vx_0
sim%bc_vx_1  = bc_vx_1
sim%bc_vy_0  = bc_vy_0
sim%bc_vy_1  = bc_vy_1

! diagnostics
!sim%diag2D_step = diag2D_step
! spline_degre
sim%spline_degree_eta1 = deg_eta1
sim%spline_degree_eta2 = deg_eta2
sim%spline_degree_vx   = deg_vx
sim%spline_degree_vy   = deg_vy

end subroutine init_4d_qns_gen

! Note that the following function has no local variables, which is silly...
! This just happened since the guts of the unit test were transplanted here
! directly, but this should be cleaned up.
subroutine run_4d_qns_general(sim)

class(sll_simulation_4d_qns_general), intent(inout) :: sim
sll_int32  :: loc_sz_x1
sll_int32  :: loc_sz_x2
sll_int32  :: loc_sz_x3
sll_int32  :: loc_sz_x4
sll_int32  :: i
sll_int32  :: j
sll_int32  :: k
sll_int32  :: l
sll_real64 :: vmin3
sll_real64 :: vmax3
sll_real64 :: vmin4
sll_real64 :: vmax4
sll_real64 :: delta1
sll_real64 :: delta2
sll_real64 :: delta3
sll_real64 :: delta4
sll_real64 :: alpha3
sll_real64 :: alpha4
sll_int32  :: itemp
sll_int32  :: ierr
sll_int32  :: itime
sll_int32  :: nc_x1
sll_int32  :: nc_x2
sll_int32  :: nc_x3
sll_int32  :: nc_x4
sll_real64 :: ex
sll_real64 :: ey
sll_real64 :: eta1
sll_real64 :: eta2
sll_real64 :: x
sll_real64 :: y
sll_real64 :: eta1_min
sll_real64 :: eta2_min
sll_real64 :: eta3_min
sll_real64 :: eta4_min
sll_real64 :: eta1_max
sll_real64 :: eta2_max
sll_real64 :: eta3_max
sll_real64 :: eta4_max
sll_real64, dimension(1:2,1:2) :: inv_j
sll_real64, dimension(1:2,1:2) :: jac_m
sll_real64 :: efield_energy_total

! The following could probably be abstracted for convenience
#define BUFFER_SIZE sim%number_diags
sll_real64, dimension(BUFFER_SIZE) :: buffer_energy
sll_real64, dimension(BUFFER_SIZE) :: buffer_energy_result
sll_real64, dimension(BUFFER_SIZE) :: num_particles_local
sll_real64, dimension(BUFFER_SIZE) :: num_particles_global
sll_real64 :: numpart
sll_int32 :: buffer_counter
sll_int32 :: efield_energy_file_id
sll_int32 :: num_particles_file_id
sll_int32 :: global_indices(4)
class(sll_scalar_field_2d_base), pointer              :: a11_field_mat
class(sll_scalar_field_2d_base), pointer              :: a21_field_mat
class(sll_scalar_field_2d_base), pointer              :: a12_field_mat
class(sll_scalar_field_2d_base), pointer              :: a22_field_mat
class(sll_scalar_field_2d_base), pointer              :: b1_field_vect
class(sll_scalar_field_2d_base), pointer              :: b2_field_vect
class(sll_scalar_field_2d_base), pointer              :: c_field
class(sll_scalar_field_2d_base), pointer              :: elec_field_ext_1
class(sll_scalar_field_2d_base), pointer              :: elec_field_ext_2
class(sll_scalar_field_2d_discrete), pointer      :: rho
type(sll_scalar_field_2d_discrete), pointer       :: phi
sll_real64, dimension(:), allocatable :: send_buf
sll_real64, dimension(:), allocatable :: recv_buf
sll_int32, dimension(:), allocatable  :: recv_sz
sll_real64, dimension(:,:), pointer :: phi_values
sll_int32  :: send_size   ! for allgatherv operation
sll_int32, dimension(:), allocatable :: disps ! for allgatherv operation
sll_int32 :: size_diag
sll_real64 :: time
type(sll_time_mark) :: t0    

nc_x1 = sim%mesh2d_x%num_cells1
nc_x2 = sim%mesh2d_x%num_cells2
nc_x3 = sim%mesh2d_v%num_cells1
nc_x4 = sim%mesh2d_v%num_cells2
delta1 = sim%mesh2d_x%delta_eta1
delta2 = sim%mesh2d_x%delta_eta2
delta3 = sim%mesh2d_v%delta_eta1
delta4 = sim%mesh2d_v%delta_eta2
eta1_min = sim%mesh2d_x%eta1_min
eta2_min = sim%mesh2d_x%eta2_min
eta3_min = sim%mesh2d_v%eta1_min
eta4_min = sim%mesh2d_v%eta2_min
eta1_max = sim%mesh2d_x%eta1_max
eta2_max = sim%mesh2d_x%eta2_max
eta3_max = sim%mesh2d_v%eta1_max
eta4_max = sim%mesh2d_v%eta2_max
! Carry out the 2D advection in the eta1-eta2 plane.
! dt in eta1 and eta2
vmin3  = sim%mesh2d_v%eta1_min
vmax3  = sim%mesh2d_v%eta1_max
vmin4  = sim%mesh2d_v%eta2_min
vmax4  = sim%mesh2d_v%eta2_max

! compute Jacobian and logical mesh points
call compute_values_jacobian_and_mesh_points(sim)
! Start with the fields

a11_field_mat => new_scalar_field_2d_analytic( sim%a11_f,      &
&                                              "a11",          &
&                                              sim%transfx,    &
&                                              sim%bc_eta1_0,  &
&                                              sim%bc_eta1_1,  &
&                                              sim%bc_eta2_0,  &
&                                              sim%bc_eta2_1,  &
&                                              sim%a11_f_params) 

a12_field_mat => new_scalar_field_2d_analytic( sim%a12_f,      &
&                                              "a12",          &
&                                              sim%transfx,    &
&                                              sim%bc_eta1_0,  &
&                                              sim%bc_eta1_1,  &
&                                              sim%bc_eta2_0,  &
&                                              sim%bc_eta2_1,  &
&                                              sim%a12_f_params) 

a21_field_mat => new_scalar_field_2d_analytic( sim%a21_f,      &
&                                              "a21",          &
&                                              sim%transfx,    &
&                                              sim%bc_eta1_0,  &
&                                              sim%bc_eta1_1,  &
&                                              sim%bc_eta2_0,  &
&                                              sim%bc_eta2_1,  &
&                                              sim%a21_f_params)

a22_field_mat => new_scalar_field_2d_analytic( sim%a22_f,      &
&                                              "a22",          &
&                                              sim%transfx,    &
&                                              sim%bc_eta1_0,  &
&                                              sim%bc_eta1_1,  &
&                                              sim%bc_eta2_0,  &
&                                              sim%bc_eta2_1,  &
&                                              sim%a22_f_params) 

b1_field_vect => new_scalar_field_2d_analytic( sim%b1_f,       &
&                                              "b1",           &
&                                              sim%transfx,    &
&                                              sim%bc_eta1_0,  &
&                                              sim%bc_eta1_1,  &
&                                              sim%bc_eta2_0,  &
&                                              sim%bc_eta2_1,  &
&                                              sim%b1_f_params,&
&                                              sim%der1_b1_f,  &
&                                              sim%der2_b1_f)

b2_field_vect => new_scalar_field_2d_analytic( sim%b2_f,       &
&                                              "b2",           &
&                                              sim%transfx,    &
&                                              sim%bc_eta1_0,  &
&                                              sim%bc_eta1_1,  &
&                                              sim%bc_eta2_0,  &
&                                              sim%bc_eta2_1,  &
&                                              sim%b2_f_params,&
&                                              sim%der1_b2_f,  &
&                                              sim%der2_b2_f)


c_field => new_scalar_field_2d_analytic( sim%c_f,       &
&                                        "c_field",     &
&                                        sim%transfx,   &
&                                        sim%bc_eta1_0, &
&                                        sim%bc_eta1_1, &
&                                        sim%bc_eta2_0, &
&                                        sim%bc_eta2_1, &
&                                        sim%c_f_params)

elec_field_ext_1 => new_scalar_field_2d_analytic( sim%elec_field_ext_1, &
&                                                 "E1_ext",             &
&                                                 sim%transfx,          &
&                                                 sim%bc_eta1_0,        &
&                                                 sim%bc_eta1_1,        &
&                                                 sim%bc_eta2_0,        &
&                                                 sim%bc_eta2_1,        &
&                                                 sim%elec_field_ext_f_params )

elec_field_ext_2 => new_scalar_field_2d_analytic( sim%elec_field_ext_2, &
&                                                 "E2_ext",             &
&                                                 sim%transfx,          &
&                                                 sim%bc_eta1_0,        &
&                                                 sim%bc_eta1_1,        &
&                                                 sim%bc_eta2_0,        &
&                                                 sim%bc_eta2_1,        &
&                                                 sim%elec_field_ext_f_params )


SLL_ALLOCATE(phi_values(nc_x1+1,nc_x2+1),ierr)
phi_values(:,:) = 0.0_f64

phi => new_scalar_field_2d_discrete( "phi_check",    &
&                                    sim%interp_phi, &
&                                    sim%transfx,    &
&                                    sim%bc_eta1_0,  &
&                                    sim%bc_eta1_1,  &
&                                    sim%bc_eta2_0,  &
&                                    sim%bc_eta2_1)

call phi%set_field_data( phi_values )
call phi%update_interpolation_coefficients( )

buffer_counter = 1

sim%world_size = sll_get_collective_size(sll_world_collective)
sim%my_rank    = sll_get_collective_rank(sll_world_collective)

SLL_ALLOCATE(recv_sz(sim%world_size),ierr)
SLL_ALLOCATE(disps(sim%world_size),ierr)

if( sim%my_rank == 0 ) then
  call sll_new_file_id( efield_energy_file_id, ierr )
  if( ierr == 1 ) then
    print *, 'sll_new_file_id() failed to obtain a file identifier.', &
         ' Exiting...'
    stop
  end if
end if

if( sim%my_rank == 0 ) then
  call sll_new_file_id( num_particles_file_id, ierr )
  if( ierr == 1 ) then
    print *, 'sll_new_file_id() failed to obtain a file identifier.', &
         ' Exiting...'
    stop
  end if
end if

sim%sequential_x1x2  => new_layout_4D( sll_world_collective )
sim%sequential_x3x4  => new_layout_4D( sll_world_collective )
sim%rho_full_layout  => new_layout_2D( sll_world_collective )
sim%rho_seq_x2       => new_layout_2D( sll_world_collective )
sim%split_rho_layout => new_layout_2D( sll_world_collective )

!--> Initialization diagnostics for the norm
size_diag  =  int(sim%num_iterations/BUFFER_SIZE) + 1
SLL_ALLOCATE(sim%diag_masse(size_diag),ierr)
SLL_ALLOCATE(sim%diag_norm_L1(size_diag),ierr)
SLL_ALLOCATE(sim%diag_norm_L2(size_diag),ierr)
SLL_ALLOCATE(sim%diag_norm_Linf(size_diag),ierr)
SLL_ALLOCATE(sim%diag_entropy_kin(size_diag),ierr)

!--> Initialization diagnostics for the energy
SLL_ALLOCATE(sim%diag_nrj_kin(size_diag),ierr)
SLL_ALLOCATE(sim%diag_nrj_pot(size_diag),ierr)
SLL_ALLOCATE(sim%diag_nrj_tot(size_diag),ierr)

! layout for sequential operations in x3 and x4. Make an even split for
! x1 and x2, or as close as even if the power of 2 is odd. This should 
! be packaged in some sort of routine and set up at initialization time.
sim%power2 = int(log(real(sim%world_size))/log(2.0))

! special case N = 1, so power2 = 0
if(sim%power2 == 0) then
  sim%nproc_x1 = 1
  sim%nproc_x2 = 1
  sim%nproc_x3 = 1
  sim%nproc_x4 = 1
end if

if(is_even(sim%power2)) then
  sim%nproc_x1 = 2**(sim%power2/2)
  sim%nproc_x2 = 2**(sim%power2/2)
  sim%nproc_x3 = 1
  sim%nproc_x4 = 1
else 
  sim%nproc_x1 = 2**((sim%power2-1)/2)
  sim%nproc_x2 = 2**((sim%power2+1)/2)
  sim%nproc_x3 = 1
  sim%nproc_x4 = 1
end if

! pad de initialize_layout_with_distributed_array different du cartesian L182

print *, 'sequential_x3x4 mode...'
! Use this information to initialize the layout that describes the result
! of computing rho. This layout is not useful to do sequential operations
! in any of the two available directions. We also initialize the other two
! layouts needed for both sequential operations on x1 and x2 in the 2D case.
call initialize_layout_with_distributed_array( &
     nc_x1+1, & ! changed from nc only
     nc_x2+1, & ! changed from nc only
     sim%nproc_x1, &
     sim%nproc_x2, &
     sim%split_rho_layout )

call compute_local_sizes( sim%split_rho_layout, loc_sz_x1, loc_sz_x2)
! This layout is also useful to represent the charge density array. Since
! this is a result of a local reduction on x3 and x4, the new layout is
! 2D but with the same dimensions of the process mesh in x1 and x2.
SLL_ALLOCATE(sim%rho_split(loc_sz_x1,loc_sz_x2),ierr)
SLL_ALLOCATE(send_buf(loc_sz_x1*loc_sz_x2), ierr)
    
SLL_ALLOCATE(sim%rho_full(nc_x1+1,nc_x2+1),ierr) ! changed from nc,nc
SLL_ALLOCATE(recv_buf((nc_x1+1)*(nc_x2+1)),ierr) !changed from nc, nc


call initialize_layout_with_distributed_array( nc_x1+1,      &
                                               nc_x2+1,      &
                                               nc_x3+1,      &
                                               nc_x4+1,      &
                                               sim%nproc_x1, &
                                               sim%nproc_x2, &
                                               sim%nproc_x3, &
                                               sim%nproc_x4, &
                                               sim%sequential_x3x4 )

print *, 'nproc_x1: ', sim%nproc_x1
print *, 'nproc_x2: ', sim%nproc_x2
print *, 'nproc_x3: ', sim%nproc_x3
print *, 'nproc_x4: ', sim%nproc_x4
    
call compute_local_sizes( sim%sequential_x3x4, &
                          loc_sz_x1,           &
                          loc_sz_x2,           &
                          loc_sz_x3,           &
                          loc_sz_x4 )
    
SLL_ALLOCATE(sim%f_x3x4(loc_sz_x1,loc_sz_x2,loc_sz_x3,loc_sz_x4),ierr)
SLL_ALLOCATE(sim%partial_reduction(loc_sz_x1,loc_sz_x2, loc_sz_x3),ierr)

itemp = sim%nproc_x3
sim%nproc_x3 = sim%nproc_x1
sim%nproc_x1 = itemp
! switch x2 and x4
itemp = sim%nproc_x4
sim%nproc_x4 = sim%nproc_x2 
sim%nproc_x2 = itemp

print *, 'sequential x1x2 mode...'
call initialize_layout_with_distributed_array( &
     nc_x1+1, & ! changed
     nc_x2+1, & ! changed
     nc_x3+1, &
     nc_x4+1, &
     sim%nproc_x1, &
     sim%nproc_x2, &
     sim%nproc_x3, &
     sim%nproc_x4, &
     sim%sequential_x1x2 )

! Allocate the array needed to store the local chunk of the distribution
! function data. First compute the local sizes. Since the remap operations
! are out-of-place, we will allocate four different arrays, one for each
! layout.
call compute_local_sizes( sim%sequential_x1x2, &
     loc_sz_x1, loc_sz_x2, loc_sz_x3, loc_sz_x4 )

SLL_ALLOCATE(sim%f_x1x2(loc_sz_x1,loc_sz_x2,loc_sz_x3,loc_sz_x4),ierr)
!    SLL_ALLOCATE(sim%phi_split(loc_sz_x3,loc_sz_x4),ierr)

call sll_set_time_mark(t0)  
call sll_4d_parallel_array_initializer( &
     sim%sequential_x3x4, &
     sim%mesh2d_x, &
     sim%mesh2d_v, &
     sim%f_x3x4, &
     sim%init_func, &
     sim%params, &
     transf_x1_x2=sim%transfx )

time =  sll_time_elapsed_since(t0)
print *, 'time to initialize distribution function: ', time
call sll_display(sim%mesh2d_x)
call sll_display(sim%mesh2d_v)

sim%rho_split(:,:) = 0.0_f64
! this only works because there is no transformation applied in the
! velocity space...
call compute_charge_density( &
     sim%mesh2d_x,           &
     sim%mesh2d_v,           &
     size(sim%f_x3x4,1),     &
     size(sim%f_x3x4,2),     &
     sim%f_x3x4,             &
     sim%partial_reduction,  &
     sim%rho_split )

global_indices(1:2) = local_to_global( sim%split_rho_layout, (/1, 1/) )

call sll_gnuplot_rect_2d_parallel( &
     sim%mesh2d_x%eta1_min,        &
     sim%mesh2d_x%delta_eta1,      &
     sim%mesh2d_x%eta2_min,        &
     sim%mesh2d_x%delta_eta2,      &
     size(sim%rho_split,1),        &
     size(sim%rho_split,2),        &
     sim%rho_split,                &
     "rho_split",                  &
     0,                            &
     ierr )

call load_buffer( sim%split_rho_layout, sim%rho_split, send_buf )
recv_sz(:) = receive_counts_array( sim%split_rho_layout, sim%world_size )
send_size = size(send_buf)

call compute_displacements_array( &
     sim%split_rho_layout, &
     sim%world_size, &
     disps )

call sll_collective_allgatherv_real64( &
     sll_world_collective, &
     send_buf, &
     send_size, &
     recv_sz, &
     disps, &
     recv_buf )

call unload_buffer(sim%split_rho_layout, recv_buf, sim%rho_full)
    
rho => new_scalar_field_2d_discrete( &
     "rho_field_check", &
     sim%interp_rho, &     
     sim%transfx, &
     sim%bc_eta1_0, &
     sim%bc_eta1_1, &
     sim%bc_eta2_0, &
     sim%bc_eta2_1)

call rho%set_field_data( sim%rho_full )
call rho%update_interpolation_coefficients( )

sim%seqx3x4_to_seqx1x2 => &
     NEW_REMAP_PLAN(sim%sequential_x3x4,sim%sequential_x1x2,sim%f_x3x4)

sim%seqx1x2_to_seqx3x4 => &
     NEW_REMAP_PLAN(sim%sequential_x1x2,sim%sequential_x3x4,sim%f_x1x2)

call apply_remap_4D( sim%seqx3x4_to_seqx1x2, sim%f_x3x4, sim%f_x1x2 )
call compute_local_sizes( sim%sequential_x1x2, &
     loc_sz_x1, &
     loc_sz_x2, &
     loc_sz_x3, &
     loc_sz_x4 )

! First dt/2 advection for eta1-eta2:

! compute the spline coefficients
! Start the interpolators... Watch out: the periodic case has equal number
! of cells than points. Is this properly handled by the interpolators??
! The interpolators need the number of points and always consider that
! num_cells = num_pts - 1. This is a possible source of confusion.

! endpoints are hardcoded because the logical mesh lives always on the 
! unit square. But with the more general logical meshes, this is not
! true anymore, so this should be changed to depend on the values stored
! in the logical grids.

call sim%interp_x1x2%initialize( &
&   sim%mesh2d_x%num_cells1 +1,  &
&   sim%mesh2d_x%num_cells2 +1,  &
&   sim%mesh2d_x%eta1_min,       &
&   sim%mesh2d_x%eta1_max,       &
&   sim%mesh2d_x%eta2_min,       &
&   sim%mesh2d_x%eta2_max,       &
&   sim%bc_eta1_0,               &
&   sim%bc_eta1_1,               &
&   sim%bc_eta2_0,               &
&   sim%bc_eta2_1,               &
&   sim%spline_degree_eta1,      &
&   sim%spline_degree_eta2)

call advection_x1x2(sim,0.5*sim%dt,1)

call sim%interp_x3%initialize( nc_x3+1, vmin3, vmax3, SLL_HERMITE)
    
call sim%interp_x4%initialize( nc_x4+1, &
     vmin4, &
     vmax4, &
    SLL_HERMITE)! sim%bc_vy_0)
 
sim%qns => new_general_elliptic_solver(sim%spline_degree_eta1,  & 
&                                      sim%spline_degree_eta2,  & 
&                                      sim%mesh2d_x%num_cells1, &
&                                      sim%mesh2d_x%num_cells2, &
&                                      sim%quadrature_type1,    & 
&                                      sim%quadrature_type2,    &
&                                      sim%bc_eta1_0,           &
&                                      sim%bc_eta1_1,           &
&                                      sim%bc_eta2_0,           &
&                                      sim%bc_eta2_1,           &
&                                      sim%mesh2d_x%eta1_min,   &  
&                                      sim%mesh2d_x%eta1_max,   & 
&                                      sim%mesh2d_x%eta2_min,   & 
&                                      sim%mesh2d_x%eta2_max )  

call factorize_mat_es( sim%qns,       & 
&                      a11_field_mat, &
&                      a12_field_mat, &
&                      a21_field_mat, &
&                      a22_field_mat, &
&                      b1_field_vect, &
&                      b2_field_vect, &
&                      c_field)

do itime=1,sim%num_iterations

  if(sim%my_rank == 0) then
     print *, 'Starting iteration ', itime, ' of ', sim%num_iterations
  end if
  ! The splitting scheme used here is meant to attain a dt^2 accuracy.
  ! We use:
  
  ! dt/2   in eta1 and eta2
  ! solve the poisson equation (this acts as a prediction step for E in 
  ! BSL)
  !
  ! dt in vx
  ! dt in vy
  ! dt/2   in eta1 and eta2

  ! Here we join the first and last steps in eta1 and eta2 and to one
  ! extra dt/2 step outside of the main loop:

  ! dt/2   in eta1 and eta2 (outside of loop)
  !
  ! in main loop:
  !
  ! solve the poisson equation (this acts as a prediction step for E in 
  ! BSL)
  !
  ! dt in vx
  ! dt in vy
  ! dt in eta1 and eta2

  ! Note: Since the Ex and Ey values are used separately, the proposed
  ! data structure is actually not good. These field values should be kept
  ! separate.

  call apply_remap_4D( sim%seqx1x2_to_seqx3x4, sim%f_x1x2, sim%f_x3x4 )
  
  call compute_local_sizes( &
       sim%sequential_x1x2, &
       loc_sz_x1,           &
       loc_sz_x2,           &
       loc_sz_x3,           &
       loc_sz_x4 )
  
  sim%rho_split(:,:) = 0.0_f64
  call compute_charge_density( &
       sim%mesh2d_x,           &
       sim%mesh2d_v,           &
       size(sim%f_x3x4,1),     &
       size(sim%f_x3x4,2),     &
       sim%f_x3x4,             &
       sim%partial_reduction,  &
       sim%rho_split )
  
  global_indices(1:2) =  &
       local_to_global( sim%split_rho_layout, (/1, 1/) )
  
  call sll_gnuplot_rect_2d_parallel( &
     sim%mesh2d_x%eta1_min+(global_indices(1)-1)*sim%mesh2d_x%delta_eta1, &
     sim%mesh2d_x%delta_eta1, &
     sim%mesh2d_x%eta2_min+(global_indices(2)-1)*sim%mesh2d_x%delta_eta2, &
     sim%mesh2d_x%delta_eta2, &
     size(sim%rho_split,1), &
     size(sim%rho_split,2), &
     sim%rho_split, &
     "rho_split", &
     itime, &
     ierr )
  
  call load_buffer( sim%split_rho_layout, sim%rho_split, send_buf )
  
  recv_sz(:) = receive_counts_array( sim%split_rho_layout, sim%world_size )
  
  call sll_collective_allgatherv( &
       sll_world_collective, &
       send_buf, &
       size(send_buf), &
       recv_sz, &
       disps, &
       recv_buf )
  
  call unload_buffer(sim%split_rho_layout, recv_buf, sim%rho_full)
  
  if(sim%my_rank == 0) then
     call sll_gnuplot_rect_2d_parallel( &
          sim%mesh2d_x%eta1_min, &
          sim%mesh2d_x%delta_eta1, &
          sim%mesh2d_x%eta2_min, &
          sim%mesh2d_x%delta_eta2, &
          size(sim%rho_full,1), &
          size(sim%rho_full,2), &
          sim%rho_full, &
          "rho_full_check", &
          itime, &
          ierr )
  end if

  ! the rho field has a pointer to sim%rho_full so it is already 
  ! 'aware' that the data has changed. However, the interpolation
  ! coefficients are out of date.
  !
  ! It should be seriously considered to modify the interpolators
  ! in such a way that they always carry a pointer to the data to 
  ! be interpolated. In such case we would need:
  ! - a routine to (re-)set this pointer to the data
  ! - a change of the compute_coefficients interface to set the
  !   data parameter as optional...
      
  call rho%set_field_data(sim%rho_full)
  call rho%update_interpolation_coefficients( )
       
  ! It is important to remember a particular property of the periodic 
  ! poisson solver used here: For a given input charge density 
  ! configuration, there is an infinite number of solutions for the 
  ! potential, all differing by a constant. By design, the solver will
  ! return the solution with ZERO-MEAN. This implies that if given as
  ! input a uniform blob of charge, the solver will return a potential
  ! field with value equal to zero everywhere. In other words, the solver
  ! will only 'react' to nonuniform inputs.
  !
  ! The above is important when dealing with certain tests or certain
  ! model assumptions. For example in a Landau-damping test, one may
  ! want to apply a uniform neutralizing field for instance by adding or
  ! subtracting a constant value. This step becomes unnecessary since
  ! the answer returned by the solver will not be affected.
  !
  !    sim%rho_x1(:,:) = sim%rho_x1(:,:) - 1.0_f64  <--- unnecessary step
  
  ! solve for the electric potential
  ! but first adjust the sign of the source term (the sign should come
  ! automatically from the computation of the charge density, please fix)
  !       sim%rho_x1(:,:) = - sim%rho_x1(:,:) 
       
  call sll_solve( sim%qns, rho, phi )
  
  if(sim%my_rank == 0) then
    call phi%write_to_file(itime)
  end if
  
  call compute_local_sizes( sim%sequential_x1x2, &
       loc_sz_x1,           &
       loc_sz_x2,           &
       loc_sz_x3,           &
       loc_sz_x4 )
  
  call compute_local_sizes( sim%sequential_x3x4, &
       loc_sz_x1, loc_sz_x2, loc_sz_x3, loc_sz_x4 ) 
  
  efield_energy_total = 0.0_f64

  do l=1,loc_sz_x4 
    do j=1,loc_sz_x2
      do i=1,loc_sz_x1
        global_indices(1:2) = local_to_global( sim%split_rho_layout, (/i,j/))
        eta1 = sim%pt_eta1(global_indices(1))
        eta2 = sim%pt_eta2(global_indices(2))
        x    = sim%point_x(global_indices(1),global_indices(2))
        y    = sim%point_y(global_indices(1),global_indices(2))
        inv_j  =  sim%values_jacobian_matinv(global_indices(1),global_indices(2),:,:)
        jac_m  =  sim%values_jacobian_mat(global_indices(1),global_indices(2),:,:)
        
        ex     =  - phi%first_deriv_eta1_value_at_point(eta1,eta2)
        ey     =  - phi%first_deriv_eta2_value_at_point(eta1,eta2)
        sim%values_ex (global_indices(1),global_indices(2) ) = ex
        sim%values_ey (global_indices(1),global_indices(2) ) = ey
        
        alpha3 = -sim%dt*(inv_j(1,1)*ex + inv_j(2,1)*ey)
        alpha3 = alpha3 -sim%dt*(elec_field_ext_1%value_at_point(x,y) )

        sim%f_x3x4(i,j,:,l) = sim%interp_x3%interpolate_array_disp( &
             nc_x3+1, &
             sim%f_x3x4(i,j,:,l), &
             alpha3 )

        efield_energy_total = efield_energy_total + &
             delta1*delta2*&
             abs(sim%values_jacobian(global_indices(1),global_indices(2))) &
             *abs( ( inv_j(1,1) *inv_j(1,1) + inv_j(1,2)*inv_j(1,2))*ex**2 &
             +2* ( inv_j(1,1) *inv_j(2,1) + inv_j(1,2)*inv_j(2,2))*abs(ex)*abs(ey) &
             + ( inv_j(2,1)*inv_j(2,1)  + inv_j(2,2)*inv_j(2,2))*ey**2)
                
      end do
    end do
  end do
       
  call compute_local_sizes( sim%sequential_x3x4, &
            loc_sz_x1, loc_sz_x2, loc_sz_x3, loc_sz_x4 ) 
  numpart = 0.0_f64

  do j=1,loc_sz_x2
    do i=1,loc_sz_x1
      global_indices(1:2) = local_to_global( sim%split_rho_layout, (/i,j/))
      do k=1,sim%mesh2d_v%num_cells1+1
        eta1 = sim%pt_eta1(global_indices(1))
        eta2 = sim%pt_eta2(global_indices(2))
        x    = sim%point_x(global_indices(1),global_indices(2))
        y    = sim%point_y(global_indices(1),global_indices(2))
        inv_j  =  sim%values_jacobian_matinv(global_indices(1),global_indices(2),:,:)
        jac_m  =  sim%values_jacobian_mat(global_indices(1),global_indices(2),:,:)
        ex     =  sim%values_ex (global_indices(1),global_indices(2) ) 
        ey     =  sim%values_ey (global_indices(1),global_indices(2) ) !
        alpha4 = -sim%dt*(inv_j(1,2)*ex + inv_j(2,2)*ey)
        alpha4 = alpha4 -sim%dt*(elec_field_ext_2%value_at_point(x,y))
        sim%f_x3x4(i,j,k,:) = sim%interp_x4%interpolate_array_disp( &
             nc_x4+1, &
             sim%f_x3x4(i,j,k,:), &
             alpha4 )

      end do
      numpart = numpart + sum(sim%f_x3x4(i,j,:,:))*&
             abs(sim%values_jacobian(global_indices(1),global_indices(2)))
     end do
  end do

  call apply_remap_4D( sim%seqx3x4_to_seqx1x2, sim%f_x3x4, sim%f_x1x2 )
  
  call compute_local_sizes( sim%sequential_x1x2, &
       loc_sz_x1, loc_sz_x2, loc_sz_x3, loc_sz_x4 ) 
  
  ! Approximate the integral of the distribution function along all
  ! directions.
  num_particles_local(buffer_counter) = numpart*delta1*delta2*delta3*delta4
  buffer_energy(buffer_counter)       = efield_energy_total
      ! sum(sim%f_x3x4)*delta1*delta2*delta3*delta4
  if( buffer_counter == BUFFER_SIZE ) then
     ! ----------------------------------
     ! write particles buffer to disk 
     ! ----------------------------------
     num_particles_global = 0.0_f64
     call sll_collective_reduce_real64( &
          sll_world_collective, &
          num_particles_local, &
          BUFFER_SIZE, &
          MPI_SUM, &
          0, &
          num_particles_global )
     if(sim%my_rank == 0) then
        open(num_particles_file_id,file="number_particles",&
             position="append")
        if(itime == BUFFER_SIZE) then
           rewind(num_particles_file_id)
        end if
        do i=1,BUFFER_SIZE
           write(num_particles_file_id,*) num_particles_global(i)
        end do
        close(num_particles_file_id)
     end if
     
     ! ----------------------------------
     ! write electric field energy to disk 
     ! ----------------------------------
     buffer_energy_result = 0.0_f64
     call sll_collective_reduce_real64( sll_world_collective, &
                                        buffer_energy,        &
                                        BUFFER_SIZE,          &
                                        MPI_SUM,              &
                                        0,                    &
                                        buffer_energy_result )
     

      if(sim%my_rank == 0) then
        open(efield_energy_file_id,file="electric_field_energy_qns",&
             position="append")
        
        if(itime == BUFFER_SIZE) then
           rewind(efield_energy_file_id)
        end if
        buffer_energy_result(:) = log(sqrt(buffer_energy_result(:)))
        do i=1,BUFFER_SIZE
           write(efield_energy_file_id,*) buffer_energy_result(i)
        end do
        close(efield_energy_file_id)
     end if
     buffer_counter = 1

  else
     buffer_counter         = buffer_counter + 1
  end if
       
  ! Proceed to the advections in the spatial directions, 'x' and 'y'
  ! Reconfigure data. 
  
  ! what are the new local limits on x3 and x4? It is bothersome to have
  ! to make these calls...

  call advection_x1x2(sim,sim%dt,1) 

  if ( mod(itime,BUFFER_SIZE) == 0) then
    !--> Compute energy kinetic, potential and total
    call compute_energy_qns(sim,phi)
    
    !--> Compute L1 norm, L2 norm, L infini norm
    call compute_norm_L1_L2_Linf_qns(sim)
    
    !call writeHDF5_diag_qns( sim )
     
  end if
       
end do ! main loop

#undef BUFFER_SIZE
end subroutine run_4d_qns_general
  
subroutine advection_x1x2(sim,deltat,opt)
class(sll_simulation_4d_qns_general) :: sim
sll_real64, intent(in) :: deltat
sll_int32 :: gi, gj, gk, gl
sll_int32 :: loc_sz_x1, loc_sz_x2, loc_sz_x3, loc_sz_x4 
sll_int32, dimension(4) :: global_indices
sll_real64 :: alpha1, alpha2
sll_real64,dimension(2,2) :: inv_j,inv_j_tmp
sll_real64 :: eta1, eta2, eta3, eta4
sll_int32 :: i, j, k, l
sll_int32,intent(in) :: opt
sll_real64:: alpha1_tmp,alpha2_tmp,eta1_tmp,eta2_tmp

call compute_local_sizes( sim%sequential_x1x2, &
     loc_sz_x1, loc_sz_x2, loc_sz_x3, loc_sz_x4 )

do l=1,loc_sz_x4
  do k=1,loc_sz_x3
    call sim%interp_x1x2%compute_interpolants(sim%f_x1x2(:,:,k,l))
    do j=1,loc_sz_x2
      do i=1,loc_sz_x1
        global_indices = local_to_global(sim%sequential_x1x2,(/i,j,k,l/))
        gi = global_indices(1)
        gj = global_indices(2)
        gk = global_indices(3)
        gl = global_indices(4)
        eta1 = sim%pt_eta1(gi)
        eta2 = sim%pt_eta2(gj)
        eta3 = sim%mesh2d_v%eta1_min + (gk-1)*sim%mesh2d_v%delta_eta1
        eta4 = sim%mesh2d_v%eta2_min + (gl-1)*sim%mesh2d_v%delta_eta2
        inv_j  =  sim%values_jacobian_matinv(gi,gj,:,:) 
        if (opt .eq. 1) then !! euler explicit
          alpha1 = -deltat*(inv_j(1,1)*eta3 + inv_j(1,2)*eta4)
          alpha2 = -deltat*(inv_j(2,1)*eta3 + inv_j(2,2)*eta4)
        elseif ( opt .eq. 2) then! RK2
          alpha1_tmp = -deltat*(inv_j(1,1)*eta3 + inv_j(1,2)*eta4)
          alpha2_tmp = -deltat*(inv_j(2,1)*eta3 + inv_j(2,2)*eta4)
          eta1_tmp = eta1+alpha1_tmp
          eta2_tmp = eta2+alpha2_tmp
          inv_j_tmp(:,:) = sim%transfx%inverse_jacobian_matrix(eta1_tmp,eta2_tmp)
          alpha1 = -deltat/2.*( ( inv_j(1,1) + inv_j_tmp(1,1) ) *eta3 &
                              + ( inv_j(1,2) + inv_j_tmp(1,2) ) *eta4 )
          alpha2 = -deltat/2.*( ( inv_j(2,1) + inv_j_tmp(2,1) ) *eta3 &
                               + ( inv_j(2,2) + inv_j_tmp(2,2) ) *eta4 )
        end if
        eta1 = eta1+alpha1
        eta2 = eta2+alpha2
        ! This is hardwiring the periodic BC, please improve this..
        if ( sim%bc_eta1_0 == SLL_PERIODIC .and.&
             sim%bc_eta1_1 == SLL_PERIODIC .and.&
             sim%bc_eta2_0 == SLL_PERIODIC .and.&
             sim%bc_eta2_1 == SLL_PERIODIC) then
           
          ! PERIODIC TEST CASE.
          if( eta1 <  sim%mesh2d_x%eta1_min ) then
            eta1 = eta1+sim%mesh2d_x%eta1_max-sim%mesh2d_x%eta1_min
          else if( eta1 >  sim%mesh2d_x%eta1_max ) then
            eta1 = eta1+sim%mesh2d_x%eta1_min-sim%mesh2d_x%eta1_max
          end if
          if( eta2 <  sim%mesh2d_x%eta2_min ) then
            eta2 = eta2+sim%mesh2d_x%eta2_max-sim%mesh2d_x%eta2_min
          else if( eta2 >  sim%mesh2d_x%eta2_max ) then
            eta2 = eta2+sim%mesh2d_x%eta2_min-sim%mesh2d_x%eta2_max
          end if

          sim%f_x1x2(i,j,k,l) = sim%interp_x1x2%interpolate_value(eta1,eta2)

        else if (sim%bc_eta1_0 == SLL_PERIODIC  .and.&
             sim%bc_eta1_1 == SLL_PERIODIC  .and.&
             sim%bc_eta2_0 == SLL_DIRICHLET .and.&
             sim%bc_eta2_1 == SLL_DIRICHLET) then

          if( eta1 <  sim%mesh2d_x%eta1_min ) then
             eta1 = eta1+sim%mesh2d_x%eta1_max-sim%mesh2d_x%eta1_min
          else if( eta1 >  sim%mesh2d_x%eta1_max ) then
             eta1 = eta1+sim%mesh2d_x%eta1_min-sim%mesh2d_x%eta1_max
          end if
          if( eta2 <  sim%mesh2d_x%eta2_min ) then
             sim%f_x1x2(i,j,k,l) = 0.0_f64
          else if( eta2 >  sim%mesh2d_x%eta2_max ) then
             sim%f_x1x2(i,j,k,l) = 0.0_f64
          else
             sim%f_x1x2(i,j,k,l) = sim%interp_x1x2%interpolate_value(eta1,eta2)
          end if
              
        else if (sim%bc_eta1_0 == SLL_DIRICHLET .and.&
                 sim%bc_eta1_1 == SLL_DIRICHLET .and.&
                 sim%bc_eta2_0 == SLL_PERIODIC  .and.&
                 sim%bc_eta2_1 == SLL_PERIODIC) then

          if( eta2 <  sim%mesh2d_x%eta2_min ) then
             eta2 = eta2+sim%mesh2d_x%eta2_max-sim%mesh2d_x%eta2_min
          else if( eta2 >  sim%mesh2d_x%eta2_max ) then
             eta2 = eta2+sim%mesh2d_x%eta2_min-sim%mesh2d_x%eta2_max
          end if
          if( eta1 <  sim%mesh2d_x%eta1_min ) then
             sim%f_x1x2(i,j,k,l) = 0.0_f64
          else if( eta1 >  sim%mesh2d_x%eta1_max ) then
             sim%f_x1x2(i,j,k,l) = 0.0_f64
          else
             sim%f_x1x2(i,j,k,l) = sim%interp_x1x2%interpolate_value(eta1,eta2)
          end if

        else if (sim%bc_eta1_0 == SLL_DIRICHLET .and.&
                 sim%bc_eta1_1 == SLL_DIRICHLET .and.&
                 sim%bc_eta2_0 == SLL_DIRICHLET .and.&
                 sim%bc_eta2_1 == SLL_DIRICHLET) then
           
          if( eta2 < sim%mesh2d_x%eta2_min  .or.  &
              eta2 > sim%mesh2d_x%eta2_max  .or.  &
              eta1 < sim%mesh2d_x%eta1_min  .or.  &
              eta1 > sim%mesh2d_x%eta1_max ) then
            sim%f_x1x2(i,j,k,l) = 0.0_f64
          else
            sim%f_x1x2(i,j,k,l) = sim%interp_x1x2%interpolate_value(eta1,eta2)
          end if
        else 
          print*, 'problem boundary conditon for particles motions in eta2'
          stop
        end if
      end do
    end do
  end do
end do

end subroutine advection_x1x2

subroutine delete_4d_qns_gen( sim )
type(sll_simulation_4d_qns_general) :: sim
sll_int32 :: ierr

SLL_DEALLOCATE( sim%f_x1x2, ierr )
SLL_DEALLOCATE( sim%f_x3x4, ierr )
SLL_DEALLOCATE_ARRAY( sim%partial_reduction, ierr )
SLL_DEALLOCATE_ARRAY( sim%rho_full, ierr )
SLL_DEALLOCATE_ARRAY( sim%rho_x2, ierr )
SLL_DEALLOCATE_ARRAY( sim%rho_split, ierr )
SLL_DEALLOCATE(sim%values_ex ,ierr)
SLL_DEALLOCATE(sim%values_ey ,ierr)
call sll_delete( sim%sequential_x1x2 )
call sll_delete( sim%sequential_x3x4 )
call sll_delete( sim%rho_full_layout )
call sll_delete( sim%rho_seq_x2 )
call sll_delete( sim%split_rho_layout )
call sll_delete( sim%split_to_full )
call sll_delete( sim%efld_seqx1_to_seqx2 )
call sll_delete( sim%efld_seqx2_to_split )
call sll_delete( sim%seqx1x2_to_seqx3x4 )
call sll_delete( sim%seqx3x4_to_seqx1x2 )
call sll_delete( sim%interp_x1x2 )
call sll_delete( sim%interp_x3 )
call sll_delete( sim%interp_x4 )
SLL_DEALLOCATE(sim%diag_masse,ierr)
SLL_DEALLOCATE(sim%diag_norm_L1,ierr)
SLL_DEALLOCATE(sim%diag_norm_L2,ierr)
SLL_DEALLOCATE(sim%diag_norm_Linf,ierr)
SLL_DEALLOCATE(sim%diag_entropy_kin,ierr)
SLL_DEALLOCATE(sim%values_jacobian_mat,ierr)
SLL_DEALLOCATE(sim%values_jacobian_matinv,ierr)
SLL_DEALLOCATE(sim%values_jacobian,ierr)
SLL_DEALLOCATE(sim%point_x,ierr)
SLL_DEALLOCATE(sim%point_y,ierr)
SLL_DEALLOCATE(sim%pt_eta1,ierr)
SLL_DEALLOCATE(sim%pt_eta2,ierr)
SLL_DEALLOCATE(sim%diag_nrj_kin,ierr)
SLL_DEALLOCATE(sim%diag_nrj_pot,ierr)
SLL_DEALLOCATE(sim%diag_nrj_tot,ierr)
end subroutine delete_4d_qns_gen

! we put the reduction functions here for now, since we are only using
! simple data for the distribution function. This should go elsewhere.
! THIS SUBROUTINE IS JUST A PLACEHOLDER, IT IS NUMERICALLY INCORRECT.
! Change it later by something that uses some acceptable integrator in
! 1D.
! Design issues with this subroutine:
! 1. The distribution function needs to be preserved, thus this is an
!    out-of-place operation.
! 2. There is probably a cleverer way to do this, but if the reduction
!    happens in two steps a. reduction in x4 and b. reduction in x3, we
!    need an array to store the intermediate result (after reducing in
!    x4). This array should come as an argument.
subroutine compute_charge_density( &
  mx, &
  mv, &
  numpts1, &
  numpts2, &
  f, &
  partial, &
  rho )

  type(sll_cartesian_mesh_2d), pointer     :: mx
  type(sll_cartesian_mesh_2d), pointer     :: mv
  sll_int32, intent(in)                  :: numpts1
  sll_int32, intent(in)                  :: numpts2
  sll_real64, intent(in),  dimension(:,:,:,:) :: f       ! local distr. func
  sll_real64, intent(inout),  dimension(:,:,:):: partial ! intermediate res.
  sll_real64, intent(inout), dimension(:,:)     :: rho     ! local rho

  ! local sizes in the split directions have to be given by caller.
  sll_int32                       :: numpts3
  sll_int32                       :: numpts4
  sll_real64                      :: delta3
  sll_real64                      :: delta4
  sll_int32                       :: i, j, k, l
  
  numpts3 = mv%num_cells1+1
  numpts4 = mv%num_cells2+1
  delta3  = mv%delta_eta1
  delta4  = mv%delta_eta2

  partial(:,:,:) = 0.0

  ! This expects partial to be already initialized to zero!!!
  do k=1,numpts3
     do j=1,numpts2
        do i=1,numpts1
           ! This summation happens on a super-long stride... slow stuff
           ! This loop should be substituted by a proper integration
           ! function that we could use in the other directions as well...
           do l=1,numpts4
              partial(i,j,k) = partial(i,j,k) + f(i,j,k,l)*delta4
           end do
        end do
     end do
  end do

  ! Carry out the final reduction on x3. Note that rho is not initialized
  ! to zero since it may already have the partial charge accumulation from
  ! other species.

  do j=1,numpts2
     do i=1,numpts1
        do k=1,numpts3
           ! This summation happens on a very-long stride... slow stuff
           ! This loop should be substituted by a proper integration
           ! function that we could use in the other directions as well.
           ! See above reduction function for same problem.
           rho(i,j) = rho(i,j) + partial(i,j,k)*delta3
        end do
     end do
  end do

end subroutine compute_charge_density

! Some ad-hoc functions to prepare data for allgather operations. Should
! consider putting this elsewhere.

subroutine compute_displacements_array( layout, collective_size, disps )

type(layout_2D), pointer                           :: layout
sll_int32, intent(in)                              :: collective_size
sll_int32, dimension(collective_size), intent(out) :: disps
sll_int32 :: imin, imax
sll_int32 :: jmin, jmax
sll_int32 :: size_i, size_j
sll_int32 :: counter
sll_int32 :: rank

counter  = 0
disps(1) = counter
do rank=1,collective_size-1
   imin = get_layout_i_min( layout, rank-1 )
   imax = get_layout_i_max( layout, rank-1 )
   jmin = get_layout_j_min( layout, rank-1 )
   jmax = get_layout_j_max( layout, rank-1 )
   size_i      = imax - imin + 1
   size_j      = jmax - jmin + 1
   counter     = counter + size_i*size_j
   disps(rank+1) = counter
end do

end subroutine compute_displacements_array

subroutine load_buffer( layout, data, buffer )

type(layout_2D), pointer   :: layout
sll_real64, dimension(:,:), intent(in) :: data
sll_real64, dimension(:),  intent(out) :: buffer
sll_int32 :: myrank
sll_int32 :: data_size
type(sll_collective_t), pointer :: col
sll_int32 :: imin, imax
sll_int32 :: jmin, jmax
sll_int32 :: size_i, size_j
sll_int32 :: i,j
sll_int32 :: counter

col => get_layout_collective( layout )
myrank = sll_get_collective_rank( col )
data_size = size(data,1)*size(data,2)
imin = get_layout_i_min( layout, myrank )
imax = get_layout_i_max( layout, myrank )
jmin = get_layout_j_min( layout, myrank )
jmax = get_layout_j_max( layout, myrank )
size_i = imax - imin + 1
size_j = jmax - jmin + 1

counter=0
do j=1,size_j
  do i=1,size_i
    counter = counter + 1
    buffer(counter) = data(i,j)
  end do
end do

end subroutine load_buffer

function receive_counts_array( layout, n ) result(rc)

type(layout_2D), pointer :: layout
sll_int32, intent(in)    :: n
sll_int32, dimension(n) :: rc
sll_int32 :: i
sll_int32 :: imin, imax
sll_int32 :: jmin, jmax
sll_int32 :: size_i, size_j

do i=0,n-1
   imin = get_layout_i_min( layout, i )
   imax = get_layout_i_max( layout, i )
   jmin = get_layout_j_min( layout, i )
   jmax = get_layout_j_max( layout, i )
   size_i = imax - imin + 1
   size_j = jmax - jmin + 1
   rc(i+1)  = size_i*size_j
end do

end function receive_counts_array

subroutine unload_buffer( layout, buffer, data )

type(layout_2D), pointer                :: layout
sll_real64, dimension(:,:), intent(out) :: data
sll_real64, dimension(:), intent(in)    :: buffer
sll_int32 :: col_sz
type(sll_collective_t), pointer :: col
sll_int32 :: i, j
sll_int32 :: box
sll_int32 :: imin, imax
sll_int32 :: jmin, jmax
sll_int32 :: pos            ! position in buffer
col => get_layout_collective( layout )
col_sz = sll_get_collective_size( col )

! loop over all the boxes in the layout and fill the data array by chunks.
pos = 1
do box=0,col_sz-1
   imin = get_layout_i_min( layout, box )
   imax = get_layout_i_max( layout, box )
   jmin = get_layout_j_min( layout, box )
   jmax = get_layout_j_max( layout, box )
   ! this will fill the data array in whatever order that the boxes
   ! are ordered.
   do j=jmin,jmax
      do i=imin,imax
         data(i,j) = buffer(pos)
         pos       = pos + 1
      end do
   end do
end do

end subroutine unload_buffer

subroutine writeHDF5_diag_qns( sim )

use sll_m_hdf5_io_serial, only: sll_hdf5_file_create, &
  sll_hdf5_write_array_1d, sll_hdf5_file_close

class(sll_simulation_4d_qns_general), intent(inout) :: sim

sll_int32 :: ix1_diag, ix2_diag
sll_int32 :: iv1_diag, iv2_diag

!--> diagnostics norm
sll_real64, dimension(sim%count_save_diag + 1) :: diag_masse_result
sll_real64, dimension(sim%count_save_diag + 1) :: diag_norm_L1_result
sll_real64, dimension(sim%count_save_diag + 1) :: diag_norm_L2_result
sll_real64, dimension(sim%count_save_diag + 1) :: diag_norm_Linf_result
sll_real64, dimension(sim%count_save_diag + 1) :: diag_entropy_kin_result

!--> diagnostics energy
sll_real64, dimension(sim%count_save_diag + 1) :: diag_nrj_kin_result
sll_real64, dimension(sim%count_save_diag + 1) :: diag_nrj_pot_result
sll_real64, dimension(sim%count_save_diag + 1) :: diag_nrj_tot_result
sll_real64, dimension(sim%count_save_diag + 1) :: diag_relative_error_nrj_tot_result

!--> For initial profile HDF5 saving
integer             :: file_err
sll_int32           :: file_id
character(len=80)   :: filename_HDF5
character(20), save :: numfmt = "'_d',i5.5"
    
ix1_diag   = int(sim%mesh2d_x%num_cells1/2)
ix2_diag   = int(sim%mesh2d_x%num_cells2/3)
iv1_diag   = int(sim%mesh2d_v%num_cells1/4)
iv2_diag   = int(sim%mesh2d_v%num_cells2/3)

diag_masse_result       = 0.0_f64
diag_norm_L1_result     = 0.0_f64
diag_norm_L2_result     = 0.0_f64
diag_norm_Linf_result   = 0.0_f64
diag_entropy_kin_result = 0.0_f64
diag_nrj_kin_result     = 0.0_f64
diag_nrj_pot_result     = 0.0_f64
diag_nrj_tot_result     = 0.0_f64
diag_relative_error_nrj_tot_result = 0.0_f64

call sll_collective_reduce_real64( &
            sll_world_collective, &
            sim%diag_masse(1:sim%count_save_diag + 1), &
            sim%count_save_diag + 1, &
            MPI_SUM, &
            0, &
            diag_masse_result )

call sll_collective_reduce_real64( &
           sll_world_collective, &
           sim%diag_norm_L1(1:sim%count_save_diag + 1), &
           sim%count_save_diag + 1, &
           MPI_SUM, &
           0, &
           diag_norm_L1_result )

call sll_collective_reduce_real64( &
           sll_world_collective, &
           sim%diag_norm_L2(1:sim%count_save_diag + 1), &
           sim%count_save_diag + 1, &
           MPI_SUM, &
           0, &
           diag_norm_L2_result )

call sll_collective_reduce_real64( &
           sll_world_collective, &
           sim%diag_norm_Linf(1:sim%count_save_diag + 1), &
           sim%count_save_diag + 1, &
           MPI_SUM, &
           0, &
           diag_norm_Linf_result )

call sll_collective_reduce_real64( &
           sll_world_collective, &
           sim%diag_entropy_kin(1:sim%count_save_diag + 1), &
           sim%count_save_diag + 1, &
           MPI_SUM, &
           0, &
           diag_entropy_kin_result )

call sll_collective_reduce_real64( &
           sll_world_collective, &
           sim%diag_nrj_kin(1:sim%count_save_diag + 1), &
           sim%count_save_diag + 1, &
           MPI_SUM, &
               0, &
               diag_nrj_kin_result )

    
call sll_collective_reduce_real64( &
           sll_world_collective, &
           sim%diag_nrj_pot(1:sim%count_save_diag + 1), &
           sim%count_save_diag + 1, &
           MPI_SUM, &
           0, &
           diag_nrj_pot_result )

call sll_collective_reduce_real64( &
           sll_world_collective, &
           sim%diag_nrj_tot(1:sim%count_save_diag + 1), &
           sim%count_save_diag + 1, &
           MPI_SUM, &
           0, &
           diag_nrj_tot_result )

diag_relative_error_nrj_tot_result(:) = &
     (diag_nrj_tot_result(:)-diag_nrj_tot_result(1))/&
     sqrt(0.5*( (diag_nrj_kin_result(:)-diag_nrj_kin_result(1) )**2 + &
                (diag_nrj_pot_result(:)-diag_nrj_pot_result(1) )**2 ) ) 

write(filename_HDF5,'(A,'//numfmt//',A)') &
  "vp4D_diag", sim%count_save_diag, ".h5"

if (sim%my_rank.eq.0) then
  print*,'--> Save HDF5 file: ',filename_HDF5
  call sll_hdf5_file_create(filename_HDF5,file_id,file_err)
  call sll_hdf5_write_array_2d(file_id, &
    sim%f_x1x2(:,:,iv1_diag,iv2_diag),'f2d_xy',file_err)
  call sll_hdf5_write_array_2d(file_id, &
    sim%f_x3x4(ix1_diag,ix2_diag,:,:),'f2d_v1v2',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_nrj_kin_result(:),'nrj_kin',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_nrj_pot_result(:),'nrj_pot',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_nrj_tot_result(:),'nrj_tot',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_relative_error_nrj_tot_result(:),&
                      'relative_error_nrj_tot',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_masse_result(:),&
                      'masse',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_norm_L1_result(:),'L1_norm',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_norm_L2_result(:),'L2_norm',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_norm_Linf_result(:),'Linf_norm',file_err)
  call sll_hdf5_write_array_1d(file_id,&
                      diag_entropy_kin_result(:),'entropy_kin',file_err)
  call sll_hdf5_write_array_2d(file_id,sim%point_x(:,:),'X_coord',file_err)
  call sll_hdf5_write_array_2d(file_id,sim%point_y(:,:),'Y_coord',file_err)
  call sll_hdf5_file_close(file_id,file_err)
  
end if
sim%count_save_diag = sim%count_save_diag + 1
    
end subroutine writeHDF5_diag_qns

!-----------------------------------------------------------
! Computation of the kinetic energy, i.e   
!   nrj_kin = \int delta f * vpar**2 * 0.5 * jac dvpar deta1 deta2 deta3
!   delta f = f(x,y,z,vpar) - feq(x,y,vpar) 
!   jac     = jacobian of the change of coordinates
!  In : f4d_seqx3x4(x1=distrib,x2=distrib,x3=*,x4=*)
!       feq3d_seqx1x2x4(x1=*,x2=*,x4=*)
!  Out: nrj_kin
!
! Computation of the potential energy, i.e   
!   nrj_pot = \int delta f * phi * 0.5 * jac dvpar deta1 deta2 deta3
!   delta f = f(eta1,eta2,eta3,vpar) - feq(eta1,eta2,vpar) 
!   phi     = phi(eta1,eta2,eta3) 
!   jac     = jacobian of the change of coordinates
!  In : f4d_seqx3x4(x1=distrib,x2=distrib,x3=*,x4=*)
!       feq3d_seqx1x2x4(x1=*,x2=*,x4=*)
!       phi3d_seqx3(x1=distrib,x2=distrib,x3=*)
!  Out: nrj_pot
!
! Computation of the energy total = nrj_pot + nrj_kin
!
! Computation of the heat flux, i.e   
!   nrj_pot = \int delta f * phi * 0.5 * jac dvpar deta1 deta2 deta3
!   delta f = f(eta1,eta2,eta3,vpar) - feq(eta1,eta2,vpar) 
!   phi     = phi(eta1,eta2,eta3) 
!   jac     = jacobian of the change of coordinates
!  In : f4d_seqx3x4(x1=distrib,x2=distrib,x3=*,x4=*)
!       feq3d_seqx1x2x4(x1=*,x2=*,x4=*)
!       phi3d_seqx3(x1=distrib,x2=distrib,x3=*)
!  Out: nrj_pot
!
!-----------------------------------------------------------

subroutine compute_energy_qns(sim,phi)

class(sll_simulation_4d_qns_general), intent(inout) :: sim
type(sll_scalar_field_2d_discrete), pointer       :: phi

sll_int32  :: Neta1_loc,Neta2_loc,Nv2,Nv1,Neta1,Neta2
sll_real64 :: delta_eta1,delta_eta2,delta_v1,delta_v2
sll_real64, dimension(1:2,1:2) :: inv_j
sll_real64 :: val_jac
sll_real64 :: v1,v2
sll_real64 :: ex,ey
sll_real64 :: eta1,eta2
sll_real64 :: delta_f
sll_int32  :: iloc1, iloc2
sll_int32  :: i1,i2,iv1,iv2
sll_int32, dimension(1:4) :: glob_ind4d
sll_real64 :: nrj_kin,nrj_pot,nrj_tot

Neta1_loc  = size(sim%f_x3x4,1)
Neta2_loc  = size(sim%f_x3x4,2)

Neta1      = sim%mesh2d_x%num_cells1 + 1
Neta2      = sim%mesh2d_x%num_cells2 + 1
Nv1        = size(sim%f_x3x4,3)
Nv2        = size(sim%f_x3x4,4)
delta_eta1 = sim%mesh2d_x%delta_eta1
delta_eta2 = sim%mesh2d_x%delta_eta2
delta_v1   = sim%mesh2d_v%delta_eta1
delta_v2   = sim%mesh2d_v%delta_eta2
    
nrj_kin   = 0.0
nrj_pot   = 0.0
nrj_tot   = 0.0

!-> Computation of the energy kinetic locally in (x1,x2) directions
do iloc2 = 1,Neta2_loc
  do iloc1 = 1,Neta1_loc
    do iv1 = 1,Nv1-1
      v1 = sim%mesh2d_v%eta1_min + (iv1-1)*delta_eta1
      do iv2 = 1,Nv2-1
        v2 = sim%mesh2d_v%eta2_min + (iv2-1)*delta_eta2
        glob_ind4d(:) = local_to_global(sim%sequential_x3x4, &
             (/iloc1,iloc2,iv1,iv2/))
        i1 = glob_ind4d(1)
        i2 = glob_ind4d(2)

        eta1  = sim%pt_eta1(i1)
        eta2  = sim%pt_eta2(i2)
        ex    = sim%values_ex (i1,i2 )
        ey    = sim%values_ey(i1,i2)
        inv_j = sim%values_jacobian_matinv(i1,i2,:,:)
        
        if (i1 .ne. Neta1) then
          if (i2 .ne. Neta2) then 
            val_jac = abs(sim%values_jacobian(i1,i2))
            delta_f = sim%f_x3x4(iloc1,iloc2,iv1,iv2)
            nrj_kin = nrj_kin + &
                 delta_f * (v1**2 + v2**2) * 0.5 * val_jac * &
                 delta_eta1*delta_eta2*delta_v1*delta_v2
          end if
        end if
      end do
    end do
    nrj_pot = nrj_pot + ((inv_j(1,1)*ex+inv_j(2,1)*ey)**2+ &
                         (inv_j(1,2)*ex+inv_j(2,2)*ey)**2) &
                        *0.5*val_jac*delta_eta1*delta_eta2
  end do
end do

nrj_tot = nrj_kin + nrj_pot

sim%diag_nrj_kin(sim%count_save_diag+1) = nrj_kin
sim%diag_nrj_pot(sim%count_save_diag+1) = nrj_pot
sim%diag_nrj_tot(sim%count_save_diag+1) = nrj_tot

end subroutine compute_energy_qns
  
!-----------------------------------------------------------
! Computation of the L1 norm , i.e   
!   Norm_L1 = \int abs(delta f) * jac dvpar deta1 deta2 deta3
!   delta f = f(x,y,z,vpar)
!   jac     = jacobian of the change of coordinates
!  In : f4d_seqx3x4(x1=distrib,x2=distrib,x3=*,x4=*)
!     
!  Out: Norm_L1
!
! Computation of the L2 norm , i.e   
!   Norm_L2 = SQRT(\int abs(delta f)**2 * jac dvpar deta1 deta2 deta3)
!   delta f = f(x,y,z,vpar)
!   jac     = jacobian of the change of coordinates
!  In : f4d_seqx3x4(x1=distrib,x2=distrib,x3=*,x4=*)
!      
!  Out: Norm_L2
!
! Computation of the L infini = max( abs( delta f) )
!-----------------------------------------------------------

subroutine compute_norm_L1_L2_Linf_qns(sim)
    
class(sll_simulation_4d_qns_general), intent(inout) :: sim

! local variables
sll_int32  :: Neta1_loc,Neta2_loc,Nv1,Nv2
sll_int32  :: Neta1, Neta2
sll_real64 :: delta_eta1,delta_eta2,delta_v1,delta_v2
sll_real64 :: val_jac
sll_real64 :: delta_f
sll_int32  :: iloc1, iloc2
sll_int32  :: i1,i2,iv1,iv2
sll_int32, dimension(1:4) :: glob_ind4d
sll_real64 :: masse, norm_L1,norm_L2,norm_Linf,entropy_kin

Neta1_loc  = size(sim%f_x3x4,1)
Neta2_loc  = size(sim%f_x3x4,2)
Neta1      = sim%mesh2d_x%num_cells1 + 1
Neta2      = sim%mesh2d_x%num_cells2 + 1
Nv1        = size(sim%f_x3x4,3)
Nv2        = size(sim%f_x3x4,4)
delta_eta1 = sim%mesh2d_x%delta_eta1
delta_eta2 = sim%mesh2d_x%delta_eta2
delta_v1   = sim%mesh2d_v%delta_eta1
delta_v2   = sim%mesh2d_v%delta_eta2


norm_L1    = 0.0
norm_L2    = 0.0
norm_Linf  = 0.0
masse      = 0.0
entropy_kin= 0.0

!-> Computation of the enrgy kinetic locally in (x1,x2) directions
do iloc2 = 1,Neta2_loc
  do iloc1 = 1,Neta1_loc
    do iv1 = 1,Nv1-1
      do iv2 = 1,Nv2-1
        
        glob_ind4d(:) = local_to_global(sim%sequential_x3x4, &
             (/iloc1,iloc2,iv1,iv2/))
        i1 = glob_ind4d(1)
        i2 = glob_ind4d(2)
        
        if (i1 .ne. Neta1) then
          if (i2 .ne. Neta2) then 
            
            val_jac = abs(sim%values_jacobian(i1,i2))
            
            delta_f = sim%f_x3x4(iloc1,iloc2,iv1,iv2)
            
            masse   = masse + delta_f * val_jac * &
                              delta_eta1*delta_eta2*delta_v1*delta_v2
            
            norm_L1 = norm_L1 + &
                 abs(delta_f) * val_jac * &
                 delta_eta1*delta_eta2*delta_v1*delta_v2
            
            norm_L2 = norm_L2 + &
                 abs(delta_f)**2 * val_jac * &
                 delta_eta1*delta_eta2*delta_v1*delta_v2
            
            entropy_kin = entropy_kin - &
                 delta_f* log(abs(delta_f)) * val_jac * &
                 delta_eta1*delta_eta2*delta_v1*delta_v2
            
            norm_Linf = max(abs(delta_f),norm_Linf)
          end if
        end if
      end do
    end do
  end do
end do
norm_L2   = sqrt(norm_L2)

sim%diag_masse(sim%count_save_diag + 1)       = masse
sim%diag_norm_L1(sim%count_save_diag + 1)     = norm_L1
sim%diag_norm_L2(sim%count_save_diag + 1)     = norm_L2
sim%diag_norm_Linf(sim%count_save_diag + 1)   = norm_Linf
sim%diag_entropy_kin(sim%count_save_diag + 1) = entropy_kin
end subroutine compute_norm_L1_L2_Linf_qns

subroutine compute_values_jacobian_and_mesh_points(sim)
class(sll_simulation_4d_qns_general), intent(inout) :: sim
sll_real64 :: delta1,delta2
sll_int32  :: i,j
sll_real64 :: eta1_min
sll_real64 :: eta2_min
sll_real64 :: eta1,eta2

delta1 = sim%mesh2d_x%delta_eta1
delta2 = sim%mesh2d_x%delta_eta2

eta1_min = sim%mesh2d_x%eta1_min
eta2_min = sim%mesh2d_x%eta2_min

do j=1,sim%mesh2d_x%num_cells2 +1
  eta2   =  eta2_min + real(j-1,f64)*delta2
  sim%pt_eta2(j) = eta2
  do i=1,sim%mesh2d_x%num_cells1 +1
    eta1   =  eta1_min + real(i-1,f64)*delta1
    sim%pt_eta1(i) = eta1
    
    sim%values_jacobian_matinv(i,j,:,:)=sim%transfx%inverse_jacobian_matrix(eta1,eta2)
    sim%values_jacobian_mat(i,j,:,:)   =sim%transfx%jacobian_matrix(eta1,eta2)
    sim%values_jacobian(i,j)           =sim%values_jacobian_mat(i,j,1,1)*&
                                        sim%values_jacobian_mat(i,j,2,2)-&
                                        sim%values_jacobian_mat(i,j,1,2)*&
                                        sim%values_jacobian_mat(i,j,2,1)
    sim%point_x(i,j) = sim%transfx%x1(eta1,eta2)
    sim%point_y(i,j) = sim%transfx%x2(eta1,eta2)
  end do
end do
  
end subroutine compute_values_jacobian_and_mesh_points

end module sll_m_sim_4d_qns_general
