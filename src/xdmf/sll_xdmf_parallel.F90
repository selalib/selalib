module sll_m_xdmf_parallel

#include "sll_working_precision.h"
#include "sll_assert.h"

  use sll_collective, only:  &
    sll_collective_t,        &
    sll_get_collective_size, &
    sll_get_collective_rank, &
    sll_collective_bcast,    &
    sll_collective_gather

  use sll_m_xdmf, only: &
    sll_t_xdmf_file

  implicit none
  private

  !----------------------------------------------------------------------------
  !> Maximum length of variable-length strings to be passed through MPI
  integer, parameter :: maxlen = 256

  !----------------------------------------------------------------------------
  !> XDMF parallel file
  type, public :: sll_t_xdmf_parallel_file

    type(sll_collective_t), pointer    :: comm => null()
    sll_int32                          :: rank = -1
    type(sll_t_xdmf_file), allocatable :: xdmf_file

  contains
    procedure :: init      => t_xdmf_parallel__init
    procedure :: write     => t_xdmf_parallel__write
    procedure :: delete    => t_xdmf_parallel__delete
    procedure :: add_grid  => t_xdmf_parallel__add_grid
    procedure :: add_field => t_xdmf_parallel__add_field

  end type sll_t_xdmf_parallel_file

!==============================================================================
contains
!==============================================================================

  subroutine t_xdmf_parallel__init( self, time, comm )
    class(sll_t_xdmf_parallel_file), intent(  out) :: self
    sll_real64                     , intent(in   ) :: time
    type(sll_collective_t)         , pointer       :: comm

    ! Fill in fields
    self%comm => comm
    self%rank =  sll_get_collective_rank( comm )
    
    ! MASTER: Allocate and initialize sequential XDMF file
    if (self%rank == 0) then
      allocate( self%xdmf_file )
      call self%xdmf_file%init( time )
    end if

  end subroutine t_xdmf_parallel__init

  !----------------------------------------------------------------------------
  subroutine t_xdmf_parallel__write( self, fname )
    class(sll_t_xdmf_parallel_file), intent(in) :: self
    character(len=*)               , intent(in) :: fname

    ! MASTER: write XDMF file 
    if (self%rank == 0) then
      call self%xdmf_file%write( fname )
    end if

  end subroutine t_xdmf_parallel__write

  !----------------------------------------------------------------------------
  subroutine t_xdmf_parallel__delete( self )
    class(sll_t_xdmf_parallel_file), intent(inout) :: self

    ! MASTER: delete and deallocate sequential XDMF file
    if (self%rank == 0) then
      if (allocated( self%xdmf_file )) then
        call self%xdmf_file%delete()
        deallocate( self%xdmf_file )
      end if
    end if

    ! Reset internal fields
    self%comm => null()
    self%rank = -1

  end subroutine t_xdmf_parallel__delete

  !----------------------------------------------------------------------------
  subroutine t_xdmf_parallel__add_grid( self, grid_name, x1_path, x2_path, dims, gid )
    class(sll_t_xdmf_parallel_file), intent(inout) :: self
    character(len=*)               , intent(in   ) :: grid_name
    character(len=*)               , intent(in   ) :: x1_path
    character(len=*)               , intent(in   ) :: x2_path
    sll_int32                      , intent(in   ) :: dims(2)
    sll_int32                      , intent(  out) :: gid

    sll_int32 :: buf_gid(1)

    ! MASTER: add grid to sequential XDMF file
    ! TODO: other processes might want to add a grid
    if (self%rank == 0) then
      call self%xdmf_file%add_grid( grid_name, x1_path, x2_path, dims, gid )
    end if

    ! Broadcast grid ID to all other processes
    buf_gid(1) = gid
    call sll_collective_bcast( self%comm, buf_gid, 0 )
    gid = buf_gid(1)

  end subroutine t_xdmf_parallel__add_grid

  !----------------------------------------------------------------------------
  subroutine t_xdmf_parallel__add_field( self, &
      grid_id, field_name, field_path, &
      to_file )

    use mpi

    class(sll_t_xdmf_parallel_file), intent(inout) :: self
    sll_int32                      , intent(in   ) :: grid_id
    character(len=*)               , intent(in   ) :: field_name
    character(len=*)               , intent(in   ) :: field_path
    logical                        , intent(in   ) :: to_file

    sll_int32             :: i         ! index for cycles
    sll_int32             :: nprocs    ! number of processors
    sll_int32             :: comm      ! MPI communicator
    sll_int32             :: ierr      ! MPI error
    logical               :: buf(1)    ! send buffer for gather
    logical, allocatable  :: recbuf(:) ! receive buffer for gather
    character(len=11)     :: rank_str  ! rank converted to string
    sll_int32             :: stat(mpi_status_size)
    sll_int32             :: sender_rank

    ! Send/receive buffers (receive for master, send for all others)
    sll_int32             :: buf_gid  ! grid_id
    character(len=maxlen) :: buf_fn   ! field_name
    character(len=maxlen) :: buf_fp   ! field_path

    ! Some info about communicator
    nprocs = sll_get_collective_size( self%comm )
    comm   = self%comm%comm

    ! Fill in send buffer (all processes)
    buf(1) = to_file

    ! MASTER ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    if (self%rank == 0) then
      ! Allocate receive buffer for 'to_file' logicals, then gather all of them
      allocate( recbuf(0:nprocs-1) )
      call sll_collective_gather( self%comm, buf, 0, recbuf )
      print *, "PROC #0: gather"

      ! Write array info on XDMF file
      if (to_file) then
        call self%xdmf_file%add_field( grid_id, field_name, field_path )
        print *, "PROC #0: write array info to xmf"
      end if
      print *, "PROC #0: recbuf = ", recbuf

      ! Receive data from other processes, and write array info to XDMF file
      do i = 1, count( recbuf(1:) )

        ! Receive grid ID from any process, then field name/path from same proc

        !    MPI_RECV( BUF, COUNT, DATATYPE, SOURCE, TAG, COMM, STATUS, IERROR )
        call mpi_recv( buf_gid, 1, mpi_integer, mpi_any_source, &
          mpi_any_tag, comm, stat, ierr )

        sender_rank = stat( mpi_source )

        call mpi_recv( buf_fn, maxlen, mpi_character, sender_rank, &
          mpi_any_tag, comm, stat, ierr )

        call mpi_recv( buf_fp, maxlen, mpi_character, sender_rank, &
          mpi_any_tag, comm, stat, ierr )

        write( rank_str, '(i8)' ) sender_rank
        print *, "PROC #0: data received from processor "// &
          trim( adjustl( rank_str ) )

        ! Add field to sequential XDMF file
        call self%xdmf_file%add_field( buf_gid,trim( buf_fn ),trim( buf_fp ) )
        print *, "PROC #0: field added to XDMF file"

      end do

    ! NOT MASTER ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    else
      call sll_collective_gather( self%comm, buf, 0, recbuf )
      write( rank_str, '(i8)' ) self%rank
      print *, "PROC #"//trim( adjustl( rank_str ) )//": gather"

      if (to_file) then
        ! Fill in send buffers
        buf_gid = grid_id
        buf_fn  = adjustl( field_name )
        buf_fp  = adjustl( field_path )

        ! Send data to master
        !    MPI_SEND( BUF, COUNT, DATATYPE, DEST, TAG, COMM, IERROR )
        call mpi_send( buf_gid, 1     , mpi_integer  , 0, 9, comm, ierr )
        call mpi_send( buf_fn , maxlen, mpi_character, 0, 9, comm, ierr )
        call mpi_send( buf_fp , maxlen, mpi_character, 0, 9, comm, ierr )
        print *, "PROC #"//trim( adjustl( rank_str ) )//": send"
      end if

    end if

  end subroutine t_xdmf_parallel__add_field

!==============================================================================
! UTILITIES
!==============================================================================

  subroutine split( path, head, tail )
    character(len=*), intent(in   ) :: path
    character(len=*), intent(  out) :: head
    character(len=*), intent(  out) :: tail

    sll_int32 :: nc
    sll_int32 :: i

    ! Number of non-blank characters in path string
    nc = len_trim( path, i32 )

    ! If last character is '/', tail is empty
    if (path(nc:nc) == '/') then
      head = path(1:nc)
      tail = ''
    end if

    ! Search backwards (from right to left) for '/' character, and split path
    do i = nc-1,1,-1
      if (path(i:i) == '/') then
        head = path(1:i) 
        tail = path(i+1:nc)
        return
      end if
    end do

    ! If no '/' character was found, head is empty
    head = ''
    tail = path(1:nc)

  end subroutine split

!==============================================================================

end module sll_m_xdmf_parallel
