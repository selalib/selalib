!**************************************************************
!  Copyright INRIA
!  Authors : 
!     CALVI project team
!  
!  This code SeLaLib (for Semi-Lagrangian-Library) 
!  is a parallel library for simulating the plasma turbulence 
!  in a tokamak.
!  
!  This software is governed by the CeCILL-B license 
!  under French law and abiding by the rules of distribution 
!  of free software.  You can  use, modify and redistribute 
!  the software under the terms of the CeCILL-B license as 
!  circulated by CEA, CNRS and INRIA at the following URL
!  "http://www.cecill.info". 
!**************************************************************

!> @ingroup quasi_neutral_solvers
module sll_m_quasi_neutral_2d_polar_solver
#include "sll_working_precision.h"
#include "sll_memory.h"
#include "sll_assert.h"
!use sll_m_boundary_condition_descriptors
use sll_m_poisson_2d_base
use sll_m_poisson_2d_polar
implicit none

  type,extends(sll_c_poisson_2d_base) :: quasi_neutral_2d_polar_solver     
  
  type(sll_plan_poisson_polar), pointer                   :: poiss
  
  contains
    procedure, pass(poisson) :: initialize => &
      initialize_quasi_neutral_2d_polar_solver
    procedure, pass(poisson) :: compute_phi_from_rho => &
      compute_phi_from_rho_2d_quasi_neutral_polar
    procedure, pass(poisson) :: compute_E_from_rho => &
      compute_E_from_rho_2d_quasi_neutral_polar
!    procedure, pass(poisson) :: compute_E_from_phi => &
!      compute_E_from_phi_2d_polar
      
  end type quasi_neutral_2d_polar_solver

contains
  function new_quasi_neutral_2d_polar_solver( &
    eta1_min, &
    eta1_max, &
    nc_eta1, &
    nc_eta2, &
    bc) &     
    result(poisson)
      
    type(quasi_neutral_2d_polar_solver),pointer :: poisson
    sll_real64 :: eta1_min
    sll_real64 :: eta1_max
    sll_int32 :: nc_eta1
    sll_int32 :: nc_eta2
    sll_int32, intent(in) :: bc(2)
    sll_int32 :: ierr
      
    SLL_ALLOCATE(poisson,ierr)
    call initialize_quasi_neutral_2d_polar_solver( &
      poisson, &
      eta1_min, &
      eta1_max, &
      nc_eta1, &
      nc_eta2, &
      bc)     
    
  end function new_quasi_neutral_2d_polar_solver
  
  
  subroutine initialize_quasi_neutral_2d_polar_solver( &
    poisson, &
    eta1_min, &
    eta1_max, &
    nc_eta1, &
    nc_eta2, &
    bc)     
    class(quasi_neutral_2d_polar_solver) :: poisson
    sll_real64, intent(in) :: eta1_min
    sll_real64, intent(in) :: eta1_max
    sll_int32, intent(in) :: nc_eta1
    sll_int32, intent(in) :: nc_eta2
    sll_int32, intent(in) :: bc(2)
    sll_int32 :: ierr
    sll_real64 :: delta_eta
    
    delta_eta = (eta1_max-eta1_min)/real(nc_eta1,f64)
    
    poisson%poiss => new_plan_poisson_polar( &
      delta_eta,& 
      eta1_min, &
      nc_eta1, &
      nc_eta2, &
      bc)

        
  end subroutine initialize_quasi_neutral_2d_polar_solver
  
  ! solves -\Delta phi = rho in 2d
  subroutine compute_phi_from_rho_2d_quasi_neutral_polar( poisson, phi, rho )
    class(quasi_neutral_2d_polar_solver) :: poisson
    sll_real64,dimension(:,:),intent(in) :: rho
    sll_real64,dimension(:,:),intent(out) :: phi
    
    call solve( poisson%poiss, rho, phi)
    
  end subroutine compute_phi_from_rho_2d_quasi_neutral_polar

    ! solves E = -\nabla Phi in 2d
!    subroutine compute_E_from_phi_2d_fft( poisson, phi, E1, E2 )
!      class(sll_t_poisson_2d_fft_solver) :: poisson
!      sll_real64,dimension(:,:),intent(in) :: phi
!      sll_real64,dimension(:,:),intent(out) :: E1
!      sll_real64,dimension(:,:),intent(out) :: E2
!    end subroutine compute_E_from_phi_2d_fft

    ! solves E = -\nabla Phi with -\Delta phi = rho in 2d 
    subroutine compute_E_from_rho_2d_quasi_neutral_polar( poisson, rho, E1, E2 )
      class(quasi_neutral_2d_polar_solver) :: poisson
      sll_real64,dimension(:,:),intent(in) :: rho
      sll_real64,dimension(:,:),intent(out) :: E1
      sll_real64,dimension(:,:),intent(out) :: E2
      
      print *,'#compute_E_from_rho_2d_polar'      
      print *,'#not implemented for the moment'
      stop
      
      !call solve( poisson%poiss, E1, E2, rho)
      
    end subroutine compute_E_from_rho_2d_quasi_neutral_polar
  
  
  
  
end module sll_m_quasi_neutral_2d_polar_solver
