program unit_test_2d
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include "sll_memory.h"
#include "sll_working_precision.h"

  use helper_functions, only: &
    test_function_dirdir, &
    test_function_dirdir_der1, &
    test_function_dirdir_der2, &
    test_function_dirper, &
    test_function_dirper_der1, &
    test_function_dirper_der2, &
    test_function_perdir, &
    test_function_perdir_der1, &
    test_function_perdir_der2, &
    test_function_perper, &
    test_function_perper_der1, &
    test_function_perper_der2

  use sll_m_arbitrary_degree_spline_interpolator_2d, only: &
    sll_s_ad2d_interpolator_init, &
    sll_t_arbitrary_degree_spline_interpolator_2d

  use sll_m_boundary_condition_descriptors, only: &
    sll_p_dirichlet, &
    sll_p_periodic

  use sll_m_cartesian_meshes, only: &
    sll_f_new_cartesian_mesh_2d, &
    sll_t_cartesian_mesh_2d

  use sll_m_common_coordinate_transformations, only: &
    sll_f_identity_jac11, &
    sll_f_identity_jac12, &
    sll_f_identity_jac21, &
    sll_f_identity_jac22, &
    sll_f_identity_x1, &
    sll_f_identity_x2

  use sll_m_coordinate_transformation_2d_base, only: &
    sll_c_coordinate_transformation_2d_base

  use sll_m_coordinate_transformations_2d, only: &
    sll_f_new_coordinate_transformation_2d_analytic

  use sll_m_scalar_field_2d, only: &
    sll_t_scalar_field_2d_analytic, &
    sll_t_scalar_field_2d_discrete, &
    sll_f_new_scalar_field_2d_analytic, &
    sll_f_new_scalar_field_2d_discrete

  use sll_m_scalar_field_2d_base, only: &
    sll_c_scalar_field_2d_base

  implicit none
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define SPLINE_DEG1 3
#define SPLINE_DEG2 3
#define NUM_CELLS1  64
#define NUM_CELLS2  64
#define ETA1MIN  0.0_f64
#define ETA1MAX  1.0_f64
#define ETA2MIN  0.0_f64
#define ETA2MAX  1.0_f64
#define PRINT_COMPARISON .false.
  
  type(sll_t_cartesian_mesh_2d), pointer                  :: mesh_2d
  class(sll_c_coordinate_transformation_2d_base), pointer :: T

  class(sll_c_scalar_field_2d_base), pointer :: scalar_field

  type(sll_t_scalar_field_2d_analytic), target :: doubly_periodic_analytic
  type(sll_t_scalar_field_2d_analytic), target :: periodic_dirichlet_analytic
  type(sll_t_scalar_field_2d_analytic), target :: dirichlet_dirichlet_analytic
  type(sll_t_scalar_field_2d_analytic), target :: dirichlet_periodic_analytic
  type(sll_t_scalar_field_2d_discrete), target :: doubly_periodic_discrete
  type(sll_t_scalar_field_2d_discrete), target :: periodic_dirichlet_discrete
  type(sll_t_scalar_field_2d_discrete), target :: dirichlet_dirichlet_discrete
  type(sll_t_scalar_field_2d_discrete), target :: dirichlet_periodic_discrete


  sll_int32 :: nc1, nc2!, iplot
  sll_real64 :: grad1_node_val,grad2_node_val,grad1ref,grad2ref
  sll_real64, dimension(:,:), pointer :: tab_values
  type(sll_t_arbitrary_degree_spline_interpolator_2d), target :: interp_2d
  sll_real64 :: node_val,ref

  sll_real64, dimension(:),   allocatable    :: point1
  sll_real64, dimension(:),   allocatable    :: point2
  sll_real64 :: eta1,eta2
  sll_real64  :: h1,h2
  sll_int32 :: i,j
  
  sll_real64 :: normL2_1,normL2_2,normL2_3,normL2_4
  sll_real64 :: normL2_5,normL2_6,normL2_7,normL2_8
  sll_real64 :: normH1_1,normH1_2,normH1_3,normH1_4
  sll_real64 :: normH1_5,normH1_6,normH1_7,normH1_8

  sll_real64, dimension(1) :: params_identity

  params_identity(:) = (/ 0.0_f64 /)

  ! logical mesh
  nc1 = NUM_CELLS1
  nc2 = NUM_CELLS1
  h1 = (ETA1MAX-ETA1MIN)/real(nc1,f64)
  h2 = (ETA2MAX-ETA2MIN)/real(nc2,f64)
  print *, 'h1 = ', h1
  print *, 'h2 = ', h2

  ! First thing, initialize the logical mesh associated with this problem.        
  mesh_2d => sll_f_new_cartesian_mesh_2d( NUM_CELLS1, NUM_CELLS2, &
       ETA1MIN, ETA1MAX, ETA2MIN,ETA2MAX )
  
  print *, 'initialized mesh 2D'
  
  ! coordinate transformation
  T => sll_f_new_coordinate_transformation_2d_analytic( &
       "analytic", &
       mesh_2d, &
       sll_f_identity_x1, &
       sll_f_identity_x2, &
       sll_f_identity_jac11, &
       sll_f_identity_jac12, &
       sll_f_identity_jac21, &
       sll_f_identity_jac22, &
       params_identity )
  print *, 'initialized transformation'



  ! ******************************************************************
  ! ------------------ TEST ANALYTIC ------------------------------  
  ! ******************************************************************
  
  ! --------------------------------------------------------------------------
  !   Test case periodic-periodic analytic
  !----------------------------------------------------------------------------
  
  ! ----> initialization of the field
  call doubly_periodic_analytic%init( &
       test_function_perper, &
       "doubly_periodic_analytic", &
       T, &
       sll_p_periodic, &
       sll_p_periodic, &
       sll_p_periodic, &
       sll_p_periodic,&
       (/0.0_f64/), & ! could be anything in this case
       first_deriv_eta1=test_function_perper_der1,&
       first_deriv_eta2=test_function_perper_der2)

  scalar_field => doubly_periodic_analytic

  print *, 'initialized field 2d'
  
  ! -------> compute error norm L2 and H1
  normL2_1 = 0.0_f64
  normH1_1 = 0.0_f64
  do j=1,nc2+1
     do i=1,nc1+1
        eta1       = real(i-1,f64)*h1 + ETA1MIN
        eta2       = real(j-1,f64)*h2 + ETA2MIN
        node_val   = scalar_field%value_at_point(eta1,eta2)
        grad1_node_val = scalar_field%first_deriv_eta1_value_at_point(eta1, eta2)
        grad2_node_val = scalar_field%first_deriv_eta2_value_at_point(eta1, eta2)
        ref        = test_function_perper(eta1,eta2,(/0.0_f64/))
        grad1ref   = test_function_perper_der1(eta1,eta2,(/0.0_f64/))
        grad2ref   = test_function_perper_der2(eta1,eta2,(/0.0_f64/))
        
        if(PRINT_COMPARISON) then
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', node_val, &
                'theoretical = ', ref, 'difference=', node_val-ref
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad1_node_val, &
                'theoretical = ', grad1ref, 'difference=',grad1ref-grad1_node_val
           
        end if
        
        normL2_1    = normL2_1 + (node_val-ref)**2*h1*h2
        normH1_1    = normH1_1 + ((grad1_node_val-grad1ref)**2+&
             (grad2_node_val-grad2ref)**2)*h1*h2
        
     end do
  end do
  
  ! -------> field visualization 
  call scalar_field%write_to_file(1)
  
  ! -------> delete field
  call scalar_field%free()
  
  ! --------------------------------------------------------------------------
  !   Test case periodic-dirichlet analytic
  !----------------------------------------------------------------------------
  
  ! ----> initialization of the field
  call periodic_dirichlet_analytic%init( &
       test_function_perdir, &
       "periodic_dirichlet_analytic", &
       T, &
       sll_p_periodic, &
       sll_p_periodic, &
       sll_p_dirichlet, &
       sll_p_dirichlet,&
       (/0.0_f64/), & ! could be anything
       first_deriv_eta1=test_function_perdir_der1,&
       first_deriv_eta2=test_function_perdir_der2) 

  scalar_field => periodic_dirichlet_analytic
  print *, 'initialized field 2d'
  
  ! -------> compute error norm L2 and H1
  normL2_2 = 0.0_f64
  normH1_2 = 0.0_f64
  do j=1,nc2+1
     do i=1,nc1+1
        eta1       = real(i-1,f64)*h1 + ETA1MIN
        eta2       = real(j-1,f64)*h2 + ETA2MIN
        node_val   = scalar_field%value_at_point(eta1,eta2)
        grad1_node_val = scalar_field%first_deriv_eta1_value_at_point(&
                                                                              eta1, eta2)
        grad2_node_val = &
             scalar_field%first_deriv_eta2_value_at_point(&
             eta1, eta2)
        ref        = test_function_perdir(eta1,eta2,(/0.0_f64/))
        grad1ref   = test_function_perdir_der1(eta1,eta2,(/0.0_f64/))
        grad2ref   = test_function_perdir_der2(eta1,eta2,(/0.0_f64/))
        
        if(PRINT_COMPARISON) then
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', node_val, &
                'theoretical = ', ref, 'difference=', node_val-ref
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad1_node_val, &
                'theoretical = ', grad1ref, 'difference=',grad1ref-grad1_node_val
           
        end if
        
        normL2_2    = normL2_2 + (node_val-ref)**2*h1*h2
        normH1_2    = normH1_2 + ((grad1_node_val-grad1ref)**2+&
             (grad2_node_val-grad2ref)**2)*h1*h2
        
     end do
  end do

  ! -------> field visualization
   call scalar_field%write_to_file(1)
  
   ! -------> delete field
  call scalar_field%free()
  
  ! --------------------------------------------------------------------------
  !   Test case dirichlet-periodic analytic
  !----------------------------------------------------------------------------

  ! ----> initialization of the field
  call dirichlet_periodic_analytic%init( &
       test_function_dirper, &
       "dirichlet_periodic_analytic", &
       T, &
       sll_p_dirichlet, &
       sll_p_dirichlet,&
       sll_p_periodic, &
       sll_p_periodic,&
       (/0.0_f64/), &
       first_deriv_eta1=test_function_dirper_der1,&
       first_deriv_eta2=test_function_dirper_der2)

  print *, 'initialized field 2d'
  
  ! -------> compute error norm L2 and H1
  normL2_3 = 0.0_f64
  normH1_3 = 0.0_f64
  do j=1,nc2+1
     do i=1,nc1+1
        eta1       = real(i-1,f64)*h1 + ETA1MIN
        eta2       = real(j-1,f64)*h2 + ETA2MIN
        node_val   = dirichlet_periodic_analytic%value_at_point(eta1,eta2)
        grad1_node_val = dirichlet_periodic_analytic%first_deriv_eta1_value_at_point(&
                                                                              eta1, eta2)
        grad2_node_val = &
             dirichlet_periodic_analytic%first_deriv_eta2_value_at_point(&
             eta1, eta2)
        ref        = test_function_dirper(eta1,eta2,(/0.0_f64/))
        grad1ref   = test_function_dirper_der1(eta1,eta2,(/0.0_f64/))
        grad2ref   = test_function_dirper_der2(eta1,eta2,(/0.0_f64/))
        
        if(PRINT_COMPARISON) then
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', node_val, &
                'theoretical = ', ref, 'difference=', node_val-ref
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad1_node_val, &
                'theoretical = ', grad1ref, 'difference=',grad1ref-grad1_node_val
           
        end if
        
        normL2_3    = normL2_3 + (node_val-ref)**2*h1*h2
        normH1_3    = normH1_3 + ((grad1_node_val-grad1ref)**2+&
             (grad2_node_val-grad2ref)**2)*h1*h2
        
     end do
  end do

  ! -------> field visualization 
   call dirichlet_periodic_analytic%write_to_file(1)
  
   ! -------> delete field
  call dirichlet_periodic_analytic%free()


  ! --------------------------------------------------------------------------
  !   Test case dirichlet-dirichlet analytic
  !----------------------------------------------------------------------------
  
  ! ----> initialization of the field
  call dirichlet_dirichlet_analytic%init( &
       test_function_dirdir, &
       "dirichlet_dirichlet_analytic", &
       T, &
       sll_p_dirichlet, &
       sll_p_dirichlet,&
       sll_p_dirichlet, &
       sll_p_dirichlet,&
       (/0.0_f64/), &
       first_deriv_eta1= test_function_dirdir_der1,&
       first_deriv_eta2=test_function_dirdir_der2)
  
  print *, 'initialized field 2d'
  
  ! -------> compute error norm L2 and H1
  normL2_4 = 0.0_f64
  normH1_4 = 0.0_f64
  do j=1,nc2+1
     do i=1,nc1+1
        eta1       = real(i-1,f64)*h1 + ETA1MIN
        eta2       = real(j-1,f64)*h2 + ETA2MIN
        node_val   = dirichlet_dirichlet_analytic%value_at_point(eta1,eta2)
        grad1_node_val = dirichlet_dirichlet_analytic%first_deriv_eta1_value_at_point(&
                                                                              eta1, eta2)
        grad2_node_val = dirichlet_dirichlet_analytic%first_deriv_eta2_value_at_point(&
                                                                              eta1, eta2)
        ref        = test_function_dirdir(eta1,eta2,(/0.0_f64/))
        grad1ref   = test_function_dirdir_der1(eta1,eta2,(/0.0_f64/))
        grad2ref   = test_function_dirdir_der2(eta1,eta2,(/0.0_f64/))
        
        if(PRINT_COMPARISON) then
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', node_val, &
                'theoretical = ', ref, 'difference=', node_val-ref
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad1_node_val, &
                'theoretical = ', grad1ref, 'difference=',grad1ref-grad1_node_val
           
        end if
        
        normL2_4    = normL2_4 + (node_val-ref)**2*h1*h2
        normH1_4    = normH1_4 + ((grad1_node_val-grad1ref)**2+&
             (grad2_node_val-grad2ref)**2)*h1*h2
        
     end do
  end do
  ! -------> field visualization 
   call dirichlet_dirichlet_analytic%write_to_file(1)
  
   ! -------> delete field   
  call dirichlet_dirichlet_analytic%free()
  
  ! ******************************************************************  
  ! ----------------- TEST NON ANALYTIC ------------------------------
  ! ******************************************************************
  
  ! --------------------------------------------------------------------------
  !   Test case periodic-periodic non analytic
  !----------------------------------------------------------------------------
  

  ! ----> allocation table for field
  allocate(point1(nc1 + 1))
  allocate(point2(nc2 + 1))
  allocate(tab_values(nc1 + 1,nc2 + 1))
  do j=1,nc2 + 1
     do i=1,nc1 + 1
        point1(i)       = real(i-1,f64)*h1 + ETA1MIN 
        point2(j)       = real(j-1,f64)*h2 + ETA2MIN 
        tab_values(i,j)  = test_function_perper(point1(i),point2(j),(/0.0_f64/))
     end do
  end do
  
  ! ----> initializatio of the interpolator for the field
  
  call sll_s_ad2d_interpolator_init( &
       interp_2d, &
       NUM_CELLS1+1, &
       NUM_CELLS2+1, &
       ETA1MIN, &
       ETA1MAX, &
       ETA2MIN, &
       ETA2MAX, &
       sll_p_periodic, &
       sll_p_periodic,&
       sll_p_periodic,&
       sll_p_periodic,&
       SPLINE_DEG1, &
       SPLINE_DEG2)

  ! ----> initialization of the field
  
  call doubly_periodic_discrete%init( &
       "doubly_periodic_discrete", &
       interp_2d, &
       T, &
       sll_p_periodic, &
       sll_p_periodic,&
       sll_p_periodic,&
       sll_p_periodic,&
       point1,&
       nc1+1,&
       point2,&
       nc2+1)

  ! ------- > allocation values of field
  call doubly_periodic_discrete%set_field_data(tab_values)
  ! --------> Compute coefficients of the field
  call doubly_periodic_discrete%update_interpolation_coefficients( )
  

  ! -------> compute error norm L2 and H1
  normL2_5 = 0.0_f64
  normH1_5 = 0.0_f64
  do j=1,nc2 + 1
     do i=1,nc1 + 1 
        eta1 = real(i-1,f64)*h1 + ETA1MIN 
        eta2 = real(j-1,f64)*h2 + ETA2MIN
        node_val   = doubly_periodic_discrete%value_at_point(eta1,eta2)
        grad1_node_val = doubly_periodic_discrete%first_deriv_eta1_value_at_point(&
                                                                              eta1, eta2)
        grad2_node_val = doubly_periodic_discrete%first_deriv_eta2_value_at_point(&
                                                                              eta1, eta2)
        ref        = test_function_perper(eta1,eta2,(/0.0_f64/))
        grad1ref   = test_function_perper_der1(eta1,eta2,(/0.0_f64/))
        grad2ref   = test_function_perper_der2(eta1,eta2,(/0.0_f64/))

        if(PRINT_COMPARISON) then
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', node_val, &
                'theoretical = ', ref, 'difference=', node_val-ref
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad1_node_val, &
                'theoretical = ', grad1ref, 'difference=',grad1ref-grad1_node_val
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad2_node_val, &
                'theoretical = ', grad2ref, 'difference=',grad2ref-grad2_node_val
        end if
        
        normL2_5    = normL2_5 + (node_val-ref)**2*h1*h2
        normH1_5    = normH1_5 + ((grad1_node_val-grad1ref)**2+&
             (grad2_node_val-grad2ref)**2)*h1*h2
        
     end do
  end do
  ! -------> field visualization 
  call doubly_periodic_discrete%write_to_file(1)


  ! -------> delete field
  call doubly_periodic_discrete%free()

  ! -------> delete table
  DEALLOCATE(point1)
  DEALLOCATE(point2)
  DEALLOCATE(tab_values)
  
  ! --------------------------------------------------------------------------
  !   Test case periodic-dirichlet non analytic
  !----------------------------------------------------------------------------

  ! ----> allocation table for field
  allocate(point1(nc1 + 1))
  allocate(point2(nc2 + 1))
  allocate(tab_values(nc1 + 1,nc2 + 1))
  do j=1,nc2 + 1
     do i=1,nc1 + 1
        point1(i)       = real(i-1,f64)*h1 + ETA1MIN 
        point2(j)       = real(j-1,f64)*h2 + ETA2MIN 
        tab_values(i,j)  = test_function_perdir(point1(i),point2(j),(/0.0_f64/))
     end do
  end do
  
  ! ----> initializatio of the interpolator for the field
  
  call sll_s_ad2d_interpolator_init( &
       interp_2d, &
       NUM_CELLS1+1, &
       NUM_CELLS2+1, &
       ETA1MIN, &
       ETA1MAX, &
       ETA2MIN, &
       ETA2MAX, &
       sll_p_periodic, &
       sll_p_periodic,&
       sll_p_dirichlet,&
       sll_p_dirichlet,&
       SPLINE_DEG1, &
       SPLINE_DEG2)
  
  ! ----> initialization of the field
  
  call periodic_dirichlet_discrete%init( &
       "periodic_dirichlet_discrete", &
       interp_2d, &
       T, &
       sll_p_periodic, &
       sll_p_periodic,&
       sll_p_dirichlet,&
       sll_p_dirichlet,&
       point1,&
       nc1+1,&
       point2,&
       nc2+1)
  
  ! ------- > allocation values of field
  call periodic_dirichlet_discrete%set_field_data(tab_values)
  ! --------> Compute coefficients of the field
  call periodic_dirichlet_discrete%update_interpolation_coefficients( )
  

  ! -------> compute error norm L2 and H1
  normL2_6 = 0.0_f64
  normH1_6 = 0.0_f64
  do j=1,nc2 + 1
     do i=1,nc1 + 1 
        eta1 = real(i-1,f64)*h1 + ETA1MIN 
        eta2 = real(j-1,f64)*h2 + ETA2MIN
        node_val   = periodic_dirichlet_discrete%value_at_point(eta1,eta2)
        grad1_node_val = &
             periodic_dirichlet_discrete%first_deriv_eta1_value_at_point(&
             eta1, eta2)
        grad2_node_val = &
             periodic_dirichlet_discrete%first_deriv_eta2_value_at_point(&
             eta1, eta2)
        ref        = test_function_perdir(eta1,eta2,(/0.0_f64/))
        grad1ref   = test_function_perdir_der1(eta1,eta2,(/0.0_f64/))
        grad2ref   = test_function_perdir_der2(eta1,eta2,(/0.0_f64/))
        if(PRINT_COMPARISON) then
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', node_val, &
                'theoretical = ', ref, 'difference=', node_val-ref
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad1_node_val, &
                'theoretical = ', grad1ref, 'difference=',grad1ref-grad1_node_val
           
        end if
        
        normL2_6    = normL2_6 + (node_val-ref)**2*h1*h2
        normH1_6    = normH1_6 + ((grad1_node_val-grad1ref)**2+&
             (grad2_node_val-grad2ref)**2)*h1*h2
        
     end do
  end do
  
  ! -------> field visualization 
  call periodic_dirichlet_discrete%write_to_file(1)


  ! -------> delete field
  call periodic_dirichlet_discrete%free()

  ! -------> delete table
  DEALLOCATE(point1)
  DEALLOCATE(point2)
  DEALLOCATE(tab_values)

  ! --------------------------------------------------------------------------
  !   Test case dirichlet-periodic non analytic
  !----------------------------------------------------------------------------

  ! ----> allocation table for field
  allocate(point1(nc1 + 1))
  allocate(point2(nc2 + 1))
  allocate(tab_values(nc1 + 1,nc2 + 1))
  do j=1,nc2 + 1
     do i=1,nc1 + 1
        point1(i)       = real(i-1,f64)*h1 + ETA1MIN 
        point2(j)       = real(j-1,f64)*h2 + ETA2MIN 
        tab_values(i,j)  = test_function_dirper(point1(i),point2(j),(/0.0_f64/))
     end do
  end do
  
  ! ----> initializatio of the interpolator for the field
  
  call sll_s_ad2d_interpolator_init( &
       interp_2d, &
       NUM_CELLS1+1, &
       NUM_CELLS2+1, &
       ETA1MIN, &
       ETA1MAX, &
       ETA2MIN, &
       ETA2MAX, &
       sll_p_dirichlet, &
       sll_p_dirichlet,&
       sll_p_periodic,&
       sll_p_periodic,&
       SPLINE_DEG1, &
       SPLINE_DEG2)
  
  ! ----> initialization of the field
  
  call dirichlet_periodic_discrete%init( &
       "dirichlet_periodic_discrete", &
       interp_2d, &
       T, &
       sll_p_dirichlet, &
       sll_p_dirichlet,&
       sll_p_periodic,&
       sll_p_periodic,&
       point1,&
       nc1+1,&
       point2,&
       nc2+1)
  
  ! ------- > allocation values of field
  call dirichlet_periodic_discrete%set_field_data(tab_values)
  ! --------> Compute coefficients of the field
  call dirichlet_periodic_discrete%update_interpolation_coefficients( )
  

  ! -------> compute error norm L2 and H1
  normL2_7 = 0.0_f64
  normH1_7 = 0.0_f64
  do j=1,nc2 + 1
     do i=1,nc1 + 1 
        eta1 = real(i-1,f64)*h1 + ETA1MIN 
        eta2 = real(j-1,f64)*h2 + ETA2MIN
        node_val   = dirichlet_periodic_discrete%value_at_point(eta1,eta2)
        grad1_node_val = dirichlet_periodic_discrete%first_deriv_eta1_value_at_point(&
                                                                              eta1, eta2)
        grad2_node_val = dirichlet_periodic_discrete%first_deriv_eta2_value_at_point(&
                                                                              eta1, eta2)
        ref        = test_function_dirper(eta1,eta2,(/0.0_f64/))
        grad1ref   = test_function_dirper_der1(eta1,eta2,(/0.0_f64/))
        grad2ref   = test_function_dirper_der2(eta1,eta2,(/0.0_f64/))
        if(PRINT_COMPARISON) then
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', node_val, &
                'theoretical = ', ref, 'difference=', node_val-ref
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad1_node_val, &
                'theoretical = ', grad1ref, 'difference=',grad1ref-grad1_node_val
           
        end if
        
        normL2_7    = normL2_7 + (node_val-ref)**2*h1*h2
        normH1_7    = normH1_7 + ((grad1_node_val-grad1ref)**2+&
             (grad2_node_val-grad2ref)**2)*h1*h2
        
     end do
  end do
  
  ! -------> field visualization 
  call dirichlet_periodic_discrete%write_to_file(1)


  ! -------> delete field
  call dirichlet_periodic_discrete%free()

  ! -------> delete table
  DEALLOCATE(point1)
  DEALLOCATE(point2)
  DEALLOCATE(tab_values)

  ! --------------------------------------------------------------------------
  !   Test case dirichlet-dirichlet non analytic
  !----------------------------------------------------------------------------

  ! ----> allocation table for field
  allocate(point1(nc1 + 1))
  allocate(point2(nc2 + 1))
  allocate(tab_values(nc1 + 1,nc2 + 1))
  do j=1,nc2 + 1
     do i=1,nc1 + 1
        point1(i)       = real(i-1,f64)*h1 + ETA1MIN 
        point2(j)       = real(j-1,f64)*h2 + ETA2MIN 
        tab_values(i,j)  = test_function_dirdir(point1(i),point2(j),(/0.0_f64/))
     end do
  end do
  
  ! ----> initializatio of the interpolator for the field
  
  call sll_s_ad2d_interpolator_init( &
       interp_2d, &
       NUM_CELLS1+1, &
       NUM_CELLS2+1, &
       ETA1MIN, &
       ETA1MAX, &
       ETA2MIN, &
       ETA2MAX, &
       sll_p_dirichlet, &
       sll_p_dirichlet,&
       sll_p_dirichlet,&
       sll_p_dirichlet,&
       SPLINE_DEG1, &
       SPLINE_DEG2)
  
  ! ----> initialization of the field
  
  call dirichlet_dirichlet_discrete%init( &
       "dirichlet_dirichlet_discrete", &
       interp_2d, &
       T, &
       sll_p_dirichlet, &
       sll_p_dirichlet,&
       sll_p_dirichlet,&
       sll_p_dirichlet,&
       point1,&
       nc1+1,&
       point2,&
       nc2+1)
  
  ! ------- > allocation values of field
  call dirichlet_dirichlet_discrete%set_field_data(tab_values)
  ! --------> Compute coefficients of the field
  call dirichlet_dirichlet_discrete%update_interpolation_coefficients( )
  

  ! -------> compute error norm L2 and H1
  normL2_8 = 0.0_f64
  normH1_8 = 0.0_f64
  do j=1,nc2 + 1
     do i=1,nc1 + 1 
        eta1 = real(i-1,f64)*h1 + ETA1MIN 
        eta2 = real(j-1,f64)*h2 + ETA2MIN
        node_val   = dirichlet_dirichlet_discrete%value_at_point(eta1,eta2)
        grad1_node_val = &
             dirichlet_dirichlet_discrete%first_deriv_eta1_value_at_point(&
             eta1, eta2)
        grad2_node_val = &
             dirichlet_dirichlet_discrete%first_deriv_eta2_value_at_point(&
             eta1, eta2)
        ref        = test_function_dirdir(eta1,eta2,(/0.0_f64/))
        grad1ref   = test_function_dirdir_der1(eta1,eta2,(/0.0_f64/))
        grad2ref   = test_function_dirdir_der2(eta1,eta2,(/0.0_f64/))
        if(PRINT_COMPARISON) then
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', node_val, &
                'theoretical = ', ref, 'difference=', node_val-ref
           print *, '(eta1,eta2) = ', eta1, eta2, 'calculated = ', grad1_node_val, &
                'theoretical = ', grad1ref, 'difference=',grad1ref-grad1_node_val
           
        end if
        
        normL2_8    = normL2_8 + (node_val-ref)**2*h1*h2
        normH1_8    = normH1_8 + ((grad1_node_val-grad1ref)**2+&
             (grad2_node_val-grad2ref)**2)*h1*h2
        
     end do
  end do
  
  ! -------> field visualization 
  call dirichlet_dirichlet_discrete%write_to_file(1)

  ! -------> delete field
  call dirichlet_dirichlet_discrete%free()

  ! -------> delete table
  DEALLOCATE(point1)
  DEALLOCATE(point2)
  DEALLOCATE(tab_values)

  ! **********************  TESTS **************************************
  
  print*, '-------------------------------------------------------'
  print*, ' PERIODIC-PERIODIC ANALYTIC' 
  print*, '-------------------------------------------------------'
  print *,'Norm L2',sqrt(normL2_1),'Norm H1',sqrt(normH1_1),&
       h1**(SPLINE_DEG1),  h1**(SPLINE_DEG1-1)
  
  print*, '-------------------------------------------------------'
  print*, ' PERIODIC-DIRICHLET ANALYTIC' 
  print*, '-------------------------------------------------------'
  print *,'Norm L2',sqrt(normL2_2),'Norm H1',sqrt(normH1_2),&
       h1**(SPLINE_DEG1),  h1**(SPLINE_DEG1-1)
  
  print*, '-------------------------------------------------------'
  print*, ' DIRICHLET-PERIODIC ANALYTIC' 
  print*, '-------------------------------------------------------'
  print *,'Norm L2',sqrt(normL2_3),'Norm H1',sqrt(normH1_3),&
       h1**(SPLINE_DEG1),  h1**(SPLINE_DEG1-1)
  
  print*, '-------------------------------------------------------'
  print*, ' DIRICHLET-DIRCHLET ANALYTIC' 
  print*, '-------------------------------------------------------'
  print *,'Norm L2',sqrt(normL2_4),'Norm H1',sqrt(normH1_4),&
       h1**(SPLINE_DEG1),  h1**(SPLINE_DEG1-1)

  print*, '-------------------------------------------------------'
  print*, ' PERIODIC-PERIODIC NON ANALYTIC' 
  print*, '-------------------------------------------------------'
  print *,'Norm L2',sqrt(normL2_5),'Norm H1',sqrt(normH1_5),&
       h1**(SPLINE_DEG1),  h1**(SPLINE_DEG1-1)
  
  print*, '-------------------------------------------------------'
  print*, ' PERIODIC-DIRICHLET NON ANALYTIC' 
  print*, '-------------------------------------------------------'
  print *,'Norm L2',sqrt(normL2_6),'Norm H1',sqrt(normH1_6),&
       h1**(SPLINE_DEG1),  h1**(SPLINE_DEG1-1)

  print*, '-------------------------------------------------------'
  print*, ' DIRICHLET-PERIODIC NON ANALYTIC' 
  print*, '-------------------------------------------------------'
  print *,'Norm L2',sqrt(normL2_7),'Norm H1',sqrt(normH1_7),&
       h1**(SPLINE_DEG1),  h1**(SPLINE_DEG1-1)
  
  print*, '-------------------------------------------------------'
  print*, ' DIRICHLET-DIRCHLET NON ANALYTIC' 
  print*, '-------------------------------------------------------'
  print *,'Norm L2',sqrt(normL2_8),'Norm H1',sqrt(normH1_8),&
       h1**(SPLINE_DEG1),  h1**(SPLINE_DEG1-1)
  
  if ( ( sqrt(normL2_1) <= h1**(SPLINE_DEG1))   .AND. &
       ( sqrt(normL2_2) <= h1**(SPLINE_DEG1))   .AND. &
       ( sqrt(normL2_3) <= h1**(SPLINE_DEG1))   .AND. &
       ( sqrt(normL2_4) <= h1**(SPLINE_DEG1))   .AND. &
       ( sqrt(normL2_5) <= h1**(SPLINE_DEG1))   .AND. &
       ( sqrt(normL2_6) <= h1**(SPLINE_DEG1))   .AND. &
       ( sqrt(normL2_7) <= h1**(SPLINE_DEG1))   .AND. &
       ( sqrt(normL2_8) <= h1**(SPLINE_DEG1))   .AND. &
       ( sqrt(normH1_1) <= h1**(SPLINE_DEG1-1)) .AND. &
       ( sqrt(normH1_2) <= h1**(SPLINE_DEG1-1)) .AND. &
       ( sqrt(normH1_3) <= h1**(SPLINE_DEG1-1)) .AND. &
       ( sqrt(normH1_4) <= h1**(SPLINE_DEG1-1)) .AND. &
       ( sqrt(normH1_5) <= h1**(SPLINE_DEG1-1)) .AND. &
       ( sqrt(normH1_6) <= h1**(SPLINE_DEG1-1)) .AND. &
       ( sqrt(normH1_7) <= h1**(SPLINE_DEG1-1)) .AND. &
       ( sqrt(normH1_8) <= h1**(SPLINE_DEG1-1)) .AND. &
       ( sqrt(normH1_8) <= h1**(SPLINE_DEG1-1))) then
     
     
     print *, 'PASSED'

  end if

end program unit_test_2d

