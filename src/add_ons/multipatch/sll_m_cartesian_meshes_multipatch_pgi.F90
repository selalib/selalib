
!!------------------------------------------------------------------------------
!! <auto-generated>
!!     This code was generated by a tool.
!!     Changes to this file may cause incorrect behavior and will be lost if
!!     the code is regenerated.
!! </auto-generated>
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! <auto-generated>
!!     This code was generated by a tool.
!!     Changes to this file may cause incorrect behavior and will be lost if
!!     the code is regenerated.
!! </auto-generated>
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! <auto-generated>
!!     This code was generated by a tool.
!!     Changes to this file may cause incorrect behavior and will be lost if
!!     the code is regenerated.
!! </auto-generated>
!!------------------------------------------------------------------------------
!**************************************************************
!  Copyright INRIA
!  Authors : 
!     CALVI project team
!  
!  This code SeLaLib (for Semi-Lagrangian-Library) 
!  is a parallel library for simulating the plasma turbulence 
!  in a tokamak.
!  
!  This software is governed by the CeCILL-B license 
!  under French law and abiding by the rules of distribution 
!  of free software.  You can  use, modify and redistribute 
!  the software under the terms of the CeCILL-B license as 
!  circulated by CEA, CNRS and INRIA at the following URL
!  "http://www.cecill.info". 
!**************************************************************

!> @file sll_cartesian_multipatch.F90
!> @ingroup sll_multipatch 
!> @brief basic types to describe a collection of logical meshes
!> associated with the decomposition of a physical region with the 
!> multipatch approach.

module sll_m_cartesian_meshes_multipatch
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++













    ! Note the semicolon when the SLL_ASSERT() macro gets expanded. We need
    ! that this be a part of the macro since we also want to be able to
    ! use this macro call within other macros. If the expansion yields 
    ! nothing (second case) then we don't want dangling semicolons...









use sll_m_assert







 
use sll_m_memory, only : sll_s_test_error_code

































 


















  




use sll_m_working_precision








  use sll_m_cartesian_meshes, only: &
    sll_f_new_cartesian_mesh_2d, &
    sll_t_cartesian_mesh_2d, &
    sll_t_cartesian_mesh_2d_ptr

  implicit none

  public :: &
    sll_f_new_cartesian_mesh_multipatch_2d, &
    sll_t_cartesian_mesh_multipatch_2d, &
    sll_o_delete

  private
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  !> @brief basic logical mesh multipatch object.
  type sll_t_cartesian_mesh_multipatch_2d
     integer(kind=i32) :: number_patches
     type(sll_t_cartesian_mesh_2d_ptr), dimension(:), pointer :: meshes
   contains
     procedure, pass :: initialize_patch => initialize_patch_lmmp2d
     procedure, pass :: get_num_cells1   => get_num_cells1_lmmp2d
     procedure, pass :: get_num_cells2   => get_num_cells2_lmmp2d
     procedure, pass :: get_eta1_min     => get_eta1_min_lmmp2d
     procedure, pass :: get_eta1_max     => get_eta1_max_lmmp2d
     procedure, pass :: get_eta2_min     => get_eta2_min_lmmp2d
     procedure, pass :: get_eta2_max     => get_eta2_max_lmmp2d
     procedure, pass :: get_delta_eta1   => get_delta_eta1_lmmp2d
     procedure, pass :: get_delta_eta2   => get_delta_eta2_lmmp2d
     procedure, pass :: get_cartesian_mesh => get_cartesian_mesh_lmmp2d
  end type sll_t_cartesian_mesh_multipatch_2d

  interface sll_o_delete
     module procedure delete_logical_mesh_lmmp2d
  end interface sll_o_delete


contains

  !> @brief allocates the memory space for a new 2D multipatch logical mesh 
  !> in the heap and returns a pointer to the newly allocated object. 
  !> This object must be then initialized by the appropriate call to the 
  !> initialize_patch method.
  !> @param num_cells1 integer denoting the number of cells.
  !> @param eta1_min optional double precision value which represents the 
  !> minimum value of the eta1 parameter in the logical mesh.
  !> @param eta1_max optional double precision value which represents the 
  !> maximum value of the eta1 parameter in the logical mesh.
  !> return a pointer to the newly allocated object.
  function sll_f_new_cartesian_mesh_multipatch_2d( num_patches ) result(m)
    type(sll_t_cartesian_mesh_multipatch_2d), pointer :: m
    integer(kind=i32), intent(in) :: num_patches
    integer(kind=i32) :: ierr
    allocate(m, stat=ierr)
 call sll_s_test_error_code(ierr, 'Memory allocation Failure.', "<stdin>", 83)

    allocate(m%meshes(num_patches), stat=ierr)
 call sll_s_test_error_code(ierr, 'Memory allocation Failure.', "<stdin>", 84)

    m%number_patches = num_patches
  end function sll_f_new_cartesian_mesh_multipatch_2d


  !> @brief initializes a previously allocated multipatch 2d logical mesh.
  !> @param mp the multipatch object, passed implicitly.
  !> @param num_cells1 integer denoting the number of cells in first direction.
  !> @param num_cells2 integer denoting the number of cells in second direction.
  !> @param eta1_min optional double precision value which represents the 
  !> minimum value of the eta1 parameter in the logical mesh.
  !> @param eta1_max optional double precision value which represents the 
  !> maximum value of the eta1 parameter in the logical mesh.
  !> @param eta2_min optional double precision value which represents the 
  !> minimum value of the eta1 parameter in the logical mesh.
  !> @param eta2_max optional double precision value which represents the 
  !> maximum value of the eta1 parameter in the logical mesh.
  subroutine initialize_patch_lmmp2d( &
    mp, &
    patch, &
    num_cells1, &
    num_cells2, &
    eta1_min, &
    eta1_max, &
    eta2_min, &
    eta2_max )

    class(sll_t_cartesian_mesh_multipatch_2d), intent(inout) :: mp
    integer(kind=i32), intent(in)  :: patch
    integer(kind=i32), intent(in)  :: num_cells1
    integer(kind=i32), intent(in)  :: num_cells2
    real(kind=f64), optional, intent(in) :: eta1_min
    real(kind=f64), optional, intent(in) :: eta1_max
    real(kind=f64), optional, intent(in) :: eta2_min
    real(kind=f64), optional, intent(in) :: eta2_max

    if( (patch < 0) .or. (patch > mp%number_patches - 1) ) then
       print *, 'ERROR, initialize_patch_2d(): the patch argument has to be ',&
            'between 0 and the number of patches - 1'
       stop
    end if
    print *, 'initializing patch: ', patch, size(mp%meshes)
    mp%meshes(patch+1)%lm => sll_f_new_cartesian_mesh_2d( &
                                num_cells1, &
                                num_cells2, &
                                eta1_min, &
                                eta1_max, &
                                eta2_min, &
                                eta2_max )
  end subroutine initialize_patch_lmmp2d












function get_num_cells1_lmmp2d( mp, patch ) result(res)
 integer(kind=i32) :: res
 class(sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
 integer(kind=i32), intent(in) :: patch
 
 res = mp%meshes(patch+1)%lm%num_cells1
 end function get_num_cells1_lmmp2d
function get_num_cells2_lmmp2d( mp, patch ) result(res)
 integer(kind=i32) :: res
 class(sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
 integer(kind=i32), intent(in) :: patch
 
 res = mp%meshes(patch+1)%lm%num_cells2
 end function get_num_cells2_lmmp2d
function get_eta1_min_lmmp2d( mp, patch ) result(res)
 real(kind=f64) :: res
 class( sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
 integer(kind=i32), intent(in) :: patch
 
 res = mp%meshes(patch+1)%lm% eta1_min
 end function get_eta1_min_lmmp2d
function get_eta1_max_lmmp2d( mp, patch ) result(res)
 real(kind=f64) :: res
 class( sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
 integer(kind=i32), intent(in) :: patch
 
 res = mp%meshes(patch+1)%lm% eta1_max
 end function get_eta1_max_lmmp2d
function get_eta2_min_lmmp2d( mp, patch ) result(res)
 real(kind=f64) :: res
 class( sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
 integer(kind=i32), intent(in) :: patch
 
 res = mp%meshes(patch+1)%lm% eta2_min
 end function get_eta2_min_lmmp2d
function get_eta2_max_lmmp2d( mp, patch ) result(res)
 real(kind=f64) :: res
 class( sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
 integer(kind=i32), intent(in) :: patch
 
 res = mp%meshes(patch+1)%lm% eta2_max
 end function get_eta2_max_lmmp2d
function get_delta_eta1_lmmp2d( mp, patch ) result(res)
 real(kind=f64) :: res
 class(sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
 integer(kind=i32), intent(in) :: patch
 
 res = mp%meshes(patch+1)%lm%delta_eta1
 end function get_delta_eta1_lmmp2d
function get_delta_eta2_lmmp2d( mp, patch ) result(res)
 real(kind=f64) :: res
 class(sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
 integer(kind=i32), intent(in) :: patch
 
 res = mp%meshes(patch+1)%lm%delta_eta2
 end function get_delta_eta2_lmmp2d




  function get_cartesian_mesh_lmmp2d( mp, patch ) result(res)
    type(sll_t_cartesian_mesh_2d), pointer               :: res
    class(sll_t_cartesian_mesh_multipatch_2d), intent(in) :: mp
    integer(kind=i32), intent(in)                            :: patch
    
    res => mp%meshes(patch+1)%lm
  end function get_cartesian_mesh_lmmp2d

  subroutine delete_logical_mesh_lmmp2d( mp )
    type(sll_t_cartesian_mesh_multipatch_2d), pointer :: mp
    integer(kind=i32) :: ierr
    deallocate(mp%meshes, stat= ierr)
 call sll_s_test_error_code( ierr, 'Error in memory deallocation.', "<stdin>", 169)
 nullify(mp%meshes)

    deallocate(mp, stat= ierr)
 call sll_s_test_error_code( ierr, 'Error in memory deallocation.', "<stdin>", 170)
 nullify(mp)

  end subroutine delete_logical_mesh_lmmp2d

end module sll_m_cartesian_meshes_multipatch

